#+TITLE: High-performance ocean wave simulation model for studying marine object behaviour
#+AUTHOR: Ivan Gankevich
#+DATE: St. Petersburg, 2016
#+LANGUAGE: en
#+LATEX_CLASS: gost
#+LATEX_CLASS_OPTIONS: [hidelinks,fontsize=14pt,paper=a4,pagesize,DIV=calc]
#+LATEX_HEADER_EXTRA: \input{preamble}
#+LATEX_HEADER_EXTRA: \organization{Saint Petersburg State University}
#+LATEX_HEADER_EXTRA: \manuscript{}
#+LATEX_HEADER_EXTRA: \degree{thesis for candidate of sciences degree}
#+LATEX_HEADER_EXTRA: \speciality{Speciality 05.13.18\\Mathematical modeling, numerical methods and programme complexes}
#+LATEX_HEADER_EXTRA: \supervisor{Supervisor\\Alexander Degtyarev}
#+LATEX_HEADER_EXTRA: \newcites{published}{Publications on the subject of thesis}
#+OPTIONS: todo:nil title:nil ':t H:5
#+STARTUP: indent

* Config                                                           :noexport:
** Produce data for Q-Q and ACF plots
#+begin_src sh :exports none :results verbatim
root=$(pwd)
for testname in propagating_wave standing_wave
do
    wd=$root/build/$testname
    rm -rf $wd
    mkdir -p $wd
    cd $wd
    arma -c $root/config/$testname.arma 2>&1
done
#+end_src

#+RESULTS:
#+begin_example
Input file                     = /home/igankevich/workspace/phd-diss/config/propagating_wave.arma
ACF grid size                  = (20,10,10)
ACF grid patch size            = (0.526316,0.555556,0.555556)
Output grid size               = (200,40,40)
Output grid patch size         = (1,1,1)
AR order                       = (10,10,10)
Do least squares               = 0
ACF function                   = propagating_wave
Model                          = MA
MA algorithm                   = fixed_point_iteration
Verification scheme            = manual
ACF variance = 5
fixed_point_iteration:Iteration=0, var_wn=2.70831
fixed_point_iteration:Iteration=1, var_wn=1.93791
fixed_point_iteration:Iteration=2, var_wn=1.54801
fixed_point_iteration:Iteration=3, var_wn=1.31202
fixed_point_iteration:Iteration=4, var_wn=1.15328
fixed_point_iteration:Iteration=5, var_wn=1.0386
fixed_point_iteration:Iteration=6, var_wn=0.951442
fixed_point_iteration:Iteration=7, var_wn=0.882674
fixed_point_iteration:Iteration=8, var_wn=0.82688
fixed_point_iteration:Iteration=9, var_wn=0.780623
fixed_point_iteration:Iteration=10, var_wn=0.74161
fixed_point_iteration:Iteration=11, var_wn=0.708244
fixed_point_iteration:Iteration=12, var_wn=0.679374
fixed_point_iteration:Iteration=13, var_wn=0.654145
fixed_point_iteration:Iteration=14, var_wn=0.63191
fixed_point_iteration:Iteration=15, var_wn=0.612168
fixed_point_iteration:Iteration=16, var_wn=0.594523
fixed_point_iteration:Iteration=17, var_wn=0.578663
fixed_point_iteration:Iteration=18, var_wn=0.564333
fixed_point_iteration:Iteration=19, var_wn=0.551325
fixed_point_iteration:Iteration=20, var_wn=0.539469
fixed_point_iteration:Iteration=21, var_wn=0.528623
fixed_point_iteration:Iteration=22, var_wn=0.518666
fixed_point_iteration:Iteration=23, var_wn=0.509497
fixed_point_iteration:Iteration=24, var_wn=0.50103
fixed_point_iteration:Iteration=25, var_wn=0.493191
fixed_point_iteration:Iteration=26, var_wn=0.485916
fixed_point_iteration:Iteration=27, var_wn=0.479148
fixed_point_iteration:Iteration=28, var_wn=0.472841
fixed_point_iteration:Iteration=29, var_wn=0.466951
fixed_point_iteration:Iteration=30, var_wn=0.461442
fixed_point_iteration:Iteration=31, var_wn=0.456279
fixed_point_iteration:Iteration=32, var_wn=0.451435
fixed_point_iteration:Iteration=33, var_wn=0.446882
fixed_point_iteration:Iteration=34, var_wn=0.442597
fixed_point_iteration:Iteration=35, var_wn=0.43856
fixed_point_iteration:Iteration=36, var_wn=0.434752
fixed_point_iteration:Iteration=37, var_wn=0.431155
fixed_point_iteration:Iteration=38, var_wn=0.427755
fixed_point_iteration:Iteration=39, var_wn=0.424538
fixed_point_iteration:Iteration=40, var_wn=0.42149
fixed_point_iteration:Iteration=41, var_wn=0.418601
fixed_point_iteration:Iteration=42, var_wn=0.415859
fixed_point_iteration:Iteration=43, var_wn=0.413256
fixed_point_iteration:Iteration=44, var_wn=0.410782
fixed_point_iteration:Iteration=45, var_wn=0.40843
fixed_point_iteration:Iteration=46, var_wn=0.406191
fixed_point_iteration:Iteration=47, var_wn=0.404059
fixed_point_iteration:Iteration=48, var_wn=0.402029
fixed_point_iteration:Iteration=49, var_wn=0.400092
fixed_point_iteration:Iteration=50, var_wn=0.398246
fixed_point_iteration:Iteration=51, var_wn=0.396483
fixed_point_iteration:Iteration=52, var_wn=0.3948
fixed_point_iteration:Iteration=53, var_wn=0.393193
fixed_point_iteration:Iteration=54, var_wn=0.391656
fixed_point_iteration:Iteration=55, var_wn=0.390188
fixed_point_iteration:Iteration=56, var_wn=0.388782
fixed_point_iteration:Iteration=57, var_wn=0.387438
fixed_point_iteration:Iteration=58, var_wn=0.386151
fixed_point_iteration:Iteration=59, var_wn=0.384918
fixed_point_iteration:Iteration=60, var_wn=0.383738
fixed_point_iteration:Iteration=61, var_wn=0.382606
fixed_point_iteration:Iteration=62, var_wn=0.381522
fixed_point_iteration:Iteration=63, var_wn=0.380482
fixed_point_iteration:Iteration=64, var_wn=0.379485
fixed_point_iteration:Iteration=65, var_wn=0.378528
fixed_point_iteration:Iteration=66, var_wn=0.37761
fixed_point_iteration:Iteration=67, var_wn=0.376729
fixed_point_iteration:Iteration=68, var_wn=0.375882
fixed_point_iteration:Iteration=69, var_wn=0.37507
fixed_point_iteration:Iteration=70, var_wn=0.374289
fixed_point_iteration:Iteration=71, var_wn=0.373539
fixed_point_iteration:Iteration=72, var_wn=0.372818
fixed_point_iteration:Iteration=73, var_wn=0.372126
fixed_point_iteration:Iteration=74, var_wn=0.37146
fixed_point_iteration:Iteration=75, var_wn=0.37082
fixed_point_iteration:Iteration=76, var_wn=0.370204
fixed_point_iteration:Iteration=77, var_wn=0.369612
fixed_point_iteration:Iteration=78, var_wn=0.369042
fixed_point_iteration:Iteration=79, var_wn=0.368494
fixed_point_iteration:Iteration=80, var_wn=0.367966
fixed_point_iteration:Iteration=81, var_wn=0.367458
fixed_point_iteration:Iteration=82, var_wn=0.366969
fixed_point_iteration:Iteration=83, var_wn=0.366499
fixed_point_iteration:Iteration=84, var_wn=0.366046
fixed_point_iteration:Iteration=85, var_wn=0.36561
fixed_point_iteration:Iteration=86, var_wn=0.365189
fixed_point_iteration:Iteration=87, var_wn=0.364785
fixed_point_iteration:Iteration=88, var_wn=0.364395
fixed_point_iteration:Iteration=89, var_wn=0.364019
fixed_point_iteration:Iteration=90, var_wn=0.363657
fixed_point_iteration:Iteration=91, var_wn=0.363309
fixed_point_iteration:Iteration=92, var_wn=0.362973
fixed_point_iteration:Iteration=93, var_wn=0.362649
fixed_point_iteration:Iteration=94, var_wn=0.362337
fixed_point_iteration:Iteration=95, var_wn=0.362036
fixed_point_iteration:Iteration=96, var_wn=0.361746
fixed_point_iteration:Iteration=97, var_wn=0.361466
fixed_point_iteration:Iteration=98, var_wn=0.361197
fixed_point_iteration:Iteration=99, var_wn=0.360937
fixed_point_iteration:Iteration=100, var_wn=0.360686
fixed_point_iteration:Iteration=101, var_wn=0.360444
fixed_point_iteration:Iteration=102, var_wn=0.360211
fixed_point_iteration:Iteration=103, var_wn=0.359986
fixed_point_iteration:Iteration=104, var_wn=0.359769
fixed_point_iteration:Iteration=105, var_wn=0.35956
fixed_point_iteration:Iteration=106, var_wn=0.359358
fixed_point_iteration:Iteration=107, var_wn=0.359163
fixed_point_iteration:Iteration=108, var_wn=0.358975
fixed_point_iteration:Iteration=109, var_wn=0.358794
fixed_point_iteration:Iteration=110, var_wn=0.358619
fixed_point_iteration:Iteration=111, var_wn=0.35845
fixed_point_iteration:Iteration=112, var_wn=0.358288
fixed_point_iteration:Iteration=113, var_wn=0.35813
fixed_point_iteration:Iteration=114, var_wn=0.357979
fixed_point_iteration:Iteration=115, var_wn=0.357832
fixed_point_iteration:Iteration=116, var_wn=0.357691
fixed_point_iteration:Iteration=117, var_wn=0.357555
fixed_point_iteration:Iteration=118, var_wn=0.357423
fixed_point_iteration:Iteration=119, var_wn=0.357296
fixed_point_iteration:Iteration=120, var_wn=0.357173
fixed_point_iteration:Iteration=121, var_wn=0.357055
fixed_point_iteration:Iteration=122, var_wn=0.356941
fixed_point_iteration:Iteration=123, var_wn=0.356831
fixed_point_iteration:Iteration=124, var_wn=0.356724
fixed_point_iteration:Iteration=125, var_wn=0.356621
fixed_point_iteration:Iteration=126, var_wn=0.356522
fixed_point_iteration:Iteration=127, var_wn=0.356426
fixed_point_iteration:Iteration=128, var_wn=0.356334
fixed_point_iteration:Iteration=129, var_wn=0.356244
fixed_point_iteration:Iteration=130, var_wn=0.356158
fixed_point_iteration:Iteration=131, var_wn=0.356075
fixed_point_iteration:Iteration=132, var_wn=0.355994
fixed_point_iteration:Iteration=133, var_wn=0.355917
fixed_point_iteration:Iteration=134, var_wn=0.355842
fixed_point_iteration:Iteration=135, var_wn=0.355769
fixed_point_iteration:Iteration=136, var_wn=0.355699
fixed_point_iteration:Iteration=137, var_wn=0.355632
fixed_point_iteration:Iteration=138, var_wn=0.355567
fixed_point_iteration:Iteration=139, var_wn=0.355504
fixed_point_iteration:Iteration=140, var_wn=0.355443
fixed_point_iteration:Iteration=141, var_wn=0.355384
fixed_point_iteration:Iteration=142, var_wn=0.355327
fixed_point_iteration:Iteration=143, var_wn=0.355273
fixed_point_iteration:Iteration=144, var_wn=0.35522
fixed_point_iteration:Iteration=145, var_wn=0.355169
fixed_point_iteration:Iteration=146, var_wn=0.355119
fixed_point_iteration:Iteration=147, var_wn=0.355072
fixed_point_iteration:Iteration=148, var_wn=0.355026
fixed_point_iteration:Iteration=149, var_wn=0.354981
fixed_point_iteration:Iteration=150, var_wn=0.354938
fixed_point_iteration:Iteration=151, var_wn=0.354897
fixed_point_iteration:Iteration=152, var_wn=0.354856
fixed_point_iteration:Iteration=153, var_wn=0.354818
fixed_point_iteration:Iteration=154, var_wn=0.35478
fixed_point_iteration:Iteration=155, var_wn=0.354744
fixed_point_iteration:Iteration=156, var_wn=0.354709
fixed_point_iteration:Iteration=157, var_wn=0.354676
fixed_point_iteration:Iteration=158, var_wn=0.354643
fixed_point_iteration:Iteration=159, var_wn=0.354612
fixed_point_iteration:Iteration=160, var_wn=0.354581
fixed_point_iteration:Iteration=161, var_wn=0.354552
fixed_point_iteration:Iteration=162, var_wn=0.354524
fixed_point_iteration:Iteration=163, var_wn=0.354496
fixed_point_iteration:Iteration=164, var_wn=0.35447
fixed_point_iteration:Iteration=165, var_wn=0.354444
fixed_point_iteration:Iteration=166, var_wn=0.35442
fixed_point_iteration:Iteration=167, var_wn=0.354396
fixed_point_iteration:Iteration=168, var_wn=0.354373
fixed_point_iteration:Iteration=169, var_wn=0.35435
fixed_point_iteration:Iteration=170, var_wn=0.354329
fixed_point_iteration:Iteration=171, var_wn=0.354308
fixed_point_iteration:Iteration=172, var_wn=0.354288
fixed_point_iteration:Iteration=173, var_wn=0.354269
fixed_point_iteration:Iteration=174, var_wn=0.35425
fixed_point_iteration:Iteration=175, var_wn=0.354232
fixed_point_iteration:Iteration=176, var_wn=0.354214
fixed_point_iteration:Iteration=177, var_wn=0.354198
fixed_point_iteration:Iteration=178, var_wn=0.354181
fixed_point_iteration:Iteration=179, var_wn=0.354165
fixed_point_iteration:Iteration=180, var_wn=0.35415
fixed_point_iteration:Iteration=181, var_wn=0.354136
fixed_point_iteration:Iteration=182, var_wn=0.354121
fixed_point_iteration:Iteration=183, var_wn=0.354108
fixed_point_iteration:Iteration=184, var_wn=0.354094
fixed_point_iteration:Iteration=185, var_wn=0.354082
fixed_point_iteration:Iteration=186, var_wn=0.354069
fixed_point_iteration:Iteration=187, var_wn=0.354057
fixed_point_iteration:Iteration=188, var_wn=0.354046
fixed_point_iteration:Iteration=189, var_wn=0.354034
fixed_point_iteration:Iteration=190, var_wn=0.354024
fixed_point_iteration:Iteration=191, var_wn=0.354013
fixed_point_iteration:Iteration=192, var_wn=0.354003
fixed_point_iteration:Iteration=193, var_wn=0.353994
WN variance = 0.353994
Input file                     = /home/igankevich/workspace/phd-diss/config/standing_wave.arma
ACF grid size                  = (10,10,10)
ACF grid patch size            = (0.277778,0.555556,0.555556)
Output grid size               = (200,40,40)
Output grid patch size         = (1,1,1)
AR order                       = (7,7,7)
Do least squares               = 0
ACF function                   = standing_wave
Model                          = AR
MA algorithm                   = fixed_point_iteration
Verification scheme            = manual
ACF variance = 5
WN variance = 0.00261323
Zeta size = (193,33,33)
NaN: 29, -nan, 1.798e+36, -1.04284e+38, inf, -1.798e+36, -1.798e+36
#+end_example

* Introduction
**** Topic relevance.
Software programmes, which simulates vessel behaviour in sea waves, are widely
used to model ship motion, estimate impact of external forces on floating
platform or other marine object, and estimate capsize probability under given
weather conditions; however, to model ocean waves most of the simulation codes
use linear wave theory
cite:shin2003nonlinear,van2007forensic,kat2001prediction,van2002development, in
the framework of which it is difficult to reproduce certain peculiarities of
wind wave climate. Among them are transition between normal and storm weather,
and sea composed of multiple wave systems --- both wind waves and swell ---
heading from multiple directions. Another shortcoming of linear wave theory is
an assumption, that wave amplitude is small compared to wave length. This makes
calculations imprecise when modelling ship motion in irregular waves, for which
the assumption does not hold. So, studying new and more advanced models and
methods for ocean simulation software may increase number of its application
scenarios and foster a study of ship motion in extreme conditions in particular.

**** State-of-the-art.
Autoregressive moving average (ARMA) model emerged in response to difficulties
encountered by practitioners who used wave simulation models developed in the
framework of linear wave theory. The problems they have encountered with
Longuet---Higgins model (a model which is entirely based on linear wave theory)
can be summarised as the following.
1. /Periodicity/. Linear wave theory approximates waves by a sum of harmonics,
   so period of the whole wavy surface realisation depends on the number of
   harmonics in the model. The more realisation size is, the more coefficients
   are required to eliminate periodicity, therefore, generation time grows
   non-linearly with realisation size. This in turn results in overall low
   efficiency of any model based on this theory, no matter how optimised the
   software implementation is.
2. /Linearity/. Linear wave theory gives mathematical definition for ocean waves
   which have small amplitudes compared to their lengths. Waves of this type
   occur mostly in the ocean, so near-shore waves as well as storm waves, for
   which this assumption does not hold, are not perfectly captured by linear
   theory.
3. /Probabilistic convergence/. Phase of a wave, which is often generated by
   pseudo random number generator (PRNG), has uniform distribution, and this
   makes wavy surface characteristics (average wave height, wave period, wave
   length etc.) sometimes converge slowly to the desired values. Convergence
   rate depends on the values generated by PRNG, so high convergence rate is not
   guaranteed.

These difficulties became a starting point in search for a new model which is
not based on linear wave theory. Autoregressive moving average (ARMA) process
studies were found to have all the required mathematical apparatus.
1. ARMA process takes auto-covariate function (ACF) as an input parameter, and
   this function can be directly obtained from wave energy or
   frequency-directional spectrum (which is the input for Longuet---Higgins
   model). So, inputs for one model can easily be converted to each other.
2. There is no small-amplitude waves assumption. Wave may have any amplitude,
   and can be generated as steep as it is possible with real ocean wave ACF.
3. Period of the realisation equals the period of PRNG, so generation time grows
   linearly with the realisation size.
4. White noise --- the only probabilistic term in ARMA process --- has
   Gaussian distribution; so, convergence rate is not probabilistic.

**** Goals and objectives.
ARMA process became the basis for ARMA ocean simulation model, however, there
was still much work to be done to make it useful in practice.
1. One have to investigate how different ACF shapes affect the choice of ARMA
   parameters (the number of moving average and autoregressive processes
   coefficients).
2. Then, investigate a possibility to generate waves of arbitrary profile, not
   only cosines (which means taking into account asymmetric distribution of wavy
   surface elevation).
3. Then, derive formulae to determine pressure field under wavy surface.
   Usually, such formulae are derived for a particular model by substituting
   wave profile into the eq. eqref:eq:problem, however, ARMA process does not
   provide explicit wave profile formula, so this problem had to be solved for
   general wavy surface (which is not defined by an analytic formula),
   without linearisation of boundaries and assumption of small-amplitude waves.
4. Finally, verify wavy surface integral characteristics to match the ones of
   real ocean waves.
5. In the final stage, develop software programme that implements ARMA model and
   pressure calculation method, and allows running simulations on both shared
   memory (SMP) and distributed memory (MPP) computer systems.

**** Scientific novelty.
ARMA model, as opposed to other ocean simulation models, does not use linear
wave theory. This makes it capable of
- generating waves with arbitrary amplitudes by adjusting wave steepness via
  ACF;
- generating waves with arbitrary profiles by adjusting asymmetry of wave
  elevation distribution via non-linear inertia-less transform (NIT).
This makes it possible to use ARMA process to model transition between normal
and storm weather taking into account climate spectra and assimilation data of a
particular ocean region, which is not possible with models based on linear wave
theory.

**** Theoretical and practical significance.
Implementing ARMA model, that does not use assumptions of linear wave theory,
will increase quality of ship motion and marine object behaviour simulation
software.

1. Since pressure field formula is derived for discrete wavy surface and without
   assumptions about wave amplitudes, it is applicable to any wavy surface of
   incompressible inviscid fluid (in particular, it is applicable to wavy
   surface generated by LH model). This allows using pressure field formula
   without being tied to ARMA model.
2. From computational point of view this formula is more efficient than the
   corresponding formula for LH model, because integrals in it are reduced to
   Fourier transforms, for which there is fast Fourier transform (FFT) family of
   algorithms, optimised for different processor architectures.
3. Since the formula is explicit, there is no need in data exchange between
   parallel processes, which allows to achieve high scalability on computer
   clusters.
4. Finally, ARMA model is itself more efficient than LH model due to vicinity of
   trigonometric functions in its formula: In fact, wavy surface is computed as
   a sum of large number of polynomials, for which there is low-level assembly
   instruction (Fused Multiply-Add) giving native performance on CPUs.

**** Methodology and research methods.
Software implementation of ARMA model and pressure field formula was created
incrementally: a prototype written in high-level engineering language
cite:mathematica10,octave2015 was rewritten in lower level language (C++).
Implementation of the same algorithm and formulae in languages of varying
levels (which involves usage of different abstractions and language primitives)
allows correcting errors, which would left unnoticed otherwise. Wavy surface,
generated by ARMA model, as well as all input parameters (ACF, distribution of
wave elevation etc.) were inspected via graphical means built into the
programming language allowing visual control of programme correctness.

**** Theses for the defence.
- Wind wave model which allows generating wavy surface realisations with large
  period and consisting of wave of arbitrary amplitudes;
- Pressure field formulae derived for this model without assumptions of linear
  wave theory;
- Software implementation of the model and the formula for shared memory (SMP)
  and distributed memory (MPP) systems.

**** Results verification and approbation.
ARMA model is verified by comparing generated wavy surface integral
characteristics (distribution of wave elevation, wave heights and lengths etc.)
to the ones of real ocean waves. Pressure field formula is derived in
Mathematica language, where resulting formulae are verified by built-in
graphical means.

ARMA model and pressure field formula were incorporated into Large Amplitude
Motion Programme (LAMP) --- an ship motion simulation software programme ---
where they were compared to previously used LH model. Preliminary numerical
experiments showed higher computational efficiency of ARMA model.

* Problem statement
The aim of the study reported here is to investigate possibilities of applying
ARMA process mathematical apparatus to ocean wave modelling and to derive formula
for pressure field under generated wavy surface without assumptions of linear
wave theory.
- In case of small-amplitude waves resulting formula must correspond to the
  one from linear wave theory; in all other cases the formula must not diverge.
- Integral characteristics of generated wavy surface must match the ones of real
  ocean waves.
- Software implementation of ARMA model and pressure field formula must work on
  shared memory (SMP) and distributed memory (MPP) systems.

**** Pressure field formula.
The problem of finding pressure field under wavy sea surface represents inverse
problem of hydrodynamics for incompressible inviscid fluid. System of equations
for it in general case is written as cite:kochin1966theoretical
\begin{align}
    & \nabla^2\phi = 0,\nonumber\\
    & \phi_t+\frac{1}{2} |\vec{\upsilon}|^2 + g\zeta=-\frac{p}{\rho}, & \text{на }z=\zeta(x,y,t),\label{eq:problem}\\
    & D\zeta = \nabla \phi \cdot \vec{n}, & \text{на }z=\zeta(x,y,t),\nonumber
\end{align}
where $\phi$ --- velocity potential, $\zeta$ --- elevation ($z$ coordinate) of
wavy surface, $p$ --- wave pressure, $\rho$ --- fluid density, $\vec{\upsilon} =
(\phi_x, \phi_y, \phi_z)$ --- velocity vector, $g$ --- acceleration of gravity,
and $D$ --- substantial (Lagrange) derivative. The first equation is called
continuity (Laplace) equation, the second one is the conservation of momentum
law (the so called dynamic boundary condition); the third one is
kinematic boundary condition for free wavy surface, which states that rate of
change of wavy surface elevation ($D\zeta$) equals to the change of velocity
potential derivative along the wavy surface normal ($\nabla \phi \cdot
\vec{n}$).

Inverse problem of hydrodynamics consists in solving this system of equations
for $\phi$. In this formulation dynamic boundary condition becomes explicit
formula to determine pressure field using velocity potential derivatives
obtained from the remaining equations. So, from mathematical point of view
inverse problem of hydrodynamics reduces to Laplace equation with mixed boundary
condition --- Robin problem.

* Related work
** Ocean wave models analysis
Pressure computation is only possible when the shape of wavy surface is known.
It is defined either at discrete grid points, or continuously via some analytic
formula. As will be shown in section [[#linearisation]], such formula may simplify
pressure computation by effectively reducing the task to pressure field
generation, instead of wavy surface generation.

*** Longuet---Higgins model
The simplest model, formula of which is derived in the framework of linear wave
theory, is Longuet---Higgins (LH) model cite:longuet1957statistical. In-depth
comparative analysis of this model and ARMA model is done in
cite:degtyarev2011modelling,boukhanovsky1997thesis.

LH model represents ocean wavy surface as a superposition of
sine waves with random amplitudes $c_n$ and phases $\epsilon_n$, continuously
distributed on interval $[0,2\pi]$. Wavy surface elevation ($z$ coordinate) is
defined by
#+name: eq:longuet-higgins
\begin{equation}
    \zeta(x,y,t) = \sum\limits_n c_n \cos(u_n x + v_n y - \omega_n t + \epsilon_n).
\end{equation}
Here wave numbers $(u_n,v_n)$ are continuously distributed on plane $(u,v)$,
i.e. area $du \times dv$ contains infinite quantity of wave numbers. Frequency
is related to wave numbers via dispersion relation $\omega_n=\omega(u_n,v_n)$.
Function $\zeta(x,y,t)$ is a three-dimensional ergodic stationary homogeneous
Gaussian process defined by
\begin{equation*}
    2E_\zeta(u,v)\, du\,  dv = \sum\limits_n c_n^2,
\end{equation*}
where $E_\zeta(u,v)$ --- two-dimensional wave energy spectral density.
Coefficients $c_n$ are derived from wave energy spectrum $S(\omega)$ via
\begin{equation*}
    c_n = \sqrt{ \textstyle\int\limits_{\omega_n}^{\omega_{n+1}} S(\omega) d\omega}.
\end{equation*}

*** Disadvantages of Longuet-Higgins model
Although LH model is simple and easy to understand, there are shortcomings that
appear in practice.

1. The model simulates only stationary Gaussian process. This is consequence of
   central limit theorem (CLT): sum of large number of sines with random
   amplitudes and phases has normal distribution, no matter what spectrum is
   used as the model input. Using lower number of coefficients may solve the
   problem, but also make realisation period smaller. So, using LH model to
   simulate waves with non-Gaussian distribution of elevation --- a distribution
   which real ocean waves have cite:huang1980experimental,рожков1996теория ---
   is impractical.
2. From computational point of view, the deficiency of the model is non-linear
   increase of wavy surface generation time with the increase of realisation
   size. The larger the size of the realisation, the higher number of
   coefficients (discrete points of frequency-directional spectrum) is needed to
   eliminate periodicity. This makes LH model inefficient for long-time
   simulations.
3. Finally, there are peculiarities which make LH model unsuitable base for
   building more advanced simulation models.
   - In software implementation convergence rate of ([[eq:longuet-higgins]]) may be
     low due to randomness of phases $\epsilon_n$.
   - It is difficult to generalise LH model for non-Gaussian processes as it
     involves incorporating non-linear terms in ([[eq:longuet-higgins]]) for which
     there is no known formula to determine coefficients
     cite:рожков1990вероятностные.

To summarise, LH model is linear, computationally inefficient for long-time
simulations, and difficult to use as a base for more advanced models.

*** ARMA model
In cite:spanos1982arma ARMA model is used to generate time series spectrum of
which is compatible with Pierson---Moskowitz (PM) approximation of ocean wave
spectrum. The authors carry out experiments for one-dimensional AR, MA and ARMA
models. They mention excellent agreement between target and initial spectra and
higher performance of ARMA model compared to models based on summing large
number of harmonic components with random phases. The also mention that in order
to reach agreement between target and initial spectrum MA model require lesser
number of coefficients than AR model. In cite:spanos1996efficient the authors
generalise ARMA model coefficients determination formulae for multi-variate
(vector) case.

One thing that distinguishes present work with respect to afore-mentioned ones
is the study of three-dimensional (2D in space and 1D in time) ARMA model, which
is mostly a different problem.
1. Yule---Walker system of equations, which are used to determine AR
   coefficients, has complex block-block structure.
2. Optimal model order (in a sense that target spectrum agrees with initial) is
   determined manually.
3. Instead of PM spectrum, analytic formulae for standing and propagating
   waves ACF are used as the model input.
4. Three-dimensional wavy surface should be compatible with real ocean surface
   not only in terms of spectral characteristics, but also in the shape of wave
   profiles. So, model verification includes distributions of various parameters
   of generated waves (lengths, heights, periods etc.).
Multi-dimensionality of investigated model not only complexifies the task, but
also allows carrying out visual validation of generated wavy surface. It is the
opportunity to visualise output of the programme that allowed to ensure that
generated surface is compatible with real ocean surface, and is not abstract
multi-dimensional stochastic process that is real only statistically.

** Pressure field determination formulae
*** Small amplitude waves theory
In cite:stab2012,детярев1998моделирование,degtyarev1997analysis the authors
propose a solution for inverse problem of hydrodynamics of potential flow in the
framework of small-amplitude wave theory (under assumption that wave length is
much larger than height: $\lambda \gg h$). In that case inverse problem is
linear and reduces to Laplace equation with mixed boundary conditions, and
equation of motion is solely used to determine pressures for calculated velocity
potential derivatives. The assumption of small amplitudes means the slow decay
of wind wave coherence function, i.e. small change of local wave number in time
and space compared to the wavy surface elevation ($z$ coordinate). This
assumption allows calculating elevation $z$ derivative as $\zeta_z=k\zeta$,
where $k$ is wave number. In two-dimensional case the solution is written
explicitly as
\begin{align}
    \left.\frac{\partial\phi}{\partial x}\right|_{x,t}= &
        -\frac{1}{\sqrt{1+\alpha^{2}}}e^{-I(x)}
            \int\limits_{0}^x\frac{\partial\dot{\zeta}/\partial
                z+\alpha\dot{\alpha}}{\sqrt{1+\alpha^{2}}}e^{I(x)}dx,\label{eq:old-sol-2d}\\
    I(x)= & \int\limits_{0}^x\frac{\partial\alpha/\partial z}{1+\alpha^{2}}dx,\nonumber
\end{align}

where $\alpha$ is wave slope. In three-dimensional case solution is written in
the form of elliptic partial differential equation (PDE):
\begin{align*}
    & \frac{\partial^2 \phi}{\partial x^2} \left( 1 + \alpha_x^2 \right) +
    \frac{\partial^2 \phi}{\partial y^2} \left( 1 + \alpha_y^2 \right) +
    2\alpha_x\alpha_y \frac{\partial^2 \phi}{\partial x \partial y} + \\
    & \left(
        \frac{\partial \alpha_x}{\partial z} +
        \alpha_x \frac{\partial \alpha_x}{\partial x} +
        \alpha_y \frac{\partial \alpha_x}{\partial y}
    \right) \frac{\partial \phi}{\partial x} + \\
    & \left(
        \frac{\partial \alpha_y}{\partial z} +
        \alpha_x \frac{\partial \alpha_y}{\partial x} +
        \alpha_y \frac{\partial \alpha_y}{\partial y}
    \right) \frac{\partial \phi}{\partial y} + \\
    & \frac{\partial \dot{\zeta}}{\partial z} +
    \alpha_x \dot{\alpha_x} + \alpha_y \dot{\alpha_y} = 0.
\end{align*}
The authors suggest transforming this equation to finite differences and solve
it numerically.

As will be shown in [[#sec:compare-formulae]] that eqref:eq:old-sol-2d diverges when
attempted to calculate velocity field for large-amplitude waves, and this is the
reason that it can not be used together with ARMA model, that generates
arbitrary-amplitude waves.

*** Linearisation of boundary condition
:PROPERTIES:
:CUSTOM_ID: linearisation
:END:

LH model allows deriving an explicit formula for velocity field by linearising
kinematic boundary condition. Velocity potential formula is written as
\begin{equation*}
\phi(x,y,z,t) = \sum_n \frac{c_n g}{\omega_n}
     e^{\sqrt{u_n^2+v_n^2} z}
     \sin(u_n x + v_n y - \omega_n t + \epsilon_n).
\end{equation*}
This formula is differentiated to obtain velocity potential derivatives, which
are plugged to dynamic boundary condition to obtain pressures.

* ARMA model for ocean wave simulation
** Governing equations for 3-dimensional ARMA process
*** Three possible processes
ARMA ocean simulation model defines ocean wavy surface as three-dimensional (two
dimensions in space and one in time) autoregressive moving average process:
every surface point is represented as a weighted sum of previous in time and
space points plus weighted sum of previous in time and space normally
distributed random impulses. The governing equation for 3-D ARMA process is
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j} \zeta_{\vec i - \vec j}
    +
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j} \epsilon_{\vec i - \vec j}
    ,
    \label{eq:arma-process}
\end{equation}
where $\zeta$ --- wave elevation, $\Phi$ --- AR process coefficients, $\Theta$
--- MA process coefficients, $\epsilon$ --- white noise with Gaussian
distribution, $\vec N$ --- AR process order, $\vec M$ --- MA process order, and
$\Phi_{\vec{0}}\equiv{0}$, $\Theta_{\vec{0}}\equiv{0}$. Here arrows denote
multi-component indices with a component for each dimension. In general, any
scalar quantity can be a component (temperature, salinity, concentration of some
substance in water etc.). Equation parameters are AR and MA process coefficients
and order.

**** Autoregressive (AR) process.
AR process is ARMA process with only one random impulse instead of theirs
weighted sum:
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j} \zeta_{\vec i - \vec j}
    +
    \epsilon_{i,j,k}
    .
    \label{eq:ar-process}
\end{equation}
The coefficients $\Phi$ are calculated from ACF via three-dimensional
Yule---Walker equations, which are obtained after multiplying both parts of the
previous equation by $\zeta_{\vec{i}-\vec{k}}$ and computing the expected value.
Generic form of YW equations is
\begin{equation}
    \label{eq:yule-walker}
    \gamma_{\vec k}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j}
    \text{ }\gamma_{\vec{k}-\vec{j}}
    +
    \Var{\epsilon} \delta_{\vec{k}},
    \qquad
    \delta_{\vec{k}} =
    \begin{cases}
        1, \quad \text{if } \vec{k}=0 \\
        0, \quad \text{if } \vec{k}\neq0,
    \end{cases}
\end{equation}
where $\gamma$ --- ACF of process $\zeta$, $\Var{\epsilon}$ --- white noise
variance. Matrix form of three-dimensional YW equations, which is used in the
present work, is
\begin{equation*}
    \Gamma
    \left[
        \begin{array}{l}
            \Phi_{\vec 0}\\
            \Phi_{0,0,1}\\
            \vdotswithin{\Phi_{\vec 0}}\\
            \Phi_{\vec N}
        \end{array}
    \right]
    =
    \left[
        \begin{array}{l}
            \gamma_{0,0,0}-\Var{\epsilon}\\
            \gamma_{0,0,1}\\
            \vdotswithin{\gamma_{\vec 0}}\\
            \gamma_{\vec N}
        \end{array}
    \right],
    \qquad
    \Gamma=
    \left[
        \begin{array}{llll}
            \Gamma_0 & \Gamma_1 & \cdots & \Gamma_{N_1} \\
            \Gamma_1 & \Gamma_0 & \ddots & \vdotswithin{\Gamma_0} \\
            \vdotswithin{\Gamma_0} & \ddots & \ddots & \Gamma_1 \\
            \Gamma_{N_1} & \cdots & \Gamma_1 & \Gamma_0
        \end{array}
    \right],
\end{equation*}
where $\vec N = \left( p_1, p_2, p_3 \right)$ and
\begin{equation*}
    \Gamma_i =
    \left[
    \begin{array}{llll}
        \Gamma^0_i & \Gamma^1_i & \cdots & \Gamma^{N_2}_i \\
        \Gamma^1_i & \Gamma^0_i & \ddots & \vdotswithin{\Gamma^0_i} \\
        \vdotswithin{\Gamma^0_i} & \ddots & \ddots & \Gamma^1_i \\
        \Gamma^{N_2}_i & \cdots & \Gamma^1_i & \Gamma^0_i
    \end{array}
    \right]
    \qquad
    \Gamma_i^j=
    \left[
    \begin{array}{llll}
        \gamma_{i,j,0} & \gamma_{i,j,1} & \cdots & \gamma_{i,j,N_3} \\
        \gamma_{i,j,1} & \gamma_{i,j,0} & \ddots &x \vdotswithin{\gamma_{i,j,0}} \\
        \vdotswithin{\gamma_{i,j,0}} & \ddots & \ddots & \gamma_{i,j,1} \\
        \gamma_{i,j,N_3} & \cdots & \gamma_{i,j,1} & \gamma_{i,j,0}
    \end{array}
    \right],
\end{equation*}
Since $\Phi_{\vec 0}\equiv0$, the first row and column of $\Gamma$ can be
eliminated. Matrix $\Gamma$ is block-toeplitz, positive definite and symmetric,
hence the system is efficiently solved by Cholesky decomposition, which is
particularly suitable for these types of matrices.

After solving this system of equations white noise variance is estimated from
eqref:eq:yule-walker by plugging $\vec k = \vec 0$:
\begin{equation*}
    \Var{\epsilon} =
    \Var{\zeta}
    -
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j}
    \text{ }\gamma_{\vec{j}}.
\end{equation*}

**** Moving average (MA) process.
MA process is ARMA process with $\Phi\equiv0$:
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j} \epsilon_{\vec i - \vec j}
    .
    \label{eq:ma-process}
\end{equation}
MA coefficients $\Theta$ are defined implicitly via the following non-linear
system of equations:
\begin{equation*}
  \gamma_{\vec i} =
	\left[
		\displaystyle
    \sum\limits_{\vec j = \vec i}^{\vec M}
    \Theta_{\vec j}\Theta_{\vec j - \vec i}
	\right]
  \Var{\epsilon}.
\end{equation*}
The system is solved numerically by fixed-point iteration method via the
following formulae
\begin{equation*}
  \Theta_{\vec i} =
    -\frac{\gamma_{\vec 0}}{\Var{\epsilon}}
		+
    \sum\limits_{\vec j = \vec i}^{\vec M}
    \Theta_{\vec j} \Theta_{\vec j - \vec i}.
\end{equation*}
Here coefficients $\Theta$ are calculated from back to front: from
$\vec{i}=\vec{M}$ to $\vec{i}=\vec{0}$. White noise variance is estimated by
\begin{equation*}
    \Var{\epsilon} = \frac{\gamma_{\vec 0}}{
		1
		+
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j}^2
    }.
\end{equation*}
Authors of cite:box1976time suggest using Newton---Raphson method to solve this
equation with higher precision, however, this method does not work in three
dimensions. Using slower method does not have dramatic effect on the overall
programme performance, because the number of coefficients is small and most of
the time is spent generating wavy surface.

**** TODO Stationarity and invertibility of AR and MA processes
**** Mixed autoregressive moving average (ARMA) process.
:PROPERTIES:
:CUSTOM_ID: sec:how-to-mix-ARMA
:END:
Generally speaking, ARMA process is obtained by plugging MA generated wavy
surface as random impulse to AR process, however, in order to get the process
with desired ACF one should re-compute AR coefficients before plugging. There
are several approaches to "mix" AR and MA processes.
- The approach proposed in cite:box1976time which involves dividing ACF into MA
  and AR part along each dimension is not applicable here, because in three
  dimensions such division is not possible: there always be parts of the ACF
  that are not taken into account by AR and MA process.
- The alternative approach is to use the same (undivided) ACF for both AR and MA
  processes but use different process order, however, then realisation
  characteristics (mean, variance etc.) become skewed: these are characteristics
  of the two overlapped processes.
For the first approach there is a formula to re-compute ACF for AR process, but
there is no such formula for the second approach. So, the best solution for now
is to simply use AR and MA process exclusively.

*** Process selection criteria for different wave profiles
One problem of ARMA model application to ocean wave generation is that for
different types of wave profiles different processes /must/ be used: standing
waves are modelled by AR process, and propagating waves by MA process. This
statement comes from practice: if one tries to use the processes the other way
round, the resulting realisation either diverges or does not correspond to real
ocean waves. (The latter happens for non-invertible MA process, as it is always
stationary.) So, the best way to apply ARMA model to ocean wave generation is to
use AR process for standing waves and MA process for progressive waves.

The other problem is inability to automatically determine optimal number of
coefficients for three-dimensional AR and MA processes. For one-dimensional
processes this can be achieved via iterative methods cite:box1976time, but they
diverge in three-dimensional case.

The final problem, which is discussed in [[#sec:how-to-mix-ARMA]], is inability to
"mix" AR and MA process in three dimensions.

In practice some statements made for AR and MA processes in cite:box1976time
should be flipped for three-dimensional case. For example, the authors say that
ACF of MA process cuts at $q$ and ACF of AR process decays to nought infinitely,
but in practice making ACF of 3-dimensional MA process not decay results in it
being non-invertible and producing realisation that does not look like real
ocean waves, whereas doing the same for ACF of AR process results in stationary
process and adequate realisation. Also, the authors say that one
should allocate the first $q$ points of ACF to MA process (as it often needed to
describe the peaks in ACF) and leave the rest points to AR process, but in
practice in case of ACF of a propagating wave AR process is stationary only for
the first time slice of the ACF, and the rest is left to MA process.

To summarise, the only established scenario of applying ARMA model to ocean wave
generation is to use AR process for standing waves and MA process for
propagating waves. With new formulae for 3 dimensions a single mixed ARMA
process might increase model precision, which is one of the objectives of the
future research.

** Modelling non-linearity of ocean waves
ARMA model allows modelling asymmetry of wave elevation distribution, i.e.
generate ocean waves, distribution of z-coordinate of which has non-nought
kurtosis and asymmetry. Such distribution is inherent to real ocean waves
cite:longuet1963nonlinear.

Wave asymmetry is modelled by non-linear inertia-less transform (NIT) of
stochastic process, however, transforming resulting wavy surface means
transforming initial ACF. In order to alleviate this, ACF must be preliminary
transformed as shown in cite:boukhanovsky1997thesis.

**** Wavy surface transformation.
Explicit formula $z=f(y)$ that transforms wavy surface to desired
one-dimensional distribution $F(z)$ is the solution of non-linear transcendental
equation $F(z)=\Phi(y)$, where $\Phi(y)$ --- one-dimensional Gaussian
distribution. Since distribution of wave elevation is often given by some
approximation based on field data, this equation is solved numerically with
respect to $z_k$ in each grid point $y_k|_{k=0}^N$ of generated wavy surface. In
this case equation is rewritten as
\begin{equation}
    \label{eq:distribution-transformation}
    F(z_k)
    =
    \frac{1}{\sqrt{2\pi}}
    \int\limits_0^{y_k} \exp\left[ -\frac{t^2}{2} \right] dt
    .
\end{equation}
Since, distribution functions are monotonic, the simplest interval halving
(bisection) numerical method is used to solve this equation.

**** Preliminary ACF transformation.
In order to transform ACF $\gamma_z$ of the process, it should be expanded in
series of Hermite polynomials (Gram---Charlier series)
\begin{equation*}
    \gamma_z \left( \vec u \right)
    =
    \sum\limits_{m=0}^{\infty}
    C_m^2 \frac{\gamma_y^m \left( \vec u \right)}{m!},
\end{equation*}
where
\begin{equation*}
    C_m = \frac{1}{\sqrt{2\pi}}
  \int\limits_{0}^\infty
    f(y) H_m(y) \exp\left[ -\frac{y^2}{2} \right],
\end{equation*}
$H_m$ --- Hermite polynomial, and $f(y)$ --- solution to equation
eqref:eq:distribution-transformation. Plugging polynomial approximation
$f(y)\approx\sum\limits_{i}d_{i}y^i$ and analytic formulae for Hermite
polynomial yields
\begin{equation*}
    \frac{1}{\sqrt{2\pi}}
    \int\limits_\infty^\infty
    y^k \exp\left[ -\frac{y^2}{2} \right]
    =
    \begin{cases}
        (k-1)!! & \text{if }k\text{ is even},\\
        0       & \text{if }k\text{ is odd},
    \end{cases}
\end{equation*}
which simplifies the former equation. Optimal number of coefficients $C_m$ is
determined by computing them sequentially and stopping when variances of both
fields become equal with desired accuracy $\epsilon$:
\begin{equation*}
    \left| \Var{z} - \sum\limits_{k=0}^m
    \frac{C_k^2}{k!} \right| \leq \epsilon.
\end{equation*}

In cite:boukhanovsky1997thesis the author suggests using polynomial
approximation $f(y)$ also for wavy surface transformation, however, in practice
ocean surface realisation often contains points, where z-coordinate is beyond
the limits of the approximation, which makes solution wrong. In these points it
is more efficient to solve equation eqref:eq:distribution-transformation by
bisection method. Using the same approximation in Gram---Charlier series does
not lead to such errors.

** Determining wave pressures for discretely given wavy surface
Analytic solutions to boundary problems in classical equations are often used to
study different properties of the solution, and for that purpose general
solution formula is too difficult to study, as it contains integrals of unknown
functions. Fourier method is one of the methods to find analytic solutions to
PDE. It is based on application of Fourier transform to each part of PDE, which
reduces the equation to algebraic, and the solution is written as inverse
Fourier transform of some function (which may contain Fourier transforms of
other functions). Since, it is not possible to write analytic forms of these
Fourier transforms in all cases, unique solutions are found and their behaviour
is studied in different domains instead. At the same time, computing discrete
Fourier transforms on the computer is possible for any discretely defined
function and efficient when using FFT algorithms. These algorithms use symmetry
of complex exponentials to decrease asymptotic complexity from
$\mathcal{O}(n^2)$ to $\mathcal{O}(n\log_{2}n)$. So, even if general solution
contains Fourier transforms of unknown functions, they still can be computed
numerically, and FFT family of algorithms makes this approach efficient.

Alternative approach to solve PDE is to reduce it to difference equations, which
are solved by constructing various numerical schemes. This approach leads to
approximate solution, and asymptotic complexity of corresponding algorithms is
comparable to that of FFT. For example, stationary elliptic PDE transforms to
implicit numerical scheme which is solved by iterative method on each step of
which a tridiagonal of five-diagonal system of algebraic equations is solved by
Thomas algorithm. Asymptotic complexity of this approach is
$\mathcal{O}({n}{m})$, where $n$ --- number of wavy surface grid points, $m$ ---
number of iterations. Despite their wide spread, iterative algorithms are
inefficient on parallel computer architectures; in particular, their mapping to
co-processors may involve copying data in and out of the co-processor in each
iteration, which negatively affects their performance. At the same time, high
number of Fourier transforms in the solution is an advantage, rather than a
disadvantage. First, solutions obtained by Fourier method are explicit, hence
their implementations scales with the large number of parallel computer cores.
Second, there are implementations of FFT optimised for different processor
architectures as well as co-processors (GPU, MIC) which makes it easy to get
high performance on any computing platform. These advantages substantiate the
choice of Fourier method to obtain explicit analytic solution to the problem of
determining pressures under wavy ocean surface.

*** Two-dimensional velocity field
:PROPERTIES:
:CUSTOM_ID: sec:pressure-2d
:END:
**** Formula for infinite depth fluid.
Two-dimensional Laplace equation with Robin boundary condition is written as
\begin{align}
    \label{eq:problem-2d}
    & \phi_{xx}+\phi_{zz}=0,\\
    & \zeta_t + \zeta_x\phi_x = \frac{\zeta_x}{\sqrt{1 + \zeta_x^2}} \phi_x - \phi_z, & \text{на }z=\zeta(x,t).\nonumber
\end{align}
Use Fourier method to solve this problem. Applying Fourier transform to both
sides of the equation yields
\begin{equation*}
    -4 \pi^2 \left( u^2 + v^2 \right)
    \FourierY{\phi(x,z)}{u,v} = 0,
\end{equation*}
hence $v = \pm i u$. Hereinafter we use the following symmetric form of Fourier
transform:
\begin{equation*}
    \FourierY{f(x,y)}{u,v} =
    \iint\limits_{-\infty}^{\phantom{--}\infty}
    f(x,y)
    e^{-2\pi i (x u + y v)}
    dx dy.
\end{equation*}
We seek solution in the form of inverse Fourier transform
$\phi(x,z)=\InverseFourierY{E(u,v)}{x,z}$. Plugging[fn::$v={-i}{u}$ is not
applicable because velocity potential must go to nought when depth goes to
infinity.] $v={i}{u}$ into the formula yields
\begin{equation}
    \label{eq:guessed-sol-2d}
    \phi(x,z) = \InverseFourierY{e^{2\pi u z}E(u)}{x}.
\end{equation}
In order to make substitution $z=\zeta(x,t)$ not interfere with Fourier
transforms, we rewrite eqref:eq:guessed-sol-2d as a convolution:
\begin{equation*}
    \phi(x,z)
    =
    \Fun{z}
    \ast
    \InverseFourierY{E(u)}{x},
\end{equation*}
where $\Fun{z}$ --- a function, form of which is defined in section
[[#sec:compute-delta]] and which satisfies equation
$\FourierY{\Fun{z}}{u}=e^{2\pi{u}{z}}$. Plugging formula $\phi$ into the boundary
condition yields
\begin{equation*}
    \zeta_t
    =
    \left( i f(x) - 1 \right)
    \left[
        \Fun{z}
        \ast
        \InverseFourierY{2\pi u E(u)}{x}
    \right],
\end{equation*}
where $f(x)={\zeta_x}/{\sqrt{1+\zeta_x^2}}-\zeta_x$. Applying Fourier transform
to both sides of this equation yields formula for coefficients $E$:
\begin{equation*}
    E(u) =
    \frac{1}{2\pi u}
    \frac{
    \FourierY{\zeta_t / \left(i f(x) - 1\right)}{u}
    }{
    \FourierY{\Fun{z}}{u}
    }
\end{equation*}
Finally, substituting $z$ for $\zeta(x,t)$ and plugging resulting equation into
eqref:eq:guessed-sol-2d yields formula for $\phi(x,z)$:
\begin{equation}
    \label{eq:solution-2d}
    \boxed{
        \phi(x,z)
        =
        \InverseFourierY{
            \frac{e^{2\pi u z}}{2\pi u}
            \frac{
            \FourierY{ \zeta_t / \left(i f(x) - 1\right) }{u}
            }{
            \FourierY{ \Fun{\zeta(x,t)} }{u}
            }
        }{x}.
    }
\end{equation}

Multiplier $e^{2\pi{u}{z}}/(2\pi{u})$ makes graph of a function to which Fourier
transform of which is applied asymmetric with respect to $OY$ axis. This makes
it difficult to apply FFT which expects periodic function with nought on both
ends of the interval. Using numerical integration instead of FFT is not faster
than solving the initial system of equations with numerical schemes. This
problem is alleviated by using formula eqref:eq:solution-2d-full for finite
depth fluid with wittingly large depth $h$. This formula is derived in the
following section.

**** Formula for finite depth fluid.
On the sea bottom vertical fluid velocity component equals nought: $\phi_z=0$ on
$z=-h$, where $h$ --- water depth. In this case equation $v=-{i}{u}$, which came
from Laplace equation, can not be neglected, hence the solution is sought in the
following form:
\begin{equation}
    \phi(x,z)
    =
    \InverseFourierY{
        \left( C_1 e^{2\pi u z} + C_2 e^{-2\pi u z} \right)
        E(u)
    }{x}.
    \label{eq:guessed-sol-2d-full}
\end{equation}
Plugging $\phi$ into the boundary condition on the sea bottom yields
\begin{equation*}
    C_1 e^{-2\pi u h} - C_2 e^{2\pi u h} = 0,
\end{equation*}
hence $C_1=\frac{1}{2}C{e}^{2\pi{u}{h}}$ and
$C_2=-\frac{1}{2}C{e}^{-2\pi{u}{h}}$. Constant $C$ may take arbitrary value
here, because after plugging it becomes part of unknown coefficients $E(u)$.
Plugging formulae for $C_1$ and $C_2$ into eqref:eq:guessed-sol-2d-full yields
\begin{equation*}
    \phi(x,z) = \InverseFourierY{ \Sinh{2\pi u (z+h)} E(u) }{x}.
\end{equation*}
Plugging $\phi$ into the boundary condition on the free surface yields
\begin{equation*}
    \zeta_t = f(x) \InverseFourierY{ 2\pi i u \Sinh{2\pi u (z+h)} E(u) }{x}
            - \InverseFourierY{ 2\pi u \SinhX{2\pi u (z+h)} E(u) }{x}.
\end{equation*}
Here $\sinh$ and $\cosh$ give similar results near free surface, and since this
is the main area of interest in practical applications, we assume that
$\Sinh{2\pi{u}(z+h)}\approx\SinhX{2\pi{u}(z+h)}$. Performing analogous to the
previous section transformations yields final formula for $\phi(x,z)$:
\begin{equation}
\boxed{
    \phi(x,z,t)
    =
  \InverseFourierY{
        \frac{\Sinh{2\pi u (z+h)}}{2\pi u}
        \frac{
            \FourierY{ \zeta_t / \left(i f(x) - 1\right) }{u}
        }{
            \FourierY{ \FunSecond{\zeta(x,t)} }{u}
        }
    }{x},
}
    \label{eq:solution-2d-full}
\end{equation}
where $\FunSecond{z}$ --- a function, form of which is defined in section
[[#sec:compute-delta]] and which satisfies equation
$\FourierY{\FunSecond{z}}{u}=\Sinh{2\pi{u}{z}}$.

**** Reducing to the formulae from linear wave theory.
Check the validity of derived formulae by substituting $\zeta(x,t)$ with known
analytic formula for plain waves. Symbolic computation of Fourier transforms in
this section were performed in Mathematica cite:mathematica10. In the framework
of linear wave theory assume that waves have small amplitude compared to their
lengths, which allows us simplifying initial system of equations
eqref:eq:problem-2d to
\begin{align*}
    & \phi_{xx}+\phi_{zz}=0,\\
    & \zeta_t = -\phi_z & \text{на }z=\zeta(x,t),
\end{align*}
solution to which is written as
\begin{equation*}
    \phi(x,z,t)
    =
    -\InverseFourierY{
        \frac{e^{2\pi u z}}{2\pi u}
        \FourierY{\zeta_t}{u}
    }{x}
    .
\end{equation*}
Propagating wave profile is defined as $\zeta(x,t)=A\cos(2\pi(kx-t))$. Plugging
this formula into eqref:eq:solution-2d yields
$\phi(x,z,t)=-\frac{A}{k}\sin(2\pi(kx-t))\Sinh{2\pi{k}{z}}$. In order to reduce
it to the formula from linear wave theory, rewrite hyperbolic sine in
exponential form, discard the term containing $e^{-2\pi{k}{z}}$ as contradicting
condition $\phi\underset{z\rightarrow-\infty}{\longrightarrow}0$. Taking real
part of the resulting formula yields
$\phi(x,z,t)=\frac{A}{k}e^{2\pi{k}{z}}\sin(2\pi(kx-t))$, which corresponds to
the known formula from linear wave theory. Similarly, under small-amplitude
waves assumption the formula for finite depth fluid eqref:eq:solution-2d-full is
reduced to
\begin{equation*}
    \phi(x,z,t)
    =
    -\InverseFourierY{
        \frac{\Sinh{2\pi u (z+h)}}{2\pi u \Sinh{2\pi u h}}
        \FourierY{\zeta_t}{u}
    }{x}.
\end{equation*}
Substituting $\zeta(x,t)$ with propagating plain wave profile formula yields
\begin{equation}
    \label{eq:solution-2d-linear}
    \phi(x,z,t)=\frac{A}{k}
    \frac{\Sinh{2 \pi k (z+h)}}{ \Sinh{2 \pi k h} }
    \sin(2 \pi (k x-t)),
\end{equation}
which corresponds to the formula from linear wave theory for finite depth fluid.

Different forms of Laplace equation solutions, in which decaying exponent is
written with either "+" or "-" signs, may cause incompatibilities between
formulae from linear wave theory and formulae derived in this work, where
$\sinh$ is used instead of $\cosh$. Equality
$\frac{\Sinh{2\pi{k}(z+h)}}{\Sinh{2\pi{k}{h}}}\approx\frac{\sinh(2\pi{k}(z+h))}{\sinh(2\pi{k}{h})}$
becomes strict on the free surface, and difference between left-hand and
right-hand sides increases when approaching sea bottom (for sufficiently large
depth difference near free surface is negligible). So, for sufficiently large
depth any function ($\cosh$ or $\sinh$) may be used for velocity potential
computation near free surface.

Reducing eqref:eq:solution-2d и eqref:eq:solution-2d-full to the known formulae
from linear wave theory shows, that formula for infinite depth
eqref:eq:solution-2d is not suitable to compute velocity potentials with Fourier
method, because it does not have symmetry, which is required for Fourier
transform. However, formula for finite depth can be used instead by setting $h$
to some characteristic water depth. For standing wave reducing to linear wave
theory formulae is made under the same assumptions.

*** Three-dimensional velocity field
Three-dimensional version of eqref:eq:problem is written as
\begin{align}
    \label{eq:problem-3d}
    & \phi_xx + \phi_yy + \phi_zz = 0,\\
    & \zeta_t + \zeta_x\phi_x + \zeta_y\phi_y
    =
    \frac{\zeta_x}{\sqrt{1 + \zeta_x^2}} \phi_x
    +\frac{\zeta_y}{\sqrt{\vphantom{\zeta_x^2}\smash[b]{1 + \zeta_y^2}}} \phi_y
    - \phi_z, & \text{на }z=\zeta(x,y,t).\nonumber
\end{align}
Again, use Fourier method to solve it. Applying Fourier transform to both sides
of Laplace equation yields
\begin{equation*}
    -4 \pi^2 \left( u^2 + v^2 + w^2 \right)
    \FourierY{\phi(x,y,z)}{u,v,w} = 0,
\end{equation*}
hence $w=\pm{i}\sqrt{u^2+v^2}$. We seek solution in the form of inverse Fourier
transform $\phi(x,y,z)=\InverseFourierY{E(u,v,w)}{x,y,z}$. Plugging
$w=i\sqrt{u^2+v^2}$ into the formula yields
\begin{equation*}
    \phi(x,y,z) = \InverseFourierY{
        \left(
            C_1 e^{2\pi \sqrt{u^2+v^2} z}
            -C_2 e^{-2\pi \sqrt{u^2+v^2} z}
        \right)
        E(u,v)
    }{x,y}.
\end{equation*}
Plugging $\phi$ into the boundary condition on the sea bottom (analogous to
two-dimensional case) yields
\begin{equation}
    \label{eq:guessed-sol-3d}
    \phi(x,y,z) = \InverseFourierY{
        \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)
    }{x,y}.
\end{equation}
Plugging $\phi$ into the boundary condition on the free surface yields
\begin{equation*}
    \arraycolsep=1.4pt
    \begin{array}{rl}
        \zeta_t = & i f_1(x,y) \InverseFourierY{2 \pi u \Sinh{2\pi \sqrt{u^2+v^2} (z+h)}E(u,v)}{x,y} \\
        + & i f_2(x,y) \InverseFourierY{2 \pi v \Sinh{2\pi \sqrt{u^2+v^2} (z+h)}E(u,v)}{x,y} \\
        - & \InverseFourierY{2 \pi \sqrt{u^2+v^2} \SinhX{2\pi \sqrt{u^2+v^2} (z+h)}E(u,v)}{x,y}
    \end{array}
\end{equation*}
where $f_1(x,y)={\zeta_x}/{\sqrt{1+\zeta_x^2}}-\zeta_x$ and
$f_2(x,y)={\zeta_y}/{\sqrt{\vphantom{\zeta_x^2}\smash[b]{1+\zeta_y^2}}}-\zeta_y$.
Applying Fourier transform to both sides of the equation yields formula for
coefficients $E$:
\begin{equation*}
    \arraycolsep=1.4pt
    \begin{array}{rl}
        \FourierY{\zeta_t}{u,v} = &
        \FourierY{i f_1(x,y) \InverseFourierY{2 \pi u \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)}{x,y}}{u,v}  \\
        + & \FourierY{i f_2(x,y) \InverseFourierY{2 \pi v \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)}{x,y}}{u,v}  \\
        - & 2 \pi \sqrt{u^2+v^2} \SinhX{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)
    \end{array}
\end{equation*}
Final solution is obtained after plugging $E(u,v)$ into eqref:eq:guessed-sol-3d.

* Numerical methods and experimental results
** The shape of ACF for different types of waves
*** Two methods to find ocean waves ACF
**** Analytic method of finding the ACF.
The straightforward way to find ACF for a given ocean wave profile is to apply
Wiener---Khinchin theorem. According to this theorem the autocorrelation $K$ of
a function $\zeta$ is given by the Fourier transform of the absolute square of
the function:
\begin{equation}
  K(t) = \Fourier{\left| \zeta(t) \right|^2}.
  \label{eq:wiener-khinchin}
\end{equation}
When $\zeta$ is replaced with actual wave profile, this formula gives you
analytic formula for the corresponding ACF.

For three-dimensional wave profile (2D in space and 1D in time) analytic formula
is a polynomial of high order and is best obtained via symbolic computation
programme. Then for practical usage it can be approximated by superposition of
exponentially decaying cosines (which is how ACF of a stationary ARMA process
looks like cite:box1976time).

**** Empirical method of finding the ACF.
However, for three-dimensional case there exists simpler empirical method which
does not require sophisticated software to determine shape of the ACF. It is
known that ACF represented by exponentially decaying cosines satisfies first
order Stokes' equations for gravity waves cite:boccotti1983wind. So, if the
shape of the wave profile is the only concern in the simulation, then one can
simply multiply it by a decaying exponent to get appropriate ACF. This ACF does
not reflect other wave profile parameters, such as wave height and period, but
opens possibility to simulate waves of a particular non-analytic shape by
"drawing" their profile, then multiplying it by an exponent and using the
resulting function as ACF. So, this empirical method is imprecise but offers
simpler alternative to Wiener---Khinchin theorem approach; it is mainly useful
to test ARMA model.

*** Examples of ACFs for various types of wave profiles
**** Standing wave.
For three-dimensional plain standing wave the profile is given by
\begin{equation}
  \zeta(t, x, y) = A \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq:standing-wave}
\end{equation}
Find ACF via analytic method. Multiplying the formula by a decaying exponent
(because Fourier transform is defined for a function $f$ that
$f\underset{x\rightarrow\pm\infty}{\longrightarrow}0$) yields
\begin{equation}
  \zeta(t, x, y) =
  A
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq:decaying-standing-wave}
\end{equation}
Then, apply 3D Fourier transform to both sides of the equation via symbolic
computation programme, fit the resulting polynomial to the following
approximation:
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos \beta t
  \cos \left[ \beta x + \beta y \right].
  \label{eq:standing-wave-acf}
\end{equation}
So, after applying Wiener---Khinchin theorem we get initial formula but with
cosines instead of sines. This difference is important because the value of ACF
at $(0,0,0)$ equals to the ARMA process variance, and if one used sines the
value would be wrong.

If one tries to replicate the same formula via empirical method, the usual way
is to adapt eqref:eq:decaying-standing-wave to match eqref:eq:standing-wave-acf.
This can be done either by changing the phase of the sine, or by substituting
sine with cosine to move the maximum of the function to the origin of
coordinates.

**** Propagating wave.
Three-dimensional profile of plain propagating wave is given by
\begin{equation}
  \zeta(t, x, y) = A \cos (\sigma t + k_x x + k_y y).
  \label{eq:propagating-wave}
\end{equation}
For the analytic method repeating steps from the previous two paragraphs yields
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos\left[\beta (t+x+y) \right].
  \label{eq:propagating-wave-acf}
\end{equation}
For the empirical method the wave profile is simply multiplied by a decaying
exponent without need to adapt the maximum value of ACF (as it is required for
standing wave).

*** Comparison of studied methods
To summarise, the analytic method of finding ocean wave's ACF reduces to the
following steps.
- Make wave profile decay when approaching $\pm\infty$ by multiplying it by
  a decaying exponent.
- Apply Fourier transform to the absolute square of the resulting equation using
  symbolic computation programme.
- Fit the resulting polynomial to the appropriate ACF approximation.

Two examples in this section showed that in case of standing and propagating
waves their decaying profiles resemble the corresponding ACFs with the exception
that the ACF's maximum should be moved to the origin to preserve simulated
process variance. Empirical method of finding ACF reduces to the following
steps.
- Make wave profile decay when approaching $\pm\infty$ by multiplying it by
  a decaying exponent.
- Move maximum value of the resulting function to the origin by using
  trigonometric identities to shift the phase.

** Additional formulae, methods and algorithms for ARMA model
*** Wave elevation distribution approximation
One of the parameters of ocean wavy surface generator is probability density
function (PDF) of the surface elevation. This distribution is given by either
polynomial approximation of /in situ/ data or analytic formula.

**** Gram---Charlier series expansion.
In cite:huang1980experimental the authors experimentally show, that PDF of sea
surface elevation is distinguished from normal distribution by non-nought
kurtosis and skewness. In cite:рожков1996теория the authors show, that this type
of PDF expands in Gram---Charlier series:
\begin{align}
    \label{eq:skew-normal-1}
    F(z; \gamma_1, \gamma_2) & = \phi(z)
        - \gamma_1 \frac{\phi'''(z)}{3!}
        + \gamma_2 \frac{\phi''''(z)}{4!} \nonumber \\
    & =
    \frac{1}{2} \text{erf}\left[\frac{z}{\sqrt{2}}\right]
    -
    \frac{e^{-\frac{z^2}{2}}}{\sqrt{2\pi}}
    \left[
        \frac{1}{6} \gamma_1 \left(z^2-1\right)
        + \frac{1}{24} \gamma_2 z \left(z^2-3\right)
    \right]
    ,\nonumber \\
    f(z; \gamma_1, \gamma_2) & =
    \frac{e^{-\frac{z^2}{2}}}{\sqrt{2 \pi }}
    \left[
        \frac{1}{6} \gamma_1 z \left(z^2-3\right)
        + \frac{1}{24} \gamma_2 \left(z^4-6z^2+3\right)
        +1
    \right],
\end{align}
where $\phi(z)=\frac{1}{2}\mathrm{erf}(z/\sqrt{2})$, $\gamma_1$ --- skewness,
$\gamma_2$ --- kurtosis, $f$ --- PDF, $F$ --- cumulative distribution function
(CDF). According to cite:рожков1990вероятностные for ocean waves skewness is
selected from interval $0.1\leq\gamma_1\leq{0.52}]$ and kurtosis from interval
$0.1\leq\gamma_2\leq{0.7}$. Family of probability density functions for
different parameters is shown in [[fig:skew-normal-1]].

#+name: fig:skew-normal-1
#+begin_src R :results output graphics :exports results :file build/skew-normal-1.pdf
source(file.path("R", "common.R"))
x <- seq(-3, 3, length.out=100)
params <- data.frame(
  skewness = c(0.00, 0.52, 0.00, 0.52),
  kurtosis = c(0.00, 0.00, 0.70, 0.70),
  linetypes = c("solid", "dashed", "dotdash", "dotted")
)
arma.skew_normal_1_plot(x, params)
legend(
  "topleft",
  mapply(
    function (s, k) {
      as.expression(bquote(list(
        gamma[1] == .(arma.fmt(s, 2)),
        gamma[2] == .(arma.fmt(k, 2))
      )))
    },
    params$skewness,
    params$kurtosis
  ),
  lty = paste(params$linetypes)
)
#+end_src

#+caption: Probability density function eqref:eq:skew-normal-1 of ocean wavy surface elevation for different values of skewness $\gamma_1$ and kurtosis $\gamma_2$.
#+RESULTS: fig:skew-normal-1
[[file:build/skew-normal-1.pdf]]

**** Skew-normal distribution.
Alternative approach is to approximate distribution of ocean wavy surface
elevation by skew-normal distribution:
\begin{align}
    \label{eq:skew-normal-2}
    F(z; \alpha) & = \frac{1}{2}
   \mathrm{erfc}\left[-\frac{z}{\sqrt{2}}\right]-2 T(z,\alpha ), \nonumber \\
    f(z; \alpha) & = \frac{e^{-\frac{z^2}{2}}}{\sqrt{2 \pi }}
   \mathrm{erfc}\left[-\frac{\alpha z}{\sqrt{2}}\right],
\end{align}
where $T$ --- Owen $T$-function cite:owen1956tables. Using this formula it is
impossible to specify skewness and kurtosis separately --- both values are
adjusted via $\alpha$ parameter. The only advantage of the formula is its
relative computational simplicity: this function is available in some programmes
and mathematical libraries. Its graph for different values of $\alpha$ is shown
in [[fig:skew-normal-2]].

#+name: fig:skew-normal-2
#+begin_src R :results output graphics :exports results :file build/skew-normal-2.pdf
source(file.path("R", "common.R"))
x <- seq(-3, 3, length.out=100)
alpha <- c(0.00, 0.87, 2.25, 4.90)
params <- data.frame(
  alpha = alpha,
  skewness = arma.bits.skewness_2(alpha),
  kurtosis = arma.bits.kurtosis_2(alpha),
  linetypes = c("solid", "dashed", "dotdash", "dotted")
)
arma.skew_normal_2_plot(x, params)
legend(
  "topleft",
  mapply(
    function (a, s, k) {
      as.expression(bquote(list(
        alpha == .(arma.fmt(a, 2)),
        gamma[1] == .(arma.fmt(s, 2)),
        gamma[2] == .(arma.fmt(k, 2))
      )))
    },
    params$alpha,
    params$skewness,
    params$kurtosis
  ),
  lty = paste(params$linetypes)
)
#+end_src

#+caption: Probability density function eqref:eq:skew-normal-2 of ocean wavy surface for different values of skewness coefficient $\alpha$.
#+RESULTS: fig:skew-normal-2
[[file:build/skew-normal-2.pdf]]

**** Evaluation.
Equation eqref:eq:distribution-transformation with selected wave elevation
distribution may be solved either in every point of generated wavy surface,
which gives the most accurate results, or in every fixed grid point
interpolating result via least-squares (LS) polynomial. In the second case
precision is lower. For example, interpolating 12^th order polynomial on a fixed
grid of 500 points on interval $-5\sigma_z\leq{z}\leq{5}\sigma_z$ gives error of
$\approx{0.43}\cdot10^{-3}$. Increasing polynomial order leads to either numeric
overflows during LS interpolation, or more coefficient close to nought;
increasing the size of the grid has insignificant effect on the result. In the
majority of cases three Gram---Charlier series coefficients is enough to
transform ACF; relative error without interpolation is $10^{-5}$.

*** White noise generation
In order to eliminate periodicity from generated wavy surface, it is imperative
to use PRNG with sufficiently large period to generate white noise. Parallel
Mersenne Twister cite:matsumoto1998mersenne with a period of $2^{19937}-1$ is
used as a generator in this work. It allows producing aperiodic ocean wavy
surface realisations in any practical usage scenarios.

There is no guarantee that multiple Mersenne Twisters executed in parallel
threads with distinct initial states produce uncorrelated pseudo-random number
sequences, however, algorithm of dynamic creation of Mersenne Twisters
cite:matsumoto1998dynamic may be used to provide such guarantee. The essence of
the algorithm is to find matrices of initial generator states, that give
maximally uncorrelated pseudo-random number sequences when Mersenne Twisters are
executed in parallel with these initial states. Since finding such initial
states consumes considerable amount of processor time, vector of initial states
is created preliminary with knowingly larger number of parallel threads and
saved to a file, which is then read before starting white noise generation.

*** Wavy surface generation
In ARMA model value of wavy surface elevation at a particular point depends on
previous in space and time points, as a result the so called /ramp-up interval/
(see fig. [[fig:ramp-up-interval]]), in which realisation does not correspond to
specified ACF, forms in the beginning of the realisation. There are several
solutions to this problem which depend on the simulation context.

If realisation is used in the context of ship stability simulation without
manoeuvring, ramp-up interval will not affect results of the simulation, because
it is located on the border (too far away from the studied marine object). If
ship stability with manoeuvring is studied, then the interval may be simply
discarded from the realisation (the size of the interval approximately equals
the number of AR coefficients in each dimension). However, this may lead to loss
of a very large number of points, because discarding occurs for each dimension.
Alternative approach is to generate ocean wavy surface on ramp-up interval with
LH model and generate the rest of the realisation with ARMA model.

Algorithm of wavy surface generation is data-parallel: realisation is divided
into equal parts each of which is generated independently, however, in the
beginning of each realisation there is ramp-up interval. To eliminate it
/overlap-add/ method
cite:oppenheim1989discrete,svoboda2011efficient,pavel2013algorithms (a popular
method in signal processing) is used. The essence of the method is to add
another interval, size of which is equal to the ramp-up interval size, to the
end of each part. Then wavy surface is generated in each point of each part
(including points from the added interval), the interval at the end of part $N$
is superimposed on the ramp-up interval at the beginning of the part $N+1$, and
values in corresponding points are added.

#+name: fig:ramp-up-interval
#+begin_src R :results output graphics :exports results :file build/ramp-up-interval.pdf
source(file.path("R", "common.R"))
arma.plot_ramp_up_interval()
#+end_src

#+caption: Ramp-up interval at the beginning of the $OX$ axis of the realisation.
#+RESULTS: fig:ramp-up-interval
[[file:build/ramp-up-interval.pdf]]

*** Velocity potential normalisation formulae
:PROPERTIES:
:CUSTOM_ID: sec:compute-delta
:END:

In solutions eqref:eq:solution-2d and eqref:eq:solution-2d-full to
two-dimensional pressure determination problem there are functions
$\Fun{z}=\InverseFourierY{e^{2\pi{u}{z}}}{x}$ and
$\FunSecond{z}=\InverseFourierY{\Sinh{2\pi{u}{z}}}{x}$ which has multiple
analytic representations and are difficult to compute. Each function is a
Fourier transform of linear combination of exponents which reduces to poorly
defined Dirac delta function of a complex argument (see [[tab:delta-functions]]).
The usual way of handling this type of functions is to write them as
multiplication of Dirac delta functions of real and imaginary part, however,
this approach does not work here, because applying inverse Fourier transform to
this representation does not produce exponent, which severely warp resulting
velocity field. In order to get unique analytic definition normalisation factor
$1/\Sinh{2\pi{u}{h}}$ (which is also included in formula for $E(u)$) may be
used. Despite the fact that normalisation allows obtaining adequate velocity
potential field, numerical experiments show that there is little difference
between this field and the one produced by formulae from linear wave theory, in
which terms with $\zeta$ are omitted.

#+name: tab:delta-functions
#+caption: Formulae for computing $\Fun{z}$ and $\FunSecond{z}$ from [[#sec:pressure-2d]], that use normalisation to eliminate uncertainty from definition of Dirac delta function of complex argument.
#+attr_latex: :booktabs t
| Function        | Without normalisation                                      | Normalised                                                                                                                           |
|-----------------+------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------|
| $\Fun{z}$       | $\delta (x+i z)$                                           | $\frac{1}{2 h}\mathrm{sech}\left(\frac{\pi  (x-i (h+z))}{2 h}\right)$                                                                |
| $\FunSecond{z}$ | $\frac{1}{2}\left[\delta (x-i z) + \delta (x+i z) \right]$ | $\frac{1}{4 h}\left[\text{sech}\left(\frac{\pi  (x-i (h+z))}{2 h}\right)+\text{sech}\left(\frac{\pi  (x+i(h+z))}{2 h}\right)\right]$ |

** ARMA model verification
:PROPERTIES:
:CUSTOM_ID: sec:verification
:END:

In cite:degtyarev2011modelling,degtyarev2013synoptic,boukhanovsky1997thesis AR
model the following items are verified experimentally:
- probability distributions of different wave characteristics (wave heights,
  lengths, crests, periods, slopes, three-dimensionality),
- dispersion relation,
- retention of integral characteristics for mixed wave sea state.
In this work both AR and MA model are verified by comparing probability
distributions of different wave characteristics.

*** Verification of wavy surface integral characteristics
In cite:рожков1990вероятностные the authors show that several ocean wave
characteristics (listed in table [[tab:weibull-shape]]) have Weibull distribution,
and wavy surface elevation has Gaussian distribution. In order to verify that
distributions corresponding to generated realisation are correct,
quantile-quantile plots are used (plots where analytic quantile values are used
for $OX$ axis and estimated quantile values for $OY$ axis). If the estimated
distribution matches analytic then the graph has the form of the straight line.
Tails of the graph may diverge from the straight line, because they can not be
reliably estimated from the finite-size realisation. Different methods of
extracting waves from realisation produce variations in quantile function tails,
it is probably impractical to extract every possible wave from realisation since
they may (and often) overlap.

#+name: tab:weibull-shape
#+caption: Values of Weibull shape parameter for different wave characteristics.
#+attr_latex: :booktabs t
| Characteristic       | Weibull shape ($k$) |
|----------------------+---------------------|
| Wave height          |                   2 |
| Wave length          |                 2.3 |
| Crest length         |                 2.3 |
| Wave period          |                   3 |
| Wave slope           |                 2.5 |
| Three-dimensionality |                 2.5 |

Verification was performed for standing and propagating waves. The corresponding
ACFs and quantile-quantile plots of wave characteristics distributions are shown
in fig. [[acf-slices]], [[standing-wave-distributions]], [[propagating-wave-distributions]].

#+name: propagating-wave-distributions
#+begin_src R :results output graphics :exports results :file build/propagating-wave-qqplots.pdf
source(file.path("R", "common.R"))
par(pty="s", mfrow=c(2, 2))
arma.qqplot_grid(
  file.path("build", "propagating_wave"),
  c("elevation", "heights_y", "lengths_y", "periods")
)
#+end_src

#+caption: Quantile-quantile plots for propagating waves.
#+RESULTS: propagating-wave-distributions
[[file:build/propagating-wave-qqplots.pdf]]

#+name: standing-wave-distributions
#+begin_src R :results output graphics :exports results :file build/standing-wave-qqplots.pdf
source(file.path("R", "common.R"))
par(pty="s", mfrow=c(2, 2))
arma.qqplot_grid(
  file.path("build", "standing_wave"),
  c("elevation", "heights_y", "lengths_y", "periods")
)
#+end_src

#+caption: Quantile-quantile plots for standing waves.
#+RESULTS: standing-wave-distributions
[[file:build/standing-wave-qqplots.pdf]]

#+name: acf-slices
#+header: :width 6 :height 9
#+begin_src R :results output graphics :exports results :file build/acf-slices.pdf
source(file.path("R", "common.R"))
propagating_acf <- read.csv(file.path("build", "propagating_wave", "acf.csv"))
standing_acf <- read.csv(file.path("build", "standing_wave", "acf.csv"))
par(mfrow=c(5, 2), mar=c(0,0,0,0))
for (i in seq(0, 4)) {
  arma.wavy_plot(standing_acf, i, zlim=c(-5,5))
  arma.wavy_plot(propagating_acf, i, zlim=c(-5,5))
}
#+end_src

#+caption: Time slices of ACF for standing (left column) and propagating waves (right column).
#+RESULTS: acf-slices
[[file:build/acf-slices.pdf]]

*** TODO Discuss graphs
*** Verification of velocity potential fields
:PROPERTIES:
:CUSTOM_ID: sec:compare-formulae
:END:

Comparing obtained generic formulae eqref:eq:solution-2d and
eqref:eq:solution-2d-full to the known formulae from linear wave theory allows
seeing the difference between velocity fields for both large and small amplitude
waves. In general analytic formula for velocity potential in not known, even for
plain waves, so comparison is done numerically. Taking into account conclusions
of [[#sec:pressure-2d]], only finite depth formulae are compared.

**** The difference with linear wave theory formulae.
The experiment shows that velocity potential fields produced by formula
eqref:eq:solution-2d-full for finite depth fluid and formula
eqref:eq:solution-2d-linear from linear wave theory are qualitatively different
(fig. [[fig:potential-field-nonlinear]]). First, velocity potential contours have
sinusoidal shape, which is different from oval shape described by linear wave
theory. Second, velocity potential decays more rapidly than in linear wave
theory as getting closer to the bottom, and the region where the majority of
wave energy is concentrated is closer to the wave crest. Similar numerical
experiment, in which all terms of eqref:eq:solution-2d-full that are neglected
in the framework of linear wave theory are eliminated, shows no difference (as
much as machine precision allows) in resulting velocity potential fields.

#+name: fig:potential-field-nonlinear
#+caption: Velocity potential field of propagating wave $\zeta(x,y,t) = \cos(2\pi x - t/2)$. Field produced by formula eqref:eq:solution-2d-full (left) and linear wave theory formula (right).
#+attr_latex: :width 0.47\textwidth
#+begin_figure
[[file:graphics/pressure/potential-5.eps]]
[[file:graphics/pressure/potential-6.eps]]
#+end_figure

**** The difference with small-amplitude wave theory.
The experiment shows that velocity fields produced by formula
eqref:eq:solution-2d-full and eqref:eq:old-sol-2d correspond to each other for
small-amplitude waves. Two ocean wavy surface realisations are made by AR model:
one contains small-amplitude waves, other contains large-amplitude waves.
Integration in formula eqref:eq:solution-2d-full is done over wave numbers range
extracted from the generated wavy surface. For small-amplitude waves both
formulae show comparable results (the difference in the velocity is attributed
to stochastic nature of AR model), whereas for large-amplitude waves stable
velocity field is produced only by formula eqref:eq:solution-2d-full (fig.
[[fig:velocity-field-2d]]). So, generic formula eqref:eq:solution-2d-full gives
satisfactory results without restriction on wave amplitudes.

#+name: fig:velocity-field-2d
#+caption: Comparison of velocity field on the ocean wavy surface obtained by generic formula ($u_1$) and formula for small-amplitude waves ($u_2$). Velocity field for realisations containing small-amplitude (left) and large-amplitude (right) waves.
#+begin_figure
[[file:build/low-amp-nocolor.eps]]
[[file:build/high-amp-nocolor.eps]]
#+end_figure

*** Non-physical nature of ARMA model
ARMA model, owing to its non-physical nature, does not have the notion of ocean
wave; it simulates wavy surface as a whole instead. Motions of individual waves
and their shape are often rough, and the total number of waves can not be
determined precisely. However, integral characteristics of wavy surface match
the ones of real ocean waves.

Theoretically, ocean waves themselves can be chosen as ACFs, the only
pre-processing step is to make them decay exponentially. This may allow
generating waves of arbitrary profiles, and is one of the directions of future
work.

* High-performance software implementation of ocean wave simulation
** Computational model
*** Governing principles
- There are no messages in the model, a kernel is itself a message that can
  be sent over network to another node and directly access any kernel on the
  local node. It is responsibility of a programmer to ensure that such kernel
  exist.
- A kernel is best viewed as a cooperative routine, which is submitted to
  execution queue upon the call and is executed asynchronously by system
  scheduler. There can be any number of calls to other subroutines inside
  routine body. Every call submits corresponding subroutine to execution
  queue and returns immediately. Kernels in the queue can be executed in any
  order; this fact is used by system scheduler to exploit parallelism
  offered by the computer by distributed kernels from the queue across
  available cluster nodes and processor cores.
- Asynchronous execution prevents the use of explicit synchronisation after
  the call to subroutine is made; system scheduler returns control flow to
  the routine each time one of its subroutine returns. Such *cooperation*
  transforms each routine which calls subroutines into event handler, where
  each event is a subroutine and the handler is the routine that called
  them. In many batch processing programmes control flow enters each routine
  which calls subroutines at least two times: the first time it occurs upon
  the call to the routine and the second time happens when control flow
  returns to the caller after completion of a subroutine.
- The routine may communicate with any number of local kernels, addresses of
  which it knows; communication with routines which are not adjacent in the
  call stack complexifies control flow and call stack looses its tree shape.
  It is responsibility of a programmer to ensure that communicating kernels
  are present in memory. One way to ensure this is to perform communication
  between subroutines which are called from the same routine. Incidentally,
  it is the usual way of writing batch parallel programmes: each such
  communication creates a cycle in the call stack graph, and a cycle between
  different (possibly non-adjacent) layers of kernel hierarchy is redundant,
  because there are other edges that can be used instead. The situation may
  be different when the programme is interactive or event-based.
- The other disadvantage of communication which does no occur along
  hierarchical links is that it complexifies resiliency algorithms when
  executed across cluster network. Since it is difficult to ensure that
  a kernel resides in memory of a neighbour node, because a node may fail in
  the middle of its execution. Thus, upon failure of a node all of the
  subroutines which are called from the same routine must be restarted. This
  encourage a programmer to construct
   - deep hierarchies of tightly-coupled kernels (which require
    communication on the same level of hierarchy) to reduce overhead of
    recomputation,
   - fat hierarchies of loosely-coupled kernels.
  Deep hierarchy is not only requirement of technology, it helps optimise
  communication of cluster nodes limiting it to adjacent nodes.
- No explicit synchronisation.
- Local communications between adjacent nodes in the hierarchy.
*** Mapping wavy surface generation algorithm on computational model
#+name: fig:pipeline
#+begin_src dot :exports results :file build/pipeline.pdf
digraph {

  node [fontsize=14,margin="0.055,0"]
  graph [nodesep="0.25",ranksep="0.25",rankdir="TB"]
  edge [arrowsize=0.66]

  # data
  subgraph xcluster_linear {
    label="Linear model"

    start [label="",shape=circle,style=filled,fillcolor=black,width=0.23]
    spectrum [label="S(ω,θ)",shape=box]
    acf [label="K(i,j,k)",shape=box]
    phi [label="Φ(i,j,k)",shape=box]

    # transformations
    fourier_transform [label="Fourier transform",shape=box,style=rounded]
    solve_yule_walker [label="Solve Yule—Walker\nequations",shape=box,style=rounded]

    subgraph cluster_nonlinear_1 {
      label="Simulate non-linearity\l"
      labeljust=left
      style=filled
      color=lightgrey
      acf2 [label="K*(i,j,k)",shape=box]
      transform_acf [label="Transform ACF",shape=box,style=rounded]
    }
  }

  subgraph xcluster_linear2 {

    eps_parts [label="<e1> ε₁|<e2> ε₂|<e3> …|<e4> εₙ|<e> ε(t,x,y)",shape=record]
    end [label="",shape=doublecircle,style=filled,fillcolor=black,width=0.23]

    generate_white_noise [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Generate\lwhite noise",shape=record,style=rounded]
    generate_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Generate ocean\lwavy surface parts\l",shape=record,style=rounded]

    zeta_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Non-crosslinked\lrealisation parts",shape=record]
    overlap_add [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Crosslink realisation\lparts\l",shape=record,style=rounded]

    zeta_parts:g1->overlap_add:g1
    zeta_parts:g2->overlap_add:g2
    zeta_parts:g3->overlap_add:g3
    zeta_parts:g4->overlap_add:g4

    zeta_parts:g2->overlap_add:g1 [constraint=false]
    zeta_parts:g3->overlap_add:g2 [constraint=false]
    zeta_parts:g4->overlap_add:g3 [constraint=false]

    overlap_add:g1->zeta2_parts:g1
    overlap_add:g2->zeta2_parts:g2
    overlap_add:g3->zeta2_parts:g3
    overlap_add:g4->zeta2_parts:g4

    zeta2_parts:g1->transform_zeta:g1->zeta3_parts:g1->write_zeta:g1->eps_end
    zeta2_parts:g2->transform_zeta:g2->zeta3_parts:g2->write_zeta:g2->eps_end
    zeta2_parts:g3->transform_zeta:g3->zeta3_parts:g3->write_zeta:g3->eps_end
    zeta2_parts:g4->transform_zeta:g4->zeta3_parts:g4->write_zeta:g4->eps_end

  }

  subgraph part3 {

    zeta2_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Wavy surface with\lGaussian distribution\l",shape=record]

    subgraph cluster_nonlinear_2 {
      label="Simulate non-linearity\r"
      labeljust=right
      style=filled
      color=lightgrey
      zeta3_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> ζ(t,x,y)",shape=record]
      transform_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Transform wavy\lsurface elevation\lprobability distribution\l",shape=record,style=rounded]
    }

    # barriers
    eps_start [label="",shape=box,style=filled,fillcolor=black,height=0.05]
    eps_end [label="",shape=box,style=filled,fillcolor=black,height=0.05]

    write_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Write finished\lparts to a file\l",shape=record,style=rounded]
  }

  # edges
  start->spectrum->fourier_transform->acf->transform_acf
  transform_acf->acf2
  acf2->solve_yule_walker
  solve_yule_walker->phi
  phi->eps_start [constraint=false]
  eps_start->generate_white_noise:g1
  eps_start->generate_white_noise:g2
  eps_start->generate_white_noise:g3
  eps_start->generate_white_noise:g4
  generate_white_noise:g1->eps_parts:e1->generate_zeta:g1->zeta_parts:g1
  generate_white_noise:g2->eps_parts:e2->generate_zeta:g2->zeta_parts:g2
  generate_white_noise:g3->eps_parts:e3->generate_zeta:g3->zeta_parts:g3
  generate_white_noise:g4->eps_parts:e4->generate_zeta:g4->zeta_parts:g4

  eps_end->end
}
#+end_src

#+caption: Diagram of a data processing pipeline, that implements ocean wavy surface generation via AR model.
#+RESULTS: fig:pipeline
[[file:build/pipeline.pdf]]

** SMP implementation
*** Load balancing algorithm
*** Evaluation
**** Performance of MPI, OpenMP, OpenCL implementations.
**** Performance of load balancing algorithm.
** MPP implementation
*** Cluster node discovery algorithm
*** Fail over algorithm
**** Fault tolerance.
**** High availability.
* Conclusion
* Acknowledgements
* List of acronyms and symbols

#+attr_latex: :booktabs t :align lp{0.8\linewidth}
| <<<MPP>>>  | Massively Parallel Processing, computers with distributed memory                           |
| <<<SMP>>>  | Symmetric Multi-Processing, computers with shared memory                                   |
| <<<ACF>>>  | auto-covariate function                                                                    |
| <<<FFT>>>  | fast Fourier transform                                                                     |
| <<<PRNG>>> | pseudo-random number generator                                                             |
| <<<BC>>>   | boundary condition                                                                         |
| <<<PDE>>>  | partial differential equation                                                              |
| <<<NIT>>>  | non-linear inertia-less transform                                                          |
| <<<AR>>>   | auto-regressive process                                                                    |
| <<<ARMA>>> | auto-regressive moving-average process                                                     |
| <<<MA>>>   | moving average process                                                                     |
| <<<LH>>>   | Longuet---Higgins model                                                                    |
| <<<LAMP>>> | Large Amplitude Motion Programme, a programme that simulates ship behaviour in ocean waves |
| <<<CLT>>>  | central limit theorem                                                                      |
| <<<PM>>>   | Pierson---Moskowitz ocean wave spectrum approximation                                      |
| <<<YW>>>   | Yule---Walker equations                                                                    |
| <<<LS>>>   | least squares                                                                              |
| <<<PDF>>>  | probability density function                                                   |
| <<<CDF>>>  | cumulative distribution function                                                |

#+begin_export latex
\input{postamble}
#+end_export

bibliographystyle:ugost2008
bibliography:bib/refs.bib

* Appendix
