#+TITLE: High-performance ocean wave simulation model for studying marine object behaviour
#+AUTHOR: Ivan Gankevich
#+DATE: St. Petersburg, 2016
#+LANGUAGE: en
#+LATEX_CLASS: gost
#+LATEX_CLASS_OPTIONS: [hidelinks,fontsize=14pt,paper=a4,pagesize,DIV=calc]
#+LATEX_HEADER_EXTRA: \input{preamble}
#+LATEX_HEADER_EXTRA: \organization{Saint Petersburg State University}
#+LATEX_HEADER_EXTRA: \manuscript{}
#+LATEX_HEADER_EXTRA: \degree{thesis for candidate of sciences degree}
#+LATEX_HEADER_EXTRA: \speciality{Speciality 05.13.18\\Mathematical modeling, numerical methods and programme complexes}
#+LATEX_HEADER_EXTRA: \supervisor{Supervisor\\Alexander Degtyarev}
#+LATEX_HEADER_EXTRA: \newcites{published}{Publications on the subject of thesis}
#+OPTIONS: todo:nil title:nil ':t H:5

* Introduction
**** Topic relevance.
Softwarea programmes, which simulates vessel behaviour in sea waves, are widely
used to model ship motion, estimate impact of external forces on floating
platform or other marine object, and estimate capsize probability under given
weather conditions; however, to model ocean waves most of the simulation codes
use linear wave theory
cite:shin2003nonlinear,van2007forensic,kat2001prediction,van2002development, in
the framework of which it is difficult to reproduce certain peculiarities of
wind wave climate. Among them are transition between normal and storm weather,
and sea composed of multiple wave systems --- both wind waves and swell ---
heading from multiple directions. Another shortcoming of linear wave theory is
an assumption, that wave amplitude is small compared to wave length. This makes
calculations inprecise when modeling ship motion in irregular waves, for which
the assumption does not hold. So, studying new and more advanced models and
methods for ocean simulation software may increase number of its application
scenarios and foster a study of ship motion in extreme conditions in particular.

**** State-of-the-art.
Autoregressive moving average (ARMA) model emerged in response to difficulties
encountered by practitioners who used wave simulation models developed in the
framework of linear wave theory. The problems they have encountered with
Longuet---Higgins model (a model which is entirely based on linear wave theory)
can be summarised as the following.
1. /Periodicity/. Linear wave theory approximates waves by a sum of harmonics,
   so period of the whole wavy surface realisation depends on the number of
   harmonics in the model. The more realisation size is, the more coefficients
   are required to eliminate periodicity, therefore, generation time grows
   non-linearly with realisation size. This in turn results in overall low
   efficiency of any model based on this theory, no matter how optimised the
   software implementation is.
2. /Linearity/. Linear wave theory gives mathematical definition for ocean waves
   which have small amplitudes compared to their lengths. Waves of this type
   occur mostly in the ocean, so near-shore waves as well as storm waves, for
   which this assumption does not hold, are not perfectly captured by linear
   theory.
3. /Probabilistic convergence/. Phase of a wave, which is often generated by
   pseudo random number generator (PRNG), has uniform distribution, and this
   makes wavy surface characteristics (average wave height, wave period, wave
   length etc.) sometimes converge slowly to the desired values. Convergence
   rate depends on the values generated by PRNG, so high convergence rate is not
   guaranteed.

These difficulties became a starting point in search for a new model which is
not based on linear wave theory. Autoregressive moving average (ARMA) process
studies were found to have all the required mathematical apparatus.
1. ARMA process takes auto-covariate function (ACF) as an input parameter, and
   this function can be directly obtained from wave energy or
   frequency-directional spectrum (which is the input for Longuet---Higgins
   model). So, inputs for one model can easily be converted to each other.
2. There is no small-amplitude waves assumption. Wave may have any amplitude,
   and can be generated as steep as it is possible with real ocean wave ACF.
3. Period of the realisation equals the period of PRNG, so generation time grows
   linearly with the realisation size.
4. White noise --- the only probabilistic term in ARMA process --- has
   Gaussian distribution; so, convergence rate is not probabilistic.

**** Goals and objectives.
ARMA process became the basis for ARMA ocean simulation model, however, there
was still much work to be done to make it useful in practice.
1. One have to investigate how different ACF shapes affect the choice of ARMA
   parameters (the number of moving average and autoregressive processes
   coefficients).
2. Then, investigate a possibility to generate waves of arbitrary profile, not
   only cosines (which means taking into account asymmetric distribution of wavy
   surface elevation).
3. Then, derive formulae to determine pressure field under wavy surface.
   Usually, such formulae are derived for a particular model by substituting
   wave profile into the eq. eqref:eq:problem, however, ARMA process does not
   provide explicit wave profile formula, so this problem had to be solved for
   general wavy surface (which is not defined by an analytic expression),
   without linearisation of boundaries and assumption of small-amplitude waves.
4. Finally, verify wavy surface integral characteristics to match the ones of
   real ocean waves.
5. In the final stage, develop software programme that implements ARMA model and
   pressure calculation method, and allows running simulations on both shared
   memory (SMP) and distributed memory (MPP) computer systems.

**** Scientific novelty.
ARMA model, as opposed to other ocean sumulation models, does not use linear
wave theory. This makes it capable of
- generating waves with arbitrary amplitudes by adjusting wave steepness via
  ACF;
- generating waves with arbitrary profiles by adjusting asymmetry of wave
  elevation distribution via non-linear inertialess transform (NIT).
This makes it possible to use ARMA process to model transition between normal
and storm weather taking into account climate spectra and assimilation data of a
particular ocean region, which is not possible with models based on linear wave
theory.

**** Theoretical and practical significance.
**** Methodology and research methods.
**** Theses for the defense.
**** Results verification and approbation.
* Problem statement
* Related work
* ARMA model for ocean wave simulation
** Governing equations for 3-dimensional ARMA process
*** Three possible processes
Three-dimensional autoregressive moving average process is defined by
\begin{equation}
	\zeta_{i,j,k} =
	\sum\limits_{l=0}^{p_1}
	\sum\limits_{m=0}^{p_2}
	\sum\limits_{n=0}^{p_3}
	\Phi_{l,m,n} \zeta_{i-l,j-m,k-n}
	+
	\sum\limits_{l=0}^{q_1}
	\sum\limits_{m=0}^{q_2}
	\sum\limits_{n=0}^{q_3}
	\Theta_{l,m,n} \epsilon_{i-l,j-m,k-n}
	,
	\label{eq:arma-process}
\end{equation}
where $\zeta$ --- wave elevation, $\Phi$ --- AR coefficients, $\Theta$ --- MA
coefficients, $\epsilon$ --- white noise with Gaussian distribution,
$(p_1,p_2,p_3)$ --- AR process order, $(q_1,q_2,q_3)$ --- MA process order, and
$\Phi_{0,0,0} \equiv 0$, $\Theta_{0,0,0} \equiv 0$. The input parameters are
AR/MA process coefficients and order.

**** Autoregressive (AR) process.
The coefficients $\Phi$ are calculated from ACF via three-dimensional
Yule---Walker equations:
\begin{equation*}
    \Gamma
    \left[
        \begin{array}{l}
            \Phi_{0,0,0}\\
            \Phi_{0,0,1}\\
            \vdotswithin{\Phi_{0,0,0}}\\
            \Phi_{p_1,p_2,p_3}
        \end{array}
    \right]
    = 
    \left[
        \begin{array}{l}
            K_{0,0,0}-\Var{\epsilon}\\
            K_{0,0,1}\\
            \vdotswithin{K_{0,0,0}}\\
            K_{p_1,p_2,p_3}
        \end{array}
    \right],
    \qquad
    \Gamma=
    \left[
        \begin{array}{llll}
            \Gamma_0 & \Gamma_1 & \cdots & \Gamma_{p_1} \\
            \Gamma_1 & \Gamma_0 & \ddots & \vdotswithin{\Gamma_0} \\
            \vdotswithin{\Gamma_0} & \ddots & \ddots & \Gamma_1 \\
            \Gamma_{p_1} & \cdots & \Gamma_1 & \Gamma_0
        \end{array}
    \right],
\end{equation*}
where $\vec N = \left( p_1, p_2, p_3 \right)$, $\Var{\epsilon}$ --- white noise
variance, and
\begin{equation*}
    \Gamma_i = 
    \left[
    \begin{array}{llll}
        \Gamma^0_i & \Gamma^1_i & \cdots & \Gamma^{p_2}_i \\
        \Gamma^1_i & \Gamma^0_i & \ddots & \vdotswithin{\Gamma^0_i} \\
        \vdotswithin{\Gamma^0_i} & \ddots & \ddots & \Gamma^1_i \\
        \Gamma^{p_2}_i & \cdots & \Gamma^1_i & \Gamma^0_i
    \end{array}
    \right]
    \qquad
    \Gamma_i^j= 
    \left[
    \begin{array}{llll}
        K_{i,j,0} & K_{i,j,1} & \cdots & K_{i,j,p_3} \\
        K_{i,j,1} & K_{i,j,0} & \ddots &x \vdotswithin{K_{i,j,0}} \\
        \vdotswithin{K_{i,j,0}} & \ddots & \ddots & K_{i,j,1} \\
        K_{i,j,p_3} & \cdots & K_{i,j,1} & K_{i,j,0}
    \end{array}
    \right],
\end{equation*}
Since $\Phi_{0,0,0}\equiv0$, the first row and column of $\Gamma$ can be
eliminated. Matrix $\Gamma$ is block-toeplitz, positive definite and symmetric,
hence the system is solved by Cholesky decomposition. White noise variance is
estimated by
\begin{equation*}
    \Var{\epsilon} = 
	K_{0,0,0}
    - 
	\sum\limits_{i=0}^{p_1}
	\sum\limits_{i=0}^{p_2}
	\sum\limits_{k=0}^{p_3}
    \Phi_{i,j,k} K_{i,j,k}.
\end{equation*}

**** Moving average (MA) process.
The coefficients $\Theta$ are calculated from ACF via the following non-linear
system of equations:
\begin{equation*}
	K_{i,j,k} = 
	\left[
		\displaystyle
		\sum\limits_{l=i}^{q_1}
		\sum\limits_{m=j}^{q_2}
		\sum\limits_{n=k}^{q_3}
		\Theta_{l,m,n}\Theta_{l-i,m-j,n-k}
	\right]
	\Var{\epsilon},
\end{equation*}
which is solved by fixed-point iteration method via the following formulae
\begin{equation*}
	\theta_{i,j,k} =
		-\frac{K_{0,0,0}}{\Var{\epsilon}}
		+
		\sum\limits_{l=i}^{q_1}
		\sum\limits_{m=j}^{q_2}
		\sum\limits_{n=k}^{q_3}
		\Theta_{l,m,n} \Theta_{l-i,m-j,n-k}
\end{equation*}
Coefficients are updated from back to front: from
$(i,j,k) = (q_1,q_2,q_3)$ to $(i,j,k) = (0,0,0)$. White noise variance is
estimated by
\begin{equation*}
	\Var{\epsilon} = \frac{K_{0,0,0}}{
		1
		+
		\sum\limits_{i=0}^{q_1}
		\sum\limits_{i=0}^{q_2}
		\sum\limits_{k=0}^{q_3}
		\Theta_{i,j,k}^2
	}.
\end{equation*}

**** Mixed autoregressive moving average (ARMA) process.
Generally speaking, formulae for mixed process are the same as for AR and MA
part, but there are several approaches to mix them.
- The approach proposed in~\cite{box1976time} which involves dividing ACF into
  MA and AR part is not applicable here, because in three dimensions the
  division is not possible: there always be parts of the ACF that are not taken
  into account by AR and MA process.
- The alternative approach is to use the same (undivided) ACF for both AR and MA
  part but use different process order, however, then realisation
  characteristics (mean, variance etc.) become skewed: these are characteristics
  of the two overlapped processes.
For the first approach there is a formula to recompute ACF for AR part to make
the mixed process correspond to the initial ACF, but there is no such formula
for the second approach. So, the best solution for now is to simply use AR and
MA process exclusively.

*** Process selection criteria for different wave profiles
The main problem of ARMA model application to ocean wave generation is that for
different types of wave profiles different processes /must/ be used: standing
waves can only be generated by AR process, and propagating waves can only be
generated by MA process. This statement comes from practice: if one tries to use
the processes the other way round, the resulting realisation either diverges or
does not look like real ocean waves. (The latter happens for non-invertible MA
process, and sometimes for AR process for an unknown reason.) So, the best way to
apply ARMA model to ocean wave generation is to use AR process for standing
waves and MA process for progressive waves.

The other problem of three-dimensional AR and MA processes in this context is
inability to determine the number of coefficients from ACF. For one-dimensional
processes this can be achieved via iterative methods, but their formulae need to
be mapped to three-dimensions, otherwise they do not converge.

The final problem is how to mix 3-dimensional AR and MA processes. Again the new
formula to recompute ACF needs to be derived in case of three dimensions.

It appears that some statements made for AR and MA processes in cite:box1976time
(a book from creators of ARMA process) should be flipped for three-dimensional
case. For example, the authors say that ACF of MA process is cut at
$(q_1,q_2,q_3)$ and ACF of AR process decays to nought infinitely, but in
practice making ACF of 3-dimensional MA process not decay results in it being
non-invertible and producing realisation that does not look like real ocean
waves, whereas doing the same for ACF of AR process does not have severe
consequences. The second example: the authors say that one should allocate the
first $q$ points of ACF to MA process (as it often needed to describe the peaks
in ACF) and leave the rest points to AR process, but in practice in case of ACF
of a propagating wave AR process is stationary only for the first time slice of
the ACF, and the rest is left to MA process.

So, for now the only safe scenario is to use AR process for standing waves and
MA process for propagating waves. With new formulae for 3 dimensions a single
mixed ARMA process might be a better choice, but this is the objective of the
future research.

** Modeling non-linearity of ocean waves
** Determining wave pressures for discretely given wavy surface
* Numerical methods and experimental results
** The shape of ACF for different types of waves
*** Two methods to find ocean wave's ACF
**** Analytic method of finding the ACF.
The simplest way to find auto-covariate function for a particular ocean wave
profile is to apply Wiener---Khinchin theorem. According to this theorem the
autocorrelation $K$ of a function $\zeta$ is given by the Fourier transform of
the absolute square of the function:
\begin{equation}
  K(t) = \Fourier{\left| \zeta(t) \right|^2}.
  \label{eq:wiener-khinchin}
\end{equation}
When $\zeta$ is replaced with actual wave profile, this formula gives you
analytic expression for the corresponding ACF.

For three-dimensional wave profile (2D in space and 1D in time) analytic
expression is a polynomial of high order and is best obtained via computer
algebra software. Then for practical usage it can be approximated by
superposition of exponentially decaying cosines (which is how ACF of a
stationary ARMA process looks like cite:box1976time).

**** Empirical method of finding the ACF.
However, for three-dimensional case there exists simpler empirical method which
does not require sophisticated software to determine shape of the ACF. It is
known that ACF represented by exponentially decaying cosines of a wave profile
satisfies first order Stokes' equations for gravity waves cite:boccotti1983wind.
So, if the shape of the wave profile is the only concern, then one can simply
multiply it by a decaying exponent to get appropriate ACF. This ACF will not
reflect other wave profile parameters such as wave height and period, but opens
possibility to simulate waves of a particular non-analytic shape by "drawing"
their profile, then multiplying it by an exponent and using the resulting
function as ACF. So, this empirical method is imprecise but offers simpler
alternative to Wiener---Khinchin theorem; it is mainly useful to test ARMA
model.

*** Examples of ACFs for various types of wave profiles
**** Standing wave.
For three-dimensional standing wave the profile is approximated by
\begin{equation}
  \zeta(t, x, y) = A \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq:standing-wave}
\end{equation}
In order to get ACF via analytic method one needs to multiply this expression by
a decaying exponent, because Fourier transform is defined for a function $f$ that
$f \underset{x \rightarrow \pm \infty}{\longrightarrow} 0$. The formula of the
profile then transforms to
\begin{equation}
  \zeta(t, x, y) =
  A
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq:decaying-standing-wave}
\end{equation}
Then, if one takes 3D Fourier transform of this expression via any capable
computer algebra software, the resulting polynomial may be fitted to the
following ACF approximation.
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos \beta t
  \cos \left[ \beta x + \beta y \right].
  \label{eq:standing-wave-acf}
\end{equation}
So, after applying Wiener---Khinchin theorem we get the same formula but with
sines replaced with cosines. This replacement is important because the value of
ACF at $(0,0,0)$ equals to the variance of wave elevation, and if one used sines
the value would be wrong.

If one tries to replicate the same formula via empirical method, the usual way
is to adapt eqref:eq:decaying-standing-wave to match eqref:eq:standing-wave-acf.
This can be done by changing the phase of the sine, or by replacing sine with
cosine to move the maximum of the function to $(0,0,0)$.

**** Propagating wave.
Three-dimensional profile of this type of wave is approximated by
\begin{equation}
  \zeta(t, x, y) = A \cos (\sigma t + k_x x + k_y y).
  \label{eq:propagating-wave}
\end{equation}
For the analytic method one may repeat steps from the previous two paragraphs
with ACF approximated by
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos\left[\beta (t+x+y) \right].
  \label{eq:propagating-wave-acf}
\end{equation}
For the empirical method propagating wave profile is simply multiplied by
a decaying exponent without need to adapt the maximum value of ACF.

*** Comparison of studied methods
To summarise, the analytic method of finding ocean wave's ACF reduces to the
following steps:
- Make wave profile decay when approach $\pm \infty$ by multiplying it by
  a decaying exponent.
- Take Fourier transform of absolute square of the decaying wave profile using
  computer algebra software.
- Fit the resulting polynomial to the appropriate ACF approximation.

Two examples in this section showed that in case of standing and propagating
waves their decaying profiles resemble the corresponding ACFs with the exception
that the origin should be moved to the function's maximal value for the ACF to
be useful in ARMA model simulations. So, using the empirical method the ACF is
found in the following steps:
- Make wave profile decay when approach $\pm \infty$ by multiplying it by
  a decaying exponent.
- Move maximum value to the origin by adjusting phases or using trigonometric
  identities to shift the phase of the resulting function.

** Additional formulae, methods and algorithms for ARMA model
*** Wave elevation distribution approximation
*** White noise generation
*** Wavy surface generation
** ARMA model verification
*** Numerical experiments implementation methodology
*** Verification of wavy surface integral characteristics
Research shows cite:рожков1990вероятностные that several ocean wave
characteristics (e.g. wave height, wave period, wave length etc.) have Weibull
distribution differing only in shape parameter (tab. [[tab:weibull-shape]]), and
wave elevation has Gaussian distribution. In order to verify that distributions
corresponding to generated realisation are correct, quantile-quantile plots are
used (plots where analytic quantile values are used for X axis and estimated
quantile values for Y axis). If the estimated distribution matches analytic then
the graph has the form of the straight line. Tails of the graph may diverge from
the straight line, because they can not be reliably estimated from the
realisation. Different methods of extracting waves from realisation produce
variations in quantile function tails, it is probably impractical to extract
every possible wave from realisation since they may (and often) overlap.

#+name: tab:weibull-shape
#+caption: Values of Weibull shape parameter for different wave characteristics.
#+attr_latex: :booktabs t
| Characteristic       | Weibull shape ($k$) |
|----------------------+---------------------|
| Wave height          |                   2 |
| Wave length          |                 2.3 |
| Crest length         |                 2.3 |
| Wave period          |                   3 |
| Wave slope           |                 2.5 |
| Three-dimensionality |                 2.5 |

Verification was performed for standing and propagating waves. The corresponding
ACFs and quantile-quantile plots of wave characteristics distributions are shown
in fig. [[fig:acf-plots]], [[fig:standing-wave-distributions]],
[[fig:propagating-wave-distributions]].

#+begin_src gnuplot :exports none :output-dir build
# set absolute loadpath and go to build directory
set loadpath GPVAL_PWD."/gnuplot" GPVAL_PWD."/data/verification"
system "mkdir -p build"
cd "build"

# ACFs of standing and propagating waves
sx=300
sy=200
outext='svg'
# Standing wave ACF
do for [i=0:4] {
  reset
  infile="standing-acf-" . i
  load "acf.gnuplot"
  system "inkscape --without-gui --export-eps=" . infile . ".eps " . infile . ".svg"
}
# Propagating wave ACF
do for [i=0:4] {
  reset
  infile="propagating-acf-0" . i
  load "acf.gnuplot"
  system "inkscape --without-gui --export-eps=" . infile . ".eps " . infile . ".svg"
}

# Q-Q plots
sx=250
sy=250
outext='svg'
# Standing waves
do for [i in "elevation wave-height-x wave-length-x wave-period"] {
  reset
  show loadpath
  labelText=i
  infile="standing-" . i
  load "quantile.gnuplot"
  system "inkscape --without-gui --export-eps=" . infile . ".eps " . infile . ".svg"
}
# Propagating waves
do for [i in "elevation wave-height-x wave-length-x wave-period"] {
  reset
  labelText=i
  infile="propagating-" . i
  load "quantile.gnuplot"
  system "inkscape --without-gui --export-eps=" . infile . ".eps " . infile . ".svg"
}
exit
#+end_src

#+RESULTS:

#+caption: Time slices of ACF function for standing (left column) and propagating waves (right column).
#+name: fig:acf-plots
| \includegraphics{standing-acf-0} | \includegraphics{propagating-acf-00} |
| \includegraphics{standing-acf-1} | \includegraphics{propagating-acf-01} |
| \includegraphics{standing-acf-2} | \includegraphics{propagating-acf-02} |
| \includegraphics{standing-acf-3} | \includegraphics{propagating-acf-03} |
| \includegraphics{standing-acf-4} | \includegraphics{propagating-acf-04} |

#+caption: Quantile-quantile plots for standing waves.
#+name: fig:standing-wave-distributions
| \includegraphics{standing-elevation}     | \includegraphics{standing-wave-height-x} |
| \includegraphics{standing-wave-length-x} | \includegraphics{standing-wave-period}   |

#+caption: Quantile-quantile plots for propagating waves.
#+name: fig:propagating-wave-distributions
| \includegraphics{propagating-elevation}     | \includegraphics{propagating-wave-height-x} |
| \includegraphics{propagating-wave-length-x} | \includegraphics{propagating-wave-period}   |

*** TODO Discuss graphs
*** Verification of velocity potential fields
*** Non-physical nature of ARMA model
ARMA model, owing to its non-physical nature, does not have the notion of ocean
wave; it simulates wavy surface as a whole instead. Motions of individual waves
and their shape are often rough, and the total number of waves can not be
predicted precisely. However, integral characteristics of wavy surface match the
ones of real ocean waves.

In theory, ocean waves themselves can be chosen as ACFs, the only pre-processing
step is to make them decay exponentially. This is required to make AR model
stationary and MA model parameters finding algorithm to converge.

* High-performance software implementation of ocean wave simulation
** Computational model
*** Governing principles
- There are no messages in the model, a kernel is itself a message that can
  be sent over network to another node and directly access any kernel on the
  local node. It is responsibility of a programmer to ensure that such kernel
  exist.
- A kernel is best viewed as a cooperative routine, which is submitted to
  execution queue upon the call and is executed asynchronously by system
  scheduler. There can be any number of calls to other subroutines inside
  routine body. Every call submits corresponding subroutine to execution
  queue and returns immediately. Kernels in the queue can be executed in any
  order; this fact is used by system scheduler to exploit parallelism
  offered by the computer by distributed kernels from the queue across
  available cluster nodes and processor cores.
- Asynchronous execution prevents the use of explicit synchronisation after
  the call to subroutine is made; system scheduler returns control flow to
  the routine each time one of its subroutine returns. Such *cooperation*
  transforms each routine which calls subroutines into event handler, where
  each event is a subroutine and the handler is the routine that called
  them. In many batch processing programmes control flow enters each routine
  which calls subroutines at least two times: the first time it occurs upon
  the call to the routine and the second time happens when control flow
  returns to the caller after completion of a subroutine.
- The routine may communicate with any number of local kernels, addresses of
  which it knows; communication with routines which are not adjacent in the
  call stack complexifies control flow and call stack looses its tree shape.
  It is responsibility of a programmer to ensure that communicating kernels
  are present in memory. One way to ensure this is to perform communication
  between subroutines which are called from the same routine. Incidentally,
  it is the usual way of writing batch parallel programmes: each such
  communication creates a cycle in the call stack graph, and a cycle between
  different (possibly non-adjacent) layers of kernel hierarchy is redundant,
  because there are other edges that can be used instead. The situation may
  be different when the programme is interactive or event-based.
- The other disadvantage of communication which does no occur along
  hierarchical links is that it complexifies resiliency algorithms when
  executed across cluster network. Since it is difficult to ensure that
  a kernel resides in memory of a neighbour node, because a node may fail in
  the middle of its execution. Thus, upon failure of a node all of the
  subroutines which are called from the same routine must be restarted. This
  encourage a programmer to construct
   - deep hierarchies of tightly-coupled kernels (which require
    communication on the same level of hierarchy) to reduce overhead of
    recomputation,
   - fat hierarchies of loosely-coupled kernels.
  Deep hierarchy is not only requirement of technology, it helps optimise
  communication of cluster nodes limiting it to adjacent nodes.
- No explicit synchronisation.
- Local communications between adjacent nodes in the hierarchy.
*** Mapping wavy surface generation algorithm on computational model
** SMP implementation
*** Load balancing algorithm
*** Evaluation
**** Performance of MPI, OpenMP, OpenCL implementations.
**** Performance of load balancing algorithm.
** MPP implementation
*** Cluster node discovery algorithm
*** Fail over algorithm
**** Fault tolerance.
**** High availability.
* Conclusion
* Acknowledgments
#+latex: \clearpage
* List of acronyms and symbols

#+attr_latex: :booktabs t :align lp{0.8\linewidth}
| <<<MPP>>>  | Massively Parallel Processing, computers with distributed memory |
| <<<SMP>>>  | Symmetric Multi-Processing, computers with shared memory         |
| <<<ACF>>>  | auto-covatiate function                                          |
| <<<FFT>>>  | fast Fourier transform                                           |
| <<<PRNG>>> | pseudo-random number generator                                   |
| <<<BC>>>   | boundary condition                                               |
| <<<PDE>>>  | partial differential equation                                    |
| <<<NIT>>>  | non-linear intertialess transform                                |
| <<<AR>>>   | autoregressive process                                           |
| <<<ARMA>>> | autoregressive moving average process                            |
| <<<MA>>>   | moving average process                                           |

#+begin_latex
\input{postamble}
#+end_latex

bibliographystyle:ugost2008
bibliography:bib/refs.bib

* Appendix
