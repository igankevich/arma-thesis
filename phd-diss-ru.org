#+TITLE: Высокопроизводительная модель морского волнения для программ динамики морских объектов
#+AUTHOR: Иван Ганкевич
#+DATE: Санкт-Петербург, 2016
#+LANGUAGE: ru
#+LATEX_CLASS: gost
#+LATEX_CLASS_OPTIONS: [hidelinks,fontsize=14pt,paper=a4,pagesize,DIV=calc]
#+LATEX_HEADER_EXTRA: \input{preamble}
#+LATEX_HEADER_EXTRA: \organization{Санкт-Петербургский государственный университет}
#+LATEX_HEADER_EXTRA: \manuscript{на правах рукописи}
#+LATEX_HEADER_EXTRA: \degree{Диссертация на соискание ученой степени\\кандидата физико-математических наук}
#+LATEX_HEADER_EXTRA: \speciality{Специальность 05.13.18\\Математическое моделирование, численные методы и комплексы программ}
#+LATEX_HEADER_EXTRA: \supervisor{Научный руководитель\\д.т.н Дегтярев Александр Борисович}
#+LATEX_HEADER_EXTRA: \newcites{published}{Список опубликованных по теме диссертации работ}
#+OPTIONS: todo:nil title:nil ':t H:5
#+STARTUP: indent

* Config                                                           :noexport:
# default export options
#+begin_src emacs-lisp :exports none :results silent
;; For the full list of options see
;; http://orgmode.org/manual/Publishing-options.html
;; move table/figure captions to the bottom
(setq org-latex-caption-above nil)
;; preserve original image width
(setq org-latex-image-default-width nil)
#+end_src

** Produce data for Q-Q and ACF plots
#+begin_src sh :exports none :results verbatim
root=$(pwd)
for testname in propagating_wave standing_wave
do
    wd=$root/build/$testname
    rm -rf $wd
    mkdir -p $wd
    cd $wd
    arma -c $root/config/$testname.arma 2>&1
done
#+end_src

#+RESULTS:
#+begin_example
Input file                     = /home/igankevich/workspace/phd-diss/config/propagating_wave.arma
ACF grid size                  = (20,10,10)
ACF grid patch size            = (0.526316,0.555556,0.555556)
Output grid size               = (200,40,40)
Output grid patch size         = (1,1,1)
AR order                       = (10,10,10)
Do least squares               = 0
ACF function                   = propagating_wave
Model                          = MA
MA algorithm                   = fixed_point_iteration
Verification scheme            = manual
ACF variance = 5
fixed_point_iteration:Iteration=0, var_wn=2.70831
fixed_point_iteration:Iteration=1, var_wn=1.93791
fixed_point_iteration:Iteration=2, var_wn=1.54801
fixed_point_iteration:Iteration=3, var_wn=1.31202
fixed_point_iteration:Iteration=4, var_wn=1.15328
fixed_point_iteration:Iteration=5, var_wn=1.0386
fixed_point_iteration:Iteration=6, var_wn=0.951442
fixed_point_iteration:Iteration=7, var_wn=0.882674
fixed_point_iteration:Iteration=8, var_wn=0.82688
fixed_point_iteration:Iteration=9, var_wn=0.780623
fixed_point_iteration:Iteration=10, var_wn=0.74161
fixed_point_iteration:Iteration=11, var_wn=0.708244
fixed_point_iteration:Iteration=12, var_wn=0.679374
fixed_point_iteration:Iteration=13, var_wn=0.654145
fixed_point_iteration:Iteration=14, var_wn=0.63191
fixed_point_iteration:Iteration=15, var_wn=0.612168
fixed_point_iteration:Iteration=16, var_wn=0.594523
fixed_point_iteration:Iteration=17, var_wn=0.578663
fixed_point_iteration:Iteration=18, var_wn=0.564333
fixed_point_iteration:Iteration=19, var_wn=0.551325
fixed_point_iteration:Iteration=20, var_wn=0.539469
fixed_point_iteration:Iteration=21, var_wn=0.528623
fixed_point_iteration:Iteration=22, var_wn=0.518666
fixed_point_iteration:Iteration=23, var_wn=0.509497
fixed_point_iteration:Iteration=24, var_wn=0.50103
fixed_point_iteration:Iteration=25, var_wn=0.493191
fixed_point_iteration:Iteration=26, var_wn=0.485916
fixed_point_iteration:Iteration=27, var_wn=0.479148
fixed_point_iteration:Iteration=28, var_wn=0.472841
fixed_point_iteration:Iteration=29, var_wn=0.466951
fixed_point_iteration:Iteration=30, var_wn=0.461442
fixed_point_iteration:Iteration=31, var_wn=0.456279
fixed_point_iteration:Iteration=32, var_wn=0.451435
fixed_point_iteration:Iteration=33, var_wn=0.446882
fixed_point_iteration:Iteration=34, var_wn=0.442597
fixed_point_iteration:Iteration=35, var_wn=0.43856
fixed_point_iteration:Iteration=36, var_wn=0.434752
fixed_point_iteration:Iteration=37, var_wn=0.431155
fixed_point_iteration:Iteration=38, var_wn=0.427755
fixed_point_iteration:Iteration=39, var_wn=0.424538
fixed_point_iteration:Iteration=40, var_wn=0.42149
fixed_point_iteration:Iteration=41, var_wn=0.418601
fixed_point_iteration:Iteration=42, var_wn=0.415859
fixed_point_iteration:Iteration=43, var_wn=0.413256
fixed_point_iteration:Iteration=44, var_wn=0.410782
fixed_point_iteration:Iteration=45, var_wn=0.40843
fixed_point_iteration:Iteration=46, var_wn=0.406191
fixed_point_iteration:Iteration=47, var_wn=0.404059
fixed_point_iteration:Iteration=48, var_wn=0.402029
fixed_point_iteration:Iteration=49, var_wn=0.400092
fixed_point_iteration:Iteration=50, var_wn=0.398246
fixed_point_iteration:Iteration=51, var_wn=0.396483
fixed_point_iteration:Iteration=52, var_wn=0.3948
fixed_point_iteration:Iteration=53, var_wn=0.393193
fixed_point_iteration:Iteration=54, var_wn=0.391656
fixed_point_iteration:Iteration=55, var_wn=0.390188
fixed_point_iteration:Iteration=56, var_wn=0.388782
fixed_point_iteration:Iteration=57, var_wn=0.387438
fixed_point_iteration:Iteration=58, var_wn=0.386151
fixed_point_iteration:Iteration=59, var_wn=0.384918
fixed_point_iteration:Iteration=60, var_wn=0.383738
fixed_point_iteration:Iteration=61, var_wn=0.382606
fixed_point_iteration:Iteration=62, var_wn=0.381522
fixed_point_iteration:Iteration=63, var_wn=0.380482
fixed_point_iteration:Iteration=64, var_wn=0.379485
fixed_point_iteration:Iteration=65, var_wn=0.378528
fixed_point_iteration:Iteration=66, var_wn=0.37761
fixed_point_iteration:Iteration=67, var_wn=0.376729
fixed_point_iteration:Iteration=68, var_wn=0.375882
fixed_point_iteration:Iteration=69, var_wn=0.37507
fixed_point_iteration:Iteration=70, var_wn=0.374289
fixed_point_iteration:Iteration=71, var_wn=0.373539
fixed_point_iteration:Iteration=72, var_wn=0.372818
fixed_point_iteration:Iteration=73, var_wn=0.372126
fixed_point_iteration:Iteration=74, var_wn=0.37146
fixed_point_iteration:Iteration=75, var_wn=0.37082
fixed_point_iteration:Iteration=76, var_wn=0.370204
fixed_point_iteration:Iteration=77, var_wn=0.369612
fixed_point_iteration:Iteration=78, var_wn=0.369042
fixed_point_iteration:Iteration=79, var_wn=0.368494
fixed_point_iteration:Iteration=80, var_wn=0.367966
fixed_point_iteration:Iteration=81, var_wn=0.367458
fixed_point_iteration:Iteration=82, var_wn=0.366969
fixed_point_iteration:Iteration=83, var_wn=0.366499
fixed_point_iteration:Iteration=84, var_wn=0.366046
fixed_point_iteration:Iteration=85, var_wn=0.36561
fixed_point_iteration:Iteration=86, var_wn=0.365189
fixed_point_iteration:Iteration=87, var_wn=0.364785
fixed_point_iteration:Iteration=88, var_wn=0.364395
fixed_point_iteration:Iteration=89, var_wn=0.364019
fixed_point_iteration:Iteration=90, var_wn=0.363657
fixed_point_iteration:Iteration=91, var_wn=0.363309
fixed_point_iteration:Iteration=92, var_wn=0.362973
fixed_point_iteration:Iteration=93, var_wn=0.362649
fixed_point_iteration:Iteration=94, var_wn=0.362337
fixed_point_iteration:Iteration=95, var_wn=0.362036
fixed_point_iteration:Iteration=96, var_wn=0.361746
fixed_point_iteration:Iteration=97, var_wn=0.361466
fixed_point_iteration:Iteration=98, var_wn=0.361197
fixed_point_iteration:Iteration=99, var_wn=0.360937
fixed_point_iteration:Iteration=100, var_wn=0.360686
fixed_point_iteration:Iteration=101, var_wn=0.360444
fixed_point_iteration:Iteration=102, var_wn=0.360211
fixed_point_iteration:Iteration=103, var_wn=0.359986
fixed_point_iteration:Iteration=104, var_wn=0.359769
fixed_point_iteration:Iteration=105, var_wn=0.35956
fixed_point_iteration:Iteration=106, var_wn=0.359358
fixed_point_iteration:Iteration=107, var_wn=0.359163
fixed_point_iteration:Iteration=108, var_wn=0.358975
fixed_point_iteration:Iteration=109, var_wn=0.358794
fixed_point_iteration:Iteration=110, var_wn=0.358619
fixed_point_iteration:Iteration=111, var_wn=0.35845
fixed_point_iteration:Iteration=112, var_wn=0.358288
fixed_point_iteration:Iteration=113, var_wn=0.35813
fixed_point_iteration:Iteration=114, var_wn=0.357979
fixed_point_iteration:Iteration=115, var_wn=0.357832
fixed_point_iteration:Iteration=116, var_wn=0.357691
fixed_point_iteration:Iteration=117, var_wn=0.357555
fixed_point_iteration:Iteration=118, var_wn=0.357423
fixed_point_iteration:Iteration=119, var_wn=0.357296
fixed_point_iteration:Iteration=120, var_wn=0.357173
fixed_point_iteration:Iteration=121, var_wn=0.357055
fixed_point_iteration:Iteration=122, var_wn=0.356941
fixed_point_iteration:Iteration=123, var_wn=0.356831
fixed_point_iteration:Iteration=124, var_wn=0.356724
fixed_point_iteration:Iteration=125, var_wn=0.356621
fixed_point_iteration:Iteration=126, var_wn=0.356522
fixed_point_iteration:Iteration=127, var_wn=0.356426
fixed_point_iteration:Iteration=128, var_wn=0.356334
fixed_point_iteration:Iteration=129, var_wn=0.356244
fixed_point_iteration:Iteration=130, var_wn=0.356158
fixed_point_iteration:Iteration=131, var_wn=0.356075
fixed_point_iteration:Iteration=132, var_wn=0.355994
fixed_point_iteration:Iteration=133, var_wn=0.355917
fixed_point_iteration:Iteration=134, var_wn=0.355842
fixed_point_iteration:Iteration=135, var_wn=0.355769
fixed_point_iteration:Iteration=136, var_wn=0.355699
fixed_point_iteration:Iteration=137, var_wn=0.355632
fixed_point_iteration:Iteration=138, var_wn=0.355567
fixed_point_iteration:Iteration=139, var_wn=0.355504
fixed_point_iteration:Iteration=140, var_wn=0.355443
fixed_point_iteration:Iteration=141, var_wn=0.355384
fixed_point_iteration:Iteration=142, var_wn=0.355327
fixed_point_iteration:Iteration=143, var_wn=0.355273
fixed_point_iteration:Iteration=144, var_wn=0.35522
fixed_point_iteration:Iteration=145, var_wn=0.355169
fixed_point_iteration:Iteration=146, var_wn=0.355119
fixed_point_iteration:Iteration=147, var_wn=0.355072
fixed_point_iteration:Iteration=148, var_wn=0.355026
fixed_point_iteration:Iteration=149, var_wn=0.354981
fixed_point_iteration:Iteration=150, var_wn=0.354938
fixed_point_iteration:Iteration=151, var_wn=0.354897
fixed_point_iteration:Iteration=152, var_wn=0.354856
fixed_point_iteration:Iteration=153, var_wn=0.354818
fixed_point_iteration:Iteration=154, var_wn=0.35478
fixed_point_iteration:Iteration=155, var_wn=0.354744
fixed_point_iteration:Iteration=156, var_wn=0.354709
fixed_point_iteration:Iteration=157, var_wn=0.354676
fixed_point_iteration:Iteration=158, var_wn=0.354643
fixed_point_iteration:Iteration=159, var_wn=0.354612
fixed_point_iteration:Iteration=160, var_wn=0.354581
fixed_point_iteration:Iteration=161, var_wn=0.354552
fixed_point_iteration:Iteration=162, var_wn=0.354524
fixed_point_iteration:Iteration=163, var_wn=0.354496
fixed_point_iteration:Iteration=164, var_wn=0.35447
fixed_point_iteration:Iteration=165, var_wn=0.354444
fixed_point_iteration:Iteration=166, var_wn=0.35442
fixed_point_iteration:Iteration=167, var_wn=0.354396
fixed_point_iteration:Iteration=168, var_wn=0.354373
fixed_point_iteration:Iteration=169, var_wn=0.35435
fixed_point_iteration:Iteration=170, var_wn=0.354329
fixed_point_iteration:Iteration=171, var_wn=0.354308
fixed_point_iteration:Iteration=172, var_wn=0.354288
fixed_point_iteration:Iteration=173, var_wn=0.354269
fixed_point_iteration:Iteration=174, var_wn=0.35425
fixed_point_iteration:Iteration=175, var_wn=0.354232
fixed_point_iteration:Iteration=176, var_wn=0.354214
fixed_point_iteration:Iteration=177, var_wn=0.354198
fixed_point_iteration:Iteration=178, var_wn=0.354181
fixed_point_iteration:Iteration=179, var_wn=0.354165
fixed_point_iteration:Iteration=180, var_wn=0.35415
fixed_point_iteration:Iteration=181, var_wn=0.354136
fixed_point_iteration:Iteration=182, var_wn=0.354121
fixed_point_iteration:Iteration=183, var_wn=0.354108
fixed_point_iteration:Iteration=184, var_wn=0.354094
fixed_point_iteration:Iteration=185, var_wn=0.354082
fixed_point_iteration:Iteration=186, var_wn=0.354069
fixed_point_iteration:Iteration=187, var_wn=0.354057
fixed_point_iteration:Iteration=188, var_wn=0.354046
fixed_point_iteration:Iteration=189, var_wn=0.354034
fixed_point_iteration:Iteration=190, var_wn=0.354024
fixed_point_iteration:Iteration=191, var_wn=0.354013
fixed_point_iteration:Iteration=192, var_wn=0.354003
fixed_point_iteration:Iteration=193, var_wn=0.353994
WN variance = 0.353994
Input file                     = /home/igankevich/workspace/phd-diss/config/standing_wave.arma
ACF grid size                  = (10,10,10)
ACF grid patch size            = (0.277778,0.555556,0.555556)
Output grid size               = (200,40,40)
Output grid patch size         = (1,1,1)
AR order                       = (7,7,7)
Do least squares               = 0
ACF function                   = standing_wave
Model                          = AR
MA algorithm                   = fixed_point_iteration
Verification scheme            = manual
ACF variance = 5
WN variance = 0.00261323
Zeta size = (193,33,33)
NaN: 29, -nan, 1.798e+36, -1.04284e+38, inf, -1.798e+36, -1.798e+36
#+end_example

* Введение
**** Актуальность темы.
Программы, моделирующие поведение судна на морских волнах, широко применяются
для расчета качки судна, оценки величины воздействия внешних сил на плавучую
платформу или другой морской объект, а также для оценки вероятности
опрокидывания судна при заданных погодных условиях; однако, большинство из них
используют линейную теорию для моделирования морского волнения
cite:shin2003nonlinear,van2007forensic,kat2001prediction,van2002development, в
рамках которой сложно воспроизвести определенные особенности ветроволнового
климата. Среди них можно выделить переход от нормальных погодных условий к
шторму и волнение, вызванное наложением множества систем ветровых волн и волн
зыби, распространяющихся в нескольких направлениях. Другой недостаток линейной
теории волн заключается в предположении, что высота волн много меньше их длины.
Это делает расчеты грубыми при моделировании качки судна в условиях
нерегулярного волнения, когда такое предположение несправедливо. Разработка
новых и более совершенных моделей и методов, используемых при расчете динамики
судна, может увеличить количество сценариев ее применения и, в частности,
способствовать исследованию поведения судна в экстремальных условиях.

**** Степень разработанности.
Модель авторегрессии скользящего среднего АРСС возникла как ответ на сложности,
с которыми на практике сталкиваются ученые, использующие в свой работе модели
морского волнения, разработанные в рамках линейной теории волн. Проблемы, с
которыми они сталкиваются при использовании модели Лонге---Хиггинса (которая
полностью основана на линейной теории волн) перечислены ниже.
1. /Периодичность/. В рамках линейной теории волны аппроксимируются суммой
   гармоник, а период реализации взволнованной поверхности зависит от их
   количества. Чем больше размер реализации, тем больше коэффициентов требуется
   для исключения периодичности, поэтому с увеличением размера реализации время
   ее генерации растет нелинейно. Это приводит к тому, что любая модель,
   основанная на линейной теории, неэффективна при генерации больших реализаций
   взволнованной поверхности, независимо от того, насколько оптимизирован
   исходный код программы.
2. /Линейность/. В рамках линейной теории волн дается математическое определение
   морским волнам в предположении малости их амплитуд по сравнению с длинами.
   Такие волны, в основном, характерны для открытого моря и океана, а волны в
   прибрежных районах и штормовые волны, для которых это предположение
   несправедливо, грубо описываются в рамках линейной теории.
3. /Вероятностная сходимость/. Фаза волны, значение которой обычно получается с
   помощью генератора псевдослучайных чисел (ГПСЧ), имеет равномерное
   распределение, что иногда приводит к медленной сходимости интегральных
   характеристик взволнованной поверхности (таких как распределение высот волн,
   их периодов, длин и т.п.). Скорость сходимости зависит от значений,
   полученных от ГПСЧ, поэтому быстрая сходимость не гарантируется.

Эти сложности стали отправной точкой в поиске модели, не основанной на линейной
теории волн, и в исследованиях процесса авторегрессии скользящего среднего
(АРСС) был найден необходимый математический аппарат.
1. Параметром процесса АРСС является автоковариационная функция (АКФ), которая
   может быть напрямую получена из энергетического или частотно-направленного
   спектра морского волнения (который, в свою очередь является входным
   параметром для модели Лонге---Хиггинса). Так что входные параметры одной
   модели могут быть легко преобразованы во входные параметры другой.
2. Процесс АРСС не имеет ограничение на амплитуду генерируемых волн: их крутизна
   может быть увеличена на столько, на сколько это позволяет АКФ реальных
   морских волн.
3. Период реализации равен периоду ГПСЧ, поэтому время генерации растет линейно
   с увеличением размера реализации.
4. Белый шум, который является единственным вероятностным членом формулы
   процесса АРСС, имеет нормальное распределение; так что скорость сходимость не
   носит вероятностный характер.

**** Цели и задачи.
Процесс АРСС стал основой модели ветрового волнения АРСС, однако он нуждался в
доработке перед тем, как его можно было бы использовать на практике.
1. Необходимо было исследовать, как различные формы АКФ влияют на выбор
   параметров процесса АРСС (количество коэффициентов процесса скользящего
   среднего и процесса авторегрессии).
2. Затем исследовать возможность генерации волн с произвольным профилем, а не
   только профиль синусоиды (учесть асимметричность распределения волновых
   аппликат взволнованной поверхности).
3. Затем вывести формулы для определения поля давлений под взволнованной
   поверхностью. Такие формулы обычно выводятся для конкретной модели путем
   подстановки формулы профиля волны в eqref:eq:problem, однако процесс АРСС не
   содержит в себе формулу профиля волны в явном виде, поэтому для него
   необходимо было получить решение для взволнованной поверхности общего вида
   (для которой не существует аналитического выражения) без линеаризации
   граничных условий (ГУ) и предположении о малости амплитуд волн.
4. Наконец, верифицировать интегральные характеристики взволнованной поверхности
   на соответствие реальным морским волнам.
5. Заключительный этап состоял в разработке комплекса программ, реализующего
   созданную модель и метод расчета давлений и позволяющего проводить расчеты
   как на многопроцессорной машине с общей памятью (SMP), так и на компьютерном
   кластере (MPP).

**** Научная новизна.
Модель АРСС в отличие от других моделей ветрового волнения не основана на
линейной теории волн, что позволяет
- генерировать волны произвольной амплитуды, регулируя крутизну посредством АКФ;
- генерировать волны произвольной формы, регулируя асимметричность распределения
  волновых аппликат посредством нелинейного безынерционного преобразования
  (НБП).
В то же время математический аппарат этой процесса АРСС хорошо изучен в
других научных областях, что позволяет его обобщить для моделирования развития
морского волнения в условиях шторма с учетом климатических спектров и данных
ассимиляции определенных районов мирового океана, что невозможно сделать с
помощью модели, основанной на линейной теории волн.

**** Теоретическая и практическая значимость работы.
Применение модели АРСС и формулы поля давлений, не использующей предположения
линейной теории волн, качественно повысит работу комплексов программ для расчета
воздействия океанских волн на морские объекты.

1. Поскольку формула для поля давлений выводится для дискретно заданной
   взволнованной поверхности и без каких-либо предположений об амплитудах волн,
   то она применима для любой взволнованной поверхности невязкой несжимаемой
   жидкости (в частности она применима для поверхности, генерируемой моделью
   Лонге---Хиггинса). Это позволяет использовать формулу поля давлений без
   привязки к модели АРСС.
2. С вычислительной точки зрения эта формула более эффективна, чем
   соответствующая формула для модели ЛХ, поскольку интегралы в формуле сводятся
   к преобразованиям Фурье, для которых существует семейство алгоритмов быстрого
   преобразования Фурье (БПФ), оптимизированных под разные архитектуры
   процессоров.
3. Поскольку формула явная, то обмена данными между параллельными процессами
   можно избежать, что позволяет достичь высокой масштабируемости на
   компьютерном кластере.
4. Наконец, сама модель АРСС более эффективна, чем модель ЛХ, ввиду отсутствия
   тригонометрических функций в ее формуле. Взволнованная поверхность
   вычисляется как сумма большого числа многочленов, для которых существует
   низкоуровневая ассемблерная инструкция (Fused Multiply-Add), показывающая
   высокую производительность на процессорах.

**** Методология и методы исследования.
Программная реализация модели АРСС и формула вычисления давлений создавалась
поэтапно: прототип, написанный высокойровневом инженерном языке
cite:mathematica10,octave2015, был преобразован в программу на языке более
низкого уровня (C++). Реализация одних и тех же формул и алгоритмов на языках
разного уровня (ввиду использования различных абстракций и языковых примитивов)
позволяет выявить и исправить ошибки, которые остались бы незамеченными в случае
одного языка. Генерируемая моделью АРСС взволнованная поверхность, а также все
входные параметры (АКФ, формула распределения волновых аппликат и т.п.) были
проверены с помощью встроенных в язык программирования графических средств для
визуального контроля корректности работы программы.

**** Положения, выносимые на защиту.
- Модель ветрового волнения, способная генерировать реализации взволнованной
  морской поверхности, имеющие большой период и состоящие из волн произвольной
  амплитуды;
- Формула для поля давлений, выведенная для этой модели без предположений
  линейной теории волн;
- Программная реализация созданной модели и формулы для вычислительных систем с
  общей (SMP) и с распределенной памятью (MPP).

**** Степень достоверности и апробация результатов.
Верификация модели АРСС проводится путем сравнения интегральных характеристик
(распределений волновых аппликат, высот и длин волн и т.п.) генерируемой
взволнованной поверхности с характеристиками реальных морских волн. Формула для
поля давлений выводится с помощью языка Mathematica, в котором полученные
выражения проверяются с помощью встроенных в язык графических средств.

Модель АРСС и формула для поля давлений были реализованы в Large Amplitude
Motion Programme (LAMP), программе для моделирования качки судна, и сопоставлены
с используемой ранее моделью ЛХ. Предварительные численные эксперименты показали
более высокую вычислительную эффективность модели АРСС.

* Постановка задачи
Задача состоит в исследовании возможности применении математического аппарата
процесса АРСС для моделирования морских волн и в выводе формулы для поля
давлений под генерируемой взволнованной морской поверхностью для случая
идеальной несжимаемой жидкости без предположений линейной теории волн.
- Для случая волн малых амплитуд полученная формула должна быть сопоставимо с
  соответствующей формулой линейной теории волн; для остальных случаев формула
  не должна расходиться.
- Интегральные характеристики генерируемой взволнованной поверхности должны
  совпадать с характеристиками реальных морских волн.
- Программная реализация модели АРСС и формулы вычисления давлений должна
  работать на системах с общей (SMP) и распределенной памятью (MPP).

**** Формула для поля давлений.
Задача определения поля давлений под взволнованной морской поверхностью
представляет собой обратную задачу гидродинамики для несжимаемой невязкой
жидкости. Система уравнений для нее в общем виде записывается как
cite:kochin1966theoretical
\begin{align}
    & \nabla^2\phi = 0,\nonumber\\
    & \phi_t+\frac{1}{2} |\vec{\upsilon}|^2 + g\zeta=-\frac{p}{\rho}, & \text{на }z=\zeta(x,y,t),\label{eq:problem}\\
    & D\zeta = \nabla \phi \cdot \vec{n}, & \text{на }z=\zeta(x,y,t),\nonumber
\end{align}
где $\phi$ --- потенциал скорости, $\zeta$ --- подъем (аппликата) взволнованной
поверхности, $p$ --- давление жидкости, $\rho$ --- плотность жидкости,
$\vec{\upsilon} = (\phi_x, \phi_y, \phi_z)$ --- вектор скорости, $g$ ---
ускорение свободного падения и $D$ --- субстанциональная производная
(производная Лагранжа). Первое уравнение является уравнением неразрывности
(уравнение Лапласа), второе --- законом сохранения импульса (которое иногда
называют динамическим граничным условием); третье уравнение --- кинематическое
граничное условие, которое сводится к равенству скорости перемещения этой
поверхности ($D\zeta$) нормальной составляющей скорости жидкости ($\nabla \phi
\cdot \vec{n}$).

Обратная задача гидродинамики заключается в решении этой системы уравнений
относительно $\phi$. В такой постановке динамическое ГУ становится явной
формулой для определения поля давлений по значениям производных потенциалов
скорости, полученных из оставшихся уравнений. Таким образом, с математической
точки зрения обратная задача гидродинамики сводится к решению уравнения Лапласа
со смешанным ГУ --- задаче Робена.

* Обзор литературы
** Анализ моделей морского волнения
Вычисление давлений возможно только при условии знания формы взволнованной
поверхности, которая задается либо дискретно в каждой точке пространственной
сетки, либо непрерывно с помощью аналитической формулы. Как будет показано в
разделе [[#linearisation]], знание такой формулы может упростить вычисление
давлений, фактически сведя задачу к генерации поля давлений, а не самой
взволнованной поверхности.

*** Модель Лонге---Хиггинса
Наиболее простой моделью, формула которой выводится в рамках линейной теории
волн, является модель Лонге---Хиггинса (ЛХ) cite:longuet1957statistical.
Подробный сравнительный анализ этой модели и модели АРСС проведен в работах
cite:degtyarev2011modelling,boukhanovsky1997thesis.

Модель ЛХ представляет взволнованную морскую поверхность в виде суперпозиции
элементарных гармонических волн случайных амплитуд $c_n$ и фаз $\epsilon_n$,
непрерывно распределенных на интервале $[0,2\pi]$. Подъем (координата $z$)
поверхности определяется формулой
#+name: eq:longuet-higgins
\begin{equation}
    \zeta(x,y,t) = \sum\limits_n c_n \cos(u_n x + v_n y - \omega_n t + \epsilon_n).
\end{equation}
Здесь волновые числа $(u_n,v_n)$ непрерывно распределены на плоскости $(u,v)$,
т.е. площадка $du \times dv$ содержит бесконечно большое количество волновых
чисел. Частота связана с волновыми числами дисперсионным соотношением
$\omega_n=\omega(u_n,v_n)$. Функция $\zeta(x,y,t)$ является трехмерным
эргодическим стационарным однородным гауссовым процессом, определяемым
соотношением
\begin{equation*}
    2E_\zeta(u,v)\, du\,  dv = \sum\limits_n c_n^2,
\end{equation*}
где $E_\zeta(u,v)$ --- двумерная спектральная плотность энергии волн.
Коэффициенты $c_n$ определяются из энергетического спектра волнения $S(\omega)$
по формуле
\begin{equation*}
    c_n = \sqrt{ \textstyle\int\limits_{\omega_n}^{\omega_{n+1}} S(\omega) d\omega}.
\end{equation*}

*** Основные недостатки модели Лонге---Хиггинса
Модель Лонге---Хиггинса отличается простотой численного алгоритма и
наглядностью, однако, на практике она обладает рядом недостатков.

1. Модель рассчитана на представление стационарного гауссова поля. Это является
   следствием центральной предельной теоремы (ЦПТ): сумма большого числа
   гармоник со случайными амплитудами и фазами имеет нормальное распределение в
   независимости от спектра, подаваемого на вход модели. Использование меньшего
   количества коэффициентов может решить проблему, но также уменьшит период
   реализации. Таким образом, использование модели ЛХ для генерации волн с
   негауссовым распределением аппликат (которое имеют реальные морские волны
   cite:huang1980experimental,рожков1996теория) не реализуемо на практике.
2. С вычислительной точки зрения, недостатком модели является нелинейный рост
   времени генерации поверхности с увеличением размера реализации. Чем больше
   размер реализации, тем больше коэффициентов (дискретных точек
   частотно-направленного спектра) требуется для исключения периодичности. Это
   делает модель неэффективной для проведения длительных численных
   экспериментов.
3. Наконец, с инженерной точки зрения, модель обладает рядом особенностей,
   которые не позволяют использовать ее в качестве фундамента для построения
   более совершенных моделей.
   - В программной реализации скорость сходимости выражения ([[eq:longuet-higgins]])
     может быть низкой, т.к. фазы $\epsilon_n$ имеют вероятностный характер.
   - Обобщение модели для негауссовых и нелинейных процессов сопряжено с большой
     трудоемкостью вычислений cite:рожков1990вероятностные.
 
Таким образом, модель Лонге---Хиггинса применима для решения задачи генерации
взволнованной морской поверхности только в линейной постановке (в рамках теории
волн малой амплитуды), неэффективна для длительных экспериментов и имеет ряд
недостатков, не позволяющих использовать ее в качестве основы для построения
более совершенных моделей.

*** Модель АРСС
В cite:spanos1982arma модель АРСС используется для генерации временного ряда,
спектр которого совпадает с аппроксимацией Пирсона---Московица для спектров
морского волнения. Авторы проводят эксперименты для одномерных моделей АР, СС и
АРСС. Они отмечают превосходное совпадение полученного и исходного спектров и
более высокую вычислительную эффективность модели АРСС по сравнению с
моделями, основанными на суммировании большого числа гармоник со случайными
фазами. Также отмечается, что для того чтобы спектр полученного временного ряда
совпадал с заданным, модели СС требуется меньшее количество коэффициентов, чем
модели АР. В cite:spanos1996efficient автор обобщает формулы для нахождения
коэффициентов модели АРСС для случая нескольких (векторов) переменных.

Отличие данной работы от вышеперечисленных отличается в исследовании трехмерной
модели АРСС (два пространственных и одно временное измерение), что во многом
является другой задачей.
1. Система уравнений Юла---Уокера, используемая для определения коэффициентов
   АР, имеет более сложную блочно-блочную структуру.
2. Оптимальный (для совпадения заданного и исходного спектров) порядок модели
   определяется вручную.
3. Вместо аппроксимации ПМ в качестве входа модели используются аналитические
   выражения для АКФ стоячих и прогрессивных волн.
4. Трехмерная взволнованная поверхность должна быть сопоставима с реальной
   морской поверхностью не только по спектральным характеристикам, но и по форме
   волновых профилей, поэтому верификация модели производится и для
   распределений различных параметров генерируемых волн (длин, высот, периодов и
   др.).
Многомерность исследуемой модели не только усложняет задачу, но и позволяет
провести визуальную проверку генерируемой взволнованной поверхности. Именно
возможность визуализировать результат работы программы позволила удостовериться,
что генерируемая поверхность действительно похожа на реальное морское волнение,
а не является абстрактным многомерным случайным процессом, совпадающим с
реальным лишь статистически.

В cite:fusco2010short модель АР используется для прогнозирования волн зыби для
управления преобразователем энергии волн (ПЭВ) в реальном времени. Для
эффективной работы ПЭВ необходимо чтобы частота встроенного осциллятора
совпадала с частотой морских волн. Авторы статьи представляют подъем волны как
временной ряд и сравнивают эффективность модели АР, нейронных сеть и циклических
моделей в прогнозировании будущих значения ряда. Модель АР дает наиболее точный
прогноз для низкочастотных волн зыби вплоть до двух типовых периодов волн. Это
пример успешного применения модели процесса АР для моделирования морских волн.

** Известные формулы определения поля давлений
*** Теория волн малых амплитуд
В cite:stab2012,детярев1998моделирование,degtyarev1997analysis дается решение
обратной задачи гидродинамики для случая идеальной несжимаемой жидкости в рамках
теории волн малых амплитуд (в предположении, что длина волны много больше ее
высоты: $\lambda \gg h$). В этом случае обратная задача линейна и сводится к
уравнению Лапласа со смешанным граничным условием, а уравнение движения
используется только для нахождения давлений по известным значениям производных
потенциала скорости. Предположение о малости амплитуд волн означает слабое
изменение локального волнового числа во времени и пространстве по сравнению с
подъемом (аппликатой) взволнованной поверхности. Это позволяет вычислить
производную подъема поверхности по $z$ как $\zeta_z=k\zeta$, где $k$ ---
волновое число. В двухмерном случае решение записывается явной формулой
\begin{align}
    \left.\frac{\partial\phi}{\partial x}\right|_{x,t}= &
        -\frac{1}{\sqrt{1+\alpha^{2}}}e^{-I(x)}
            \int\limits_{0}^x\frac{\partial\dot{\zeta}/\partial      
                z+\alpha\dot{\alpha}}{\sqrt{1+\alpha^{2}}}e^{I(x)}dx,\label{eq:old-sol-2d}\\
    I(x)= & \int\limits_{0}^x\frac{\partial\alpha/\partial z}{1+\alpha^{2}}dx,\nonumber
\end{align}
где $\alpha$ --- уклоны волн. В трехмерном случае решение записывается в виде
эллиптического дифференциального уравнения в частных производных
\begin{align*}
    & \frac{\partial^2 \phi}{\partial x^2} \left( 1 + \alpha_x^2 \right) +
    \frac{\partial^2 \phi}{\partial y^2} \left( 1 + \alpha_y^2 \right) +
    2\alpha_x\alpha_y \frac{\partial^2 \phi}{\partial x \partial y} + \\
    & \left(
        \frac{\partial \alpha_x}{\partial z} +
        \alpha_x \frac{\partial \alpha_x}{\partial x} +
        \alpha_y \frac{\partial \alpha_x}{\partial y}
    \right) \frac{\partial \phi}{\partial x} + \\
    & \left(
        \frac{\partial \alpha_y}{\partial z} +
        \alpha_x \frac{\partial \alpha_y}{\partial x} +
        \alpha_y \frac{\partial \alpha_y}{\partial y}
    \right) \frac{\partial \phi}{\partial y} + \\
    & \frac{\partial \dot{\zeta}}{\partial z} + 
    \alpha_x \dot{\alpha_x} + \alpha_y \dot{\alpha_y} = 0.
\end{align*}
Уравнение предполагается решать численно путем сведения к разностному.

Как будет показано в [[#sec:compare-formulae]] формула eqref:eq:old-sol-2d
расходится при попытке вычислить поле скоростей для волн больших амплитуд, а
значит не может быть использована вместе с моделью ветрового волнения,
генерирующей волны произвольных амплитуд.

*** Линеаризация граничного условия
:PROPERTIES:
:CUSTOM_ID: linearisation
:END:
Модель Лонге---Хиггинса позволяет вывести явную формулу для поля
скоростей путем линеаризации кинематического граничного условия. Формула для
потенциала скорости запишется как
\begin{equation*}
\phi(x,y,z,t) = \sum_n \frac{c_n g}{\omega_n} 
     e^{\sqrt{u_n^2+v_n^2} z}
     \sin(u_n x + v_n y - \omega_n t + \epsilon_n).
\end{equation*}
Формула дифференцируется для получения производных потенциала, а полученные
значения подставляются в динамическое граничное условие для вычисления давлений.

* Модель АРСС в задаче имитационного моделирования морского волнения
** Основные формулы трехмерного процесса AРСС
*** Три возможных процесса
Модель АРСС для морского волнения определяет взволнованную морскую поверхность
как трехмерный (два пространственных и одно временное измерение) процесс
авторегрессии скользящего среднего: каждая точка взволнованной поверхности
представляется в виде взвешенной суммы предыдущих по времени и пространству
точек и взвешенной суммы предыдущих по времени и пространству нормально
распределенных случайных импульсов. Основным уравнением для трехмерного процесса
АРСС является
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j} \zeta_{\vec i - \vec j}
    +
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j} \epsilon_{\vec i - \vec j}
    ,
    \label{eq:arma-process}
\end{equation}
где $\zeta$ --- подъем (аппликата) взволнованной поверхности, $\Phi$ ---
коэффициенты процесса АР, $\Theta$ --- коэффициенты процесса СС, $\epsilon$ ---
белый шум, имеющий Гауссово распределение, $\vec N$ --- порядок процесса АР,
$\vec M$ --- порядок процесса СС, причем $\Phi_{\vec{0}}\equiv0$,
$\Theta_{\vec{0}}\equiv0$. Здесь стрелки обозначают многокомпонентные индексы,
содержащие отдельную компоненту для каждого измерения. В общем случае в качестве
компонент могут выступать любые скалярные величины (температура, соленость,
концентрация какого-либо раствора в воде и т.п.). Параметрами уравнения служат
коэффициенты и порядки процессов АР и СС.

**** Процесс авторегрессии (АР).
Процесс АР --- это процесс АРСС только лишь с одним случайным импульсом вместо их
взвешенной суммы:
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j} \zeta_{\vec i - \vec j}
    +
    \epsilon_{i,j,k}
    .
    \label{eq:ar-process}
\end{equation}
Коэффициенты авторегрессии $\Phi$ определяются из многомерных уравнений
Юла---Уокера, получаемых после домножения на $\zeta_{\vec{i}-\vec{k}}$ обеих
частей уравнения и взятия математического ожидания. В общем виде уравнения
Юла---Уокера записываются как
\begin{equation}
    \label{eq:yule-walker}
    \gamma_{\vec k}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j}
    \text{ }\gamma_{\vec{k}-\vec{j}}
    +
    \Var{\epsilon} \delta_{\vec{k}},
    \qquad
    \delta_{\vec{k}} =
    \begin{cases}
        1, \quad \text{if } \vec{k}=0 \\
        0, \quad \text{if } \vec{k}\neq0,
    \end{cases}
\end{equation}
где $\gamma$ --- АКФ процесса $\zeta$, $\Var{\epsilon}$ --- дисперсия
белого шума. Матричная форма трехмерной системы уравнений Юла---Уокера,
используемой в данной работе, имеет следующий вид.
\begin{equation*}
    \Gamma
    \left[
        \begin{array}{l}
            \Phi_{\vec 0}\\
            \Phi_{0,0,1}\\
            \vdotswithin{\Phi_{\vec 0}}\\
            \Phi_{\vec N}
        \end{array}
    \right]
    =
    \left[
        \begin{array}{l}
            \gamma_{0,0,0}-\Var{\epsilon}\\
            \gamma_{0,0,1}\\
            \vdotswithin{\gamma_{\vec 0}}\\
            \gamma_{\vec N}
        \end{array}
    \right],
    \qquad
    \Gamma=
    \left[
        \begin{array}{llll}
            \Gamma_0 & \Gamma_1 & \cdots & \Gamma_{N_1} \\
            \Gamma_1 & \Gamma_0 & \ddots & \vdotswithin{\Gamma_0} \\
            \vdotswithin{\Gamma_0} & \ddots & \ddots & \Gamma_1 \\
            \Gamma_{N_1} & \cdots & \Gamma_1 & \Gamma_0
        \end{array}
    \right],
\end{equation*}
где $\vec N = \left( N_1, N_2, N_3 \right)$ и
\begin{equation*}
    \Gamma_i =
    \left[
    \begin{array}{llll}
        \Gamma^0_i & \Gamma^1_i & \cdots & \Gamma^{N_2}_i \\
        \Gamma^1_i & \Gamma^0_i & \ddots & \vdotswithin{\Gamma^0_i} \\
        \vdotswithin{\Gamma^0_i} & \ddots & \ddots & \Gamma^1_i \\
        \Gamma^{N_2}_i & \cdots & \Gamma^1_i & \Gamma^0_i
    \end{array}
    \right]
    \qquad
    \Gamma_i^j=
    \left[
    \begin{array}{llll}
        \gamma_{i,j,0} & \gamma_{i,j,1} & \cdots & \gamma_{i,j,N_3} \\
        \gamma_{i,j,1} & \gamma_{i,j,0} & \ddots &x \vdotswithin{\gamma_{i,j,0}} \\
        \vdotswithin{\gamma_{i,j,0}} & \ddots & \ddots & \gamma_{i,j,1} \\
        \gamma_{i,j,N_3} & \cdots & \gamma_{i,j,1} & \gamma_{i,j,0}
    \end{array}
    \right],
\end{equation*}
Поскольку по определению $\Phi_{\vec 0}\equiv0$, то первую строку и столбец
матрицы $\Gamma$ можно отбросить. Матрица $\Gamma$, как и оставшаяся от нее
матрица, будут блочно-теплицевы, положительно определены и симметричны, поэтому
систему уравнений Юла---Уокера можно эффективно решить методом Холецкого,
специально предназначенного для таких матриц.

После нахождения решения системы уравнений дисперсия белого шума определяется из
уравнения eqref:eq:yule-walker при $\vec k = \vec 0$ как
\begin{equation*}
    \Var{\epsilon} =
    \Var{\zeta}
    -
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j}
    \text{ }\gamma_{\vec{j}}.
\end{equation*}

**** Процесс скользящего среднего (СС).
Процесс СС --- это процесс АРСС, в котором $\Phi\equiv0$:
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j} \epsilon_{\vec i - \vec j}
    .
    \label{eq:ma-process}
\end{equation}
Коэффициенты СС $\Theta$ определяются неявно из системы нелинейных уравнений
\begin{equation*}
  \gamma_{\vec i} =
  \left[
    \displaystyle
    \sum\limits_{\vec j = \vec i}^{\vec M}
    \Theta_{\vec j}\Theta_{\vec j - \vec i}
  \right]
  \Var{\epsilon}.
\end{equation*}
Система решается численно с помощью метода простой итерации по формуле
\begin{equation*}
  \Theta_{\vec i} =
    -\frac{\gamma_{\vec 0}}{\Var{\epsilon}}
    +
    \sum\limits_{\vec j = \vec i}^{\vec M}
    \Theta_{\vec j} \Theta_{\vec j - \vec i}.
\end{equation*}
Здесь новые значения коэффициентов $\Theta$ вычисляются, начиная с последнего:
от $\vec{i}=\vec{M}$ до $\vec{i}=\vec{0}$. Дисперсия белого шума вычисляется из
\begin{equation*}
    \Var{\epsilon} = \frac{\gamma_{\vec 0}}{
    1
    +
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j}^2
    }.
\end{equation*}
Авторы cite:box1976time предлагают использовать метод Ньютона---Рафсона для
решения этого уравнения с большей точностью, однако, этот метод не подходит для
трех измерений. Использование более медленного метода не оказывает большого
эффекта на общую производительность программы, потому что количество
коэффициентов мало, и большую часть времени программа тратит на генерацию
взволнованной поверхности.

**** TODO Стационарность и обратимость процессов АР и СС
**** Смешанный процесс авторегрессии скользящего среднего (АРСС).
:PROPERTIES:
:CUSTOM_ID: sec:how-to-mix-ARMA
:END:
В общем и целом, процесс АРСС получается путем подстановки сгенерированной
процессом СС взволнованной поверхности в качестве случайного импульса процесса
АР, однако, для того чтобы АКФ результирующего процесса соответствовала
заданной, необходимо предварительно скорректировать значения коэффициентов АР.
Существует несколько способов "смешивания" процессов АР и СС.
- Подход, предложенный авторами cite:box1976time, который включается в себя
  разделение АКФ на часть для процесса АР и часть для процесса СС по каждому из
  измерений, не подходит в данной ситуации, поскольку в трех измерениях
  невозможно таким образом разделить АКФ: всегда останутся части, которые не
  будут учтены ни в процессе АР, ни в процессе СС.
- Альтернативный подход состоит в использование одной и той же (неразделенной)
  АКФ для обоих процессов разных порядков, однако, тогда характеристики
  реализации (математической ожидание, дисперсия и др.) будут смещены: они
  станут характеристика двух наложенных друг на друга процессов.
Для первого подхода авторами cite:box1976time предложена формула корректировки
коэффициентов процесса АР, для второго же подхода такой формулы нет. Таким
образом, лучшим решением на данный момент является использование процессов АР и
СС по отдельности.

*** Критерии выбора процесса для моделирования разных профилей волн
Одной из проблем в применении модели АРСС для генерации взволнованной морской
поверхности является то, что для разных профилей волн /необходимо/ использовать
разные процессы: стоячие волны моделируются только процессом АР, а прогрессивные
волны --- только процессом СС. Это утверждение пришло из практики: если
попытаться использовать процессы наоборот, результирующая реализация либо
расходится, либо не представляет собой реальные морские волны (такое происходит
в случае необратимого процесса СС, который всегда стационарен). Таким образом,
процесс АР может быть использован только для моделирования стоячих волн, а
процесс СС --- для прогрессивных волн.

Другой проблемой является невозможность автоматического определения оптимального
количества коэффициентов для трехмерных процессов АР и СС. Для одномерных
процессов существуют итеративные методы cite:box1976time, однако они расходятся
в трехмерном случае.

Последней проблемой, которая описана в разделе [[#sec:how-to-mix-ARMA]], является
невозможность "смешать" процесс АР и СС в трех измерениях.

Практика показывает, что некоторые утверждения авторов cite:box1976time не
выполняются для трехмерной модели АРСС. Например, авторы утверждают, что АКФ
процесса СС обрывается на отсчете $q$, а АКФ процесса АР затухает на
бесконечности, однако, на практике при использовании слабо затухающей и
обрывающейся на отсчете $q$ АКФ для трехмерного процесса СС получается
необратимый процесс СС и реализация, не соответствующая реальными морским
волнам, в то время как при использовании той же самой АКФ для трехмерного
процесса АР получается стационарный обратимый процесс и адекватная реализация.
Также, авторы утверждают, что первые $q$ точек АКФ смешанного процесса
необходимо выделить процессу СС (поскольку он обычно используется для описания
пиков АКФ) и отдать остальные точки процессу АР, однако, на практике в случае
АКФ прогрессивной волны процесс АР стационарен только для начального временного
среза АКФ, а остальные точки отдаются процессу СС.

Суммируя вышесказанное, наиболее разработанным сценарием применения модели АРСС
для генерации взволнованной морской поверхности является использование процесса
АР для стоячих волн и процесса СС для прогрессивных волн. Смешанный процесс АРСС
может сделать модель более точной при условии наличия соответствующих формул
пересчета коэффициентов, что является целью дальнейших исследований.

** Моделирование нелинейности морских волн
Модель АРСС позволяет учесть асимметричность распределения волновых аппликат,
т.е. генерировать морские волны, закон распределения аппликат которых имеет
ненулевой эксцесс и асимметрию. Такой закон распределения характерен для реальных
морских волн cite:longuet1963nonlinear.

Асимметричность волн моделируется с помощью нелинейного безынерционного
преобразования (НБП) случайного процесса, однако, любое нелинейное
преобразование случайного процесса приводит к преобразованию его АКФ. Для того
чтобы подавить этот эффект, необходимо предварительно преобразовать АКФ, как
показано в cite:boukhanovsky1997thesis.

**** Преобразование взволнованной поверхности.
Формула $z=f(y)$ преобразования взволнованной поверхности к необходимому
одномерному закону распределения $F(z)$ получается путем решения нелинейного
трансцендентного уравнения $F(z) = \Phi(y)$, где $\Phi(y)$ --- функция
одномерного нормального закона распределения. Поскольку функция распределения
аппликат морских волн часто задается некоторой аппроксимацией, основанной на
натурных данных, то это уравнение целесообразно решать численно в каждой точке
$y_k|_{k=0}^N$ сетки сгенерированной поверхности относительно $z_k$. Тогда
уравнение запишется в виде
\begin{equation}
    \label{eq:distribution-transformation}
    F(z_k)
    =
    \frac{1}{\sqrt{2\pi}}
    \int\limits_0^{y_k} \exp\left[ -\frac{t^2}{2} \right] dt
    .
\end{equation}
Поскольку функции распределения монотонны, для решения этого уравнения
используется простейший численный метод половинного деления (метод бисекции).

**** Предварительное преобразование АКФ.
Для преобразования АКФ $\gamma_z$ процесса ее необходимо разложить в ряд по
полиномам Эрмита (ряд Грама---Шарлье)
\begin{equation*}
    \gamma_z \left( \vec u \right)
    =
    \sum\limits_{m=0}^{\infty}
    C_m^2 \frac{\gamma_y^m \left( \vec u \right)}{m!},
\end{equation*}
где
\begin{equation*}
    C_m = \frac{1}{\sqrt{2\pi}}
  \int\limits_{0}^\infty
    f(y) H_m(y) \exp\left[ -\frac{y^2}{2} \right],
\end{equation*}
$H_m$ --- полином Эрмита, а $f(y)$ --- решение уравнения
eqref:eq:distribution-transformation. Воспользовавшись полиномиальной
аппроксимацией $f(y) \approx \sum\limits_i d_i y^i$ и аналитическими выражениями
для полнимов Эрмита, формулу определения коэффициентов можно упростить,
используя следующее равенство:
\begin{equation*}
    \frac{1}{\sqrt{2\pi}}
    \int\limits_\infty^\infty
    y^k \exp\left[ -\frac{y^2}{2} \right]
    =
    \begin{cases}
        (k-1)!! & \text{для четных }k,\\
        0       & \text{для нечетных }k.
    \end{cases}
\end{equation*}
Оптимальное количество коэффициентов $C_m$ определяется путем вычисления их
последовательно и критерий прекращения счета определяется совпадением дисперсий
обоих полей с требуемой точностью $\epsilon$:
\begin{equation*}
    \left| \Var{z} - \sum\limits_{k=0}^m
    \frac{C_k^2}{k!} \right| \leq \epsilon.
\end{equation*}

В cite:boukhanovsky1997thesis автор предлагает использовать полиномиальную
аппроксимацию для $f(y)$ также для преобразования поверхности, однако на
практике в реализации взволнованной поверхности часто находятся точки,
выпадающие за промежуток на котором построена аппроксимация, что приводит к
резкому уменьшению ее точности. В этих точках уравнение
eqref:eq:distribution-transformation эффективнее решать методом бисекции.
Использование полиномиальной аппроксимации в формулах для коэффициентов ряда
Грама---Шарлье не приводит к аналогичным ошибкам.

** Определение поля давлений под дискретно заданной взволнованной поверхностью
Аналитические решения граничных задач для классических уравнений часто
используются для исследования различных свойств уравнений, и для таких
исследований запись формулы общего решения неудобна ввиду своей сложности и
наличия интегралов от неизвестных функций. Одним из методов нахождения
аналитических решений ДУЧП является метод Фурье. Основой метода служит
преобразование Фурье, применение которого к любому ДУЧП позволяет свести его к
алгебраическому, а его решение записывается как обратное преобразование Фурье от
некоторой функции (которая может содержать преобразования Фурье от других
функций). Поскольку эти преобразования не всегда можно записать аналитически, то
вместо этого ищутся частные решения задачи и анализируется их поведение в
различных областях. В то же время, вычисление дискретных преобразований Фурье на
компьютере возможно для любой дискретно заданной функции и эффективно при
использовании алгоритмов БПФ. Эти алгоритмы используют симметрию комплексных
экспонент для понижения асимптотической сложности с $\mathcal{O}(n^2)$ до
$\mathcal{O}(n\log_{2}n)$. Таким образом, даже если общее решение содержит
преобразования Фурье от неизвестных функций, они все равно могут быть взяты
численно, а использование алгоритмов БПФ делает этот подход эффективным.

Альтернативным подходом является сведение их к разностным уравнениям, решаемым с
помощью построения различных численных схем. При этом решение получается
приближенным, а асимптотическая сложность соответствующих алгоритмов сопоставима
со сложностью алгоритма БПФ. Например, стационарное эллиптическое уравнение в
частных производных преобразуется в неявную разностную схему, решаемую
итерационным методом, на каждом шаге которого ищется решение трехдиагональной
или пятидиагональной СЛАУ методом прогонки (алгоритм Томаса). Асимптотическая
сложность алгоритма составляет $\mathcal{O}({n}{m})$, где $n$ --- количество
точек на сетке взволнованной поверхности, $m$ --- число итераций. Несмотря на
широкое распространение, итеративные алгоритмы неэффективно отображаются на
архитектуру параллельных машин; в частности, отображение на сопроцессоры может
включать в себя копирование данных на сопроцессор и обратно на каждой итерации,
что отрицательно сказывается на их производительности. В то же время, наличие
большого количества преобразований Фурье в решении является скорее
преимуществом, чем недостатком. Во-первых, решения, полученные с помощью метода
Фурье, явные, а значит хорошо масштабируются на большое количество параллельно
работающих вычислительных ядер с использованием простейших приемов параллельного
программирования. Во-вторых, для алгоритмов БПФ существуют готовые
оптимизированные реализация для различных архитектур процессоров и сопроцессоров
(GPU, MIC). Эти преимущества обусловили выбор метода Фурье в качестве рабочего
для получения явного аналитического решения задачи определения давлений под
взволнованной морской поверхностью.

*** Двухмерное поле скоростей
:PROPERTIES:
:CUSTOM_ID: sec:pressure-2d
:END:
**** Формула для жидкости бесконечной глубины.
Задача Робена для уравнения Лапласа в двух измерениях записывается как
\begin{align}
    \label{eq:problem-2d}
    & \phi_{xx}+\phi_{zz}=0,\\
    & \zeta_t + \zeta_x\phi_x = \frac{\zeta_x}{\sqrt{1 + \zeta_x^2}} \phi_x - \phi_z, & \text{на }z=\zeta(x,t).\nonumber
\end{align}
Для ее решения воспользуемся методом Фурье. Возьмем преобразование Фурье от
обоих частей уравнений Лапласа и получим
\begin{equation*}
    -4 \pi^2 \left( u^2 + v^2 \right)
    \FourierY{\phi(x,z)}{u,v} = 0,
\end{equation*}
откуда имеем $v = \pm i u$. Здесь и далее будет использоваться следующая
симметричная форма преобразования Фурье:
\begin{equation*}
    \FourierY{f(x,y)}{u,v} =
    \iint\limits_{-\infty}^{\phantom{--}\infty}
    f(x,y)
    e^{-2\pi i (x u + y v)}
    dx dy.
\end{equation*}
Решение уравнения будем искать в виде обратного преобразования Фурье
$\phi(x,z)=\InverseFourierY{E(u,v)}{x,z}$. Подставляя[fn::Выражение $v={-i}{u}$
не подходит в данной задаче, поскольку потенциал скорости должен стремиться к
нулю с увеличением глубины до бесконечности.} $v={i}{u}$ в формулу, решение
перепишется как
\begin{equation}
    \label{eq:guessed-sol-2d}
    \phi(x,z) = \InverseFourierY{e^{2\pi u z}E(u)}{x}.
\end{equation}
Для того чтобы подстановка $z=\zeta(x,t)$ не помешала использованию
преобразований Фурье в решении, перепишем eqref:eq:guessed-sol-2d в виде
свертки:
\begin{equation*}
    \phi(x,z)
    =
    \Fun{z}
    \ast
    \InverseFourierY{E(u)}{x},
\end{equation*}
где $\Fun{z}$ --- некоторая функция, вид которой будет определен в
[[#sec:compute-delta]] и для которой выполняется соотношение
$\FourierY{\Fun{z}}{u}=e^{2\pi{u}{z}}$. Подставляя выражение для $\phi$ в
граничное условие, получим
\begin{equation*}
    \zeta_t
    =
    \left( i f(x) - 1 \right)
    \left[
        \Fun{z}
        \ast
        \InverseFourierY{2\pi u E(u)}{x}
    \right],
\end{equation*}
где $f(x) = {\zeta_x}/{\sqrt{1 + \zeta_x^2}} - \zeta_x$. Применяя преобразование
Фурье к обеим частям, получаем выражение для коэффициентов $E$:
\begin{equation*}
    E(u) =
    \frac{1}{2\pi u}
    \frac{
    \FourierY{\zeta_t / \left(i f(x) - 1\right)}{u}
    }{
    \FourierY{\Fun{z}}{u}
    }
\end{equation*}
Выполняя подстановку $z=\zeta(x,t)$ и подставляя полученное выражение в
eqref:eq:guessed-sol-2d, получаем окончательное выражение для $\phi(x,z)$:
\begin{equation}
    \label{eq:solution-2d}
    \boxed{
        \phi(x,z)
        =
        \InverseFourierY{
            \frac{e^{2\pi u z}}{2\pi u}
            \frac{
            \FourierY{ \zeta_t / \left(i f(x) - 1\right) }{u}
            }{
            \FourierY{ \Fun{\zeta(x,t)} }{u}
            }
        }{x}.
    }
\end{equation}

Множитель $e^{2\pi u z}/(2\pi u)$ делает график функции от которой берется
обратное преобразования Фурье несимметричным относительно оси $OY$. Это
затрудняет применение БПФ, поскольку оно требует периодичную функцию, которая на
концах промежутка принимает нулевое значение. Использование численного
интегрирования вместо БПФ не позволит получить преимущество над решением всей
системы уравнений с помощью разностных схем. Эту проблему можно обойти,
используя формулу eqref:eq:solution-2d-full для жидкости конечной глубины с
заведомо большим значением глубины водоема $h$. Вывод формулы дан в следующем
разделе.

**** Формула для жидкости конечной глубины.
На дне водоема вертикальная составляющая скорости перемещения жидкости должна
равняться нулю, т.е. $\phi_z=0$ на $z=-h$, где $h$ --- глубина водоема. В этом
случае пренебречь равенством $v = -i u$, полученным из уравнения Лапласа,
нельзя, и решение ищется в виде
\begin{equation}
    \phi(x,z)
    =
    \InverseFourierY{
        \left( C_1 e^{2\pi u z} + C_2 e^{-2\pi u z} \right)
        E(u)
    }{x}.
    \label{eq:guessed-sol-2d-full}
\end{equation}
Подставляя $\phi$ в условие на дне водоема, получим
\begin{equation*}
    C_1 e^{-2\pi u h} - C_2 e^{2\pi u h} = 0,
\end{equation*}
откуда имеем $C_1=\frac{1}{2}C{e}^{2\pi{u}{h}}$ и
$C_2=-\frac{1}{2}C{e}^{-2\pi{u}{h}}$. Константа $C$ здесь произвольна, поскольку
при подстановке станет частью неизвестных коэффициентов $E(u)$. Подставляя
полученные выражения для $C_1$ и $C_2$ в eqref:eq:guessed-sol-2d-full, получаем
выражение
\begin{equation*}
    \phi(x,z) = \InverseFourierY{ \Sinh{2\pi u (z+h)} E(u) }{x}.
\end{equation*}
Подставляя $\phi$ в граничное условие на свободной поверхности, получаем
\begin{equation*}
    \zeta_t = f(x) \InverseFourierY{ 2\pi i u \Sinh{2\pi u (z+h)} E(u) }{x}
            - \InverseFourierY{ 2\pi u \SinhX{2\pi u (z+h)} E(u) }{x}.
\end{equation*}
Здесь $\sinh$ и $\cosh$ дают схожие результаты вблизи свободной поверхности, и,
поскольку эта область является наиболее интересной с точки зрения практического
применения, положим $\Sinh{2\pi{u}(z+h)}\approx\SinhX{2\pi{u}(z+h)}$. Выполняя
аналогичные предыдущему разделу операции, получаем окончательное выражение для
$\phi(x,z)$:
\begin{equation}
\boxed{
    \phi(x,z,t)
    =
  \InverseFourierY{
        \frac{\Sinh{2\pi u (z+h)}}{2\pi u}
        \frac{
            \FourierY{ \zeta_t / \left(i f(x) - 1\right) }{u}
        }{
            \FourierY{ \FunSecond{\zeta(x,t)} }{u}
        }
    }{x},
}
    \label{eq:solution-2d-full}
\end{equation}
где $\FunSecond{z}$ --- некоторая функция, вид которой будет определен в
[[#sec:compute-delta]] и для которой выполняется соотношение
$\FourierY{\FunSecond{z}}{u}=\Sinh{2\pi{u}{z}}$.

**** Сведение к формулам линейной теории волн.
Справедливость полученных формул проверим, подставив в качестве $\zeta(x,t)$
известные аналитические выражения для плоских волн. Символьные вычисления
преобразований Фурье в этом разделе производились с помощью пакета Mathematica
cite:mathematica10. В линейной теории широко используется предположение о
малости амплитуд волн, что позволяет упростить исходную систему уравнений
eqref:eq:problem-2d до
\begin{align*}
    & \phi_{xx}+\phi_{zz}=0,\\
    & \zeta_t = -\phi_z & \text{на }z=\zeta(x,t),
\end{align*}
решение которой запишется как
\begin{equation*}
    \phi(x,z,t)
    =
    -\InverseFourierY{
        \frac{e^{2\pi u z}}{2\pi u}
        \FourierY{\zeta_t}{u}
    }{x}
    .
\end{equation*}
Профиль прогрессивной волны описывается формулой $\zeta(x,t)=A\cos(2\pi(kx-t))$.
Подстановка этого выражения в eqref:eq:solution-2d дает равенство
$\phi(x,z,t)=-\frac{A}{k}\sin(2\pi(kx-t))\Sinh{2\pi{k}{z}}$. Чтобы свести его к
формуле линейной теории волн, представим гиперболический синус в
экспоненциальной форме и отбросим член, содержащий $e^{-2\pi{k}{z}}$, как
противоречащий условию $\phi\underset{z\rightarrow-\infty}{\longrightarrow}0$.
После взятия действительной части выражения получится известная формула линейной
теории $\phi(x,z,t)=\frac{A}{k}e^{2\pi{k}{z}}\sin(2\pi(kx-t))$. Аналогично,
предположение о малости амплитуд волн позволяет упростить формулу
eqref:eq:solution-2d-full до
\begin{equation*}
    \phi(x,z,t)
    =
    -\InverseFourierY{
        \frac{\Sinh{2\pi u (z+h)}}{2\pi u \Sinh{2\pi u h}}
        \FourierY{\zeta_t}{u}
    }{x}.
\end{equation*}
Подстановка формулы для прогрессивной плоской волны вместо $\zeta(x,t)$ дает
равенство
\begin{equation}
    \label{eq:solution-2d-linear}
    \phi(x,z,t)=\frac{A}{k}
    \frac{\Sinh{2 \pi k (z+h)}}{ \Sinh{2 \pi k h} }
    \sin(2 \pi (k x-t)),
\end{equation}
что соответствует формуле линейной теории для конечной глубины.

Различные записи решения уравнения Лапласа, в которых затухающая экспонента
может встречаться как со знаком "+", так и со знаком "-", могут стать причиной
разницы между формулами линейно теории и формулами, выведенными в данной работе,
где вместо $\sinh$ используется $\cosh$. Выражение
$\frac{\Sinh{2\pi{k}(z+h)}}{\Sinh{2\pi{k}{h}}}\approx\frac{\sinh(2\pi{k}(z+h))}{\sinh(2\pi{k}{h})}$
превращается в строгое равенство на поверхности, и разница между правой левой
частью увеличивается при приближении к дну водоема (для достаточно большой
глубины ошибка вблизи поверхности жидкости незначительна). Поэтому для
достаточно большой глубины можно использовать любую из функций ($\cosh$ или
$\sinh$) для вычисления потенциала скорости вблизи взволнованной поверхности.

Сведение формул eqref:eq:solution-2d и eqref:eq:solution-2d-full к формулам
линейной теории волн показывает, что формула eqref:eq:solution-2d для жидкости
бесконечной глубины не подходит для вычисления потенциала скорости с
использованием метода Фурье, т.к. не обладает необходимой для преобразования
Фурье симметрией. Однако, для такого случая можно использовать формулу для
конечной глубины, полагая $h$ равным характерному значению глубины исследуемого
водоема. Для стоячих волн сведение к формулам линейной теории происходит с
аналогичными предположениями.

*** Трехмерное поле скоростей
В трех измерениях исходная система уравнений eqref:eq:problem переписывается как
\begin{align}
    \label{eq:problem-3d}
    & \phi_xx + \phi_yy + \phi_zz = 0,\\
    & \zeta_t + \zeta_x\phi_x + \zeta_y\phi_y
    =
    \frac{\zeta_x}{\sqrt{1 + \zeta_x^2}} \phi_x
    +\frac{\zeta_y}{\sqrt{\vphantom{\zeta_x^2}\smash[b]{1 + \zeta_y^2}}} \phi_y
    - \phi_z, & \text{на }z=\zeta(x,y,t).\nonumber
\end{align}
Для ее решения также воспользуемся методом Фурье. Возьмем преобразование Фурье
от обоих частей уравнений Лапласа и получим
\begin{equation*}
    -4 \pi^2 \left( u^2 + v^2 + w^2 \right)
    \FourierY{\phi(x,y,z)}{u,v,w} = 0,
\end{equation*}
откуда имеем $w=\pm{i}\sqrt{u^2+v^2}$. Решение уравнения будем искать в виде
обратного преобразования Фурье $\phi(x,y,z)=\InverseFourierY{E(u,v,w)}{x,y,z}$.
Применяя полученное равенство, получаем
\begin{equation*}
    \phi(x,y,z) = \InverseFourierY{
        \left(
            C_1 e^{2\pi \sqrt{u^2+v^2} z}
            -C_2 e^{-2\pi \sqrt{u^2+v^2} z}
        \right)
        E(u,v)
    }{x,y}.
\end{equation*}
Подставляя $\phi$ в условие на дне водоема аналогично двухмерному случаю,
получаем
\begin{equation}
    \label{eq:guessed-sol-3d}
    \phi(x,y,z) = \InverseFourierY{
        \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)
    }{x,y}.
\end{equation}
Подставляя выражение для $\phi$ в граничное условие, получим
\begin{equation*}
    \arraycolsep=1.4pt
    \begin{array}{rl}
        \zeta_t = & i f_1(x,y) \InverseFourierY{2 \pi u \Sinh{2\pi \sqrt{u^2+v^2} (z+h)}E(u,v)}{x,y} \\
        + & i f_2(x,y) \InverseFourierY{2 \pi v \Sinh{2\pi \sqrt{u^2+v^2} (z+h)}E(u,v)}{x,y} \\
        - & \InverseFourierY{2 \pi \sqrt{u^2+v^2} \Sinh{2\pi \sqrt{u^2+v^2} (z+h)}E(u,v)}{x,y}
    \end{array}
\end{equation*}
где $f_1(x,y)={\zeta_x}/{\sqrt{1+\zeta_x^2}}-\zeta_x$ и
$f_2(x,y)={\zeta_y}/{\sqrt{\vphantom{\zeta_x^2}\smash[b]{1+\zeta_y^2}}}-\zeta_y$.
Применяя преобразование Фурье к обеим частям, получаем выражение для
коэффициентов $E$:
\begin{equation*}
    \arraycolsep=1.4pt
    \begin{array}{rl}
        \FourierY{\zeta_t}{u,v} = &
        \FourierY{i f_1(x,y) \InverseFourierY{2 \pi u \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)}{x,y}}{u,v}  \\
        + & \FourierY{i f_2(x,y) \InverseFourierY{2 \pi v \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)}{x,y}}{u,v}  \\
        - & 2 \pi \sqrt{u^2+v^2} \Sinh{2\pi \sqrt{u^2+v^2} (z+h)} E(u,v)
    \end{array}
\end{equation*}
Окончательное решение получается при подстановке выражения для $E(u,v)$
в eqref:eq:guessed-sol-3d.

* Численные методы и результаты экспериментов
** Форма АКФ для разных волновых профилей
*** Два метода для определения формы АКФ морских волн
**** Аналитический метод.
Прямой способ нахождения АКФ, соответствующей заданному профилю морской волны,
состоит в применении теоремы Винера---Хинчина. Согласно этой теореме
автокорреляционная функция $K$ функции $\zeta$ равна преобразованию Фурье от
квадрата модуля этой функции:
\begin{equation}
  K(t) = \Fourier{\left| \zeta(t) \right|^2}.
  \label{eq:wiener-khinchin}
\end{equation}
Если заменить $\zeta$ на формулу для волнового профиля, то это выражение даст
аналитическую формулу для соответствующей АКФ.

Для трехмерного волнового профиля (два пространственных и одно временное
измерение) аналитическая формула представляет собой многочлен высокой степени, и
ее лучше всего вычислять с помощью программы для символьных вычислений. Затем,
для практического применения она может быть аппроксимирована суперпозицией
экспоненциально затухающих косинусов (именно так выглядит АКФ стационарного
процесса АРСС cite:box1976time).

**** Эмпирический метод.
Впрочем, для трехмерного случая существует более простой эмпирический метод
нахождения формы АКФ, не требующий использования сложного программного
обеспечения. Известно, что АКФ, представляющая собой суперпозицию
экспоненциально затухающих косинусов, является решением уравнения Стокса для
гравитационных волн cite:boccotti1983wind. Значит, если в моделируемом морском
волнении важна только форма волны, а не точные ее характеристики, то заданный
волновой профиль можно просто домножить на затухающую экспоненту, чтобы получить
подходящую АКФ. Эта АКФ не отражает параметры волн, такие как высота и период,
зато это открывает возможность моделировать волны определенных неаналитических
форм, "рисуя" профиль волны, домножая его на экспоненту и используя
результирующую функцию в качестве АКФ. Таким образом, эмпирический метод
неточен, но более простой по сравнению с применением теоремы Винера---Хинчина;
он, в основном, полезен для тестирования модели АРСС.

*** Примеры АКФ для различных волновых профилей
**** АКФ стоячей волны.
Профиль трехмерной плоской стоячей волны задается как
\begin{equation}
  \zeta(t, x, y) = A \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq:standing-wave}
\end{equation}
Найдем АКФ с помощью аналитического метода. Домножив формулу на затухающую
экспоненту (поскольку преобразование Фурье определено для функции $f$, для
которой справедливо $f\underset{x\rightarrow\pm\infty}{\longrightarrow}0$),
получим
\begin{equation}
  \zeta(t, x, y) =
  A
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq:decaying-standing-wave}
\end{equation}
Затем, применяя трехмерное преобразование Фурье к обоим частям уравнения с
помощью программы для символьных вычислений, получим многочлен высокой степени,
который аппроксимируем выражением
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos \beta t
  \cos \left[ \beta x + \beta y \right].
  \label{eq:standing-wave-acf}
\end{equation}
Таким образом, после применения теоремы Винера---Хинчина получаем исходную
формулу, но с косинусами вместо синусов. Это различие важно, поскольку значение
АКФ в точке $(0,0,0)$ равно дисперсии процесса АРСС, которое при использовании
синусов было бы неверным.

Если попытаться получить ту же самую формулу с помощью эмпирического метода, то
выражение eqref:eq:decaying-standing-wave необходимо адаптировать для
соответствия eqref:eq:standing-wave-acf. Это можно осуществить либо, изменяя
фазу синуса, либо заменой синуса на косинус, чтобы сдвинуть максимум функции в
начало координат.

**** АКФ прогрессивной волны.
Профиль трехмерной плоской прогрессивной волны задается как
\begin{equation}
  \zeta(t, x, y) = A \cos (\sigma t + k_x x + k_y y).
  \label{eq:propagating-wave}
\end{equation}
Для аналитического метода повторение шагов из предыдущих двух параграфов дает
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos\left[\beta (t+x+y) \right].
  \label{eq:propagating-wave-acf}
\end{equation}
Для эмпирического метода профиль волны можно просто домножить на затухающую
экспоненту, не изменяя положение максимума АКФ (как это требовалось для стоячей
волны).

*** Сравнение изученных методов
Итого, аналитический метод нахождения АКФ морских волн сводится к следующим
шагам.
- Обеспечить затухание выражения для профиля волны на $\pm\infty$, домножив его
  на затухающую экспоненту.
- Взять преобразование Фурье от квадрата модуля получившегося профиля,
  воспользовавшись программой для символьных вычислений.
- Аппроксимировать получившийся многочлен подходящим выражением для АКФ.

Два примера этого раздела показывают, что затухающие профили стоячих и
прогрессивных волн схожи по форме с соответствующими АКФ с тем лишь различием,
что максимум АКФ должен быть перенесен в начало координат, чтобы сохранить
дисперсию моделируемого процесса. Применение эмпирического метода нахождения АКФ
сводится к следующим шагам.
- Обеспечить затухание выражения для профиля волны на $\pm\infty$, домножив его
  на затухающую экспоненту.
- Перенести максимум получившейся функции в начало координат, используя свойства
  тригонометрических функций для сдвига фазы.

** Дополнительные формулы, методы и алгоритмы для модели АРСС
*** Аппроксимация распределения аппликат
Одним из параметров генератора взволнованной морской поверхности служит функция
плотности распределения (ФПР) аппликат этой поверхности. Она задается либо
полиномиальной аппроксимацией натурных данных, либо аналитически.

**** Разложение в ряд Грама---Шарлье.
В cite:huang1980experimental было экспериментально показано, что распределение
аппликат морской поверхности отличается от нормального ненулевым эксцессом и
асимметрией. В cite:рожков1996теория показано, что такое распределение
раскладывается в ряд Грама---Шарлье:
\begin{align}
    \label{eq:skew-normal-1}
    F(z; \gamma_1, \gamma_2) & = \phi(z)
        - \gamma_1 \frac{\phi'''(z)}{3!}
        + \gamma_2 \frac{\phi''''(z)}{4!} \nonumber \\
    & =
    \frac{1}{2} \text{erf}\left[\frac{z}{\sqrt{2}}\right]
    -
    \frac{e^{-\frac{z^2}{2}}}{\sqrt{2\pi}}
    \left[
        \frac{1}{6} \gamma_1 \left(z^2-1\right)
        + \frac{1}{24} \gamma_2 z \left(z^2-3\right)
    \right]
    ,\nonumber \\
    f(z; \gamma_1, \gamma_2) & =
    \frac{e^{-\frac{z^2}{2}}}{\sqrt{2 \pi }}
    \left[
        \frac{1}{6} \gamma_1 z \left(z^2-3\right)
        + \frac{1}{24} \gamma_2 \left(z^4-6z^2+3\right)
        +1
    \right],
\end{align}
где $\phi(z)=\frac{1}{2}\mathrm{erf}(z/\sqrt{2})$, $\gamma_1$ --- асимметрия,
$\gamma_2$ --- эксцесс, $f$ --- ФПР, $F$ --- функция распределения (ФР).
Согласно cite:рожков1990вероятностные для аппликат морских волн значение
асимметрии выбирается на интервале $0,1\leq\gamma_1\leq{0,52}]$, а значение
эксцесса на интервале $0,1\leq\gamma_2\leq{0,7}$. Семейство плотностей
распределения при различных параметрах показано на [[fig:skew-normal-1]].

#+name: fig:skew-normal-1
#+begin_src R :results output graphics :exports results :file build/skew-normal-1-ru.pdf
source(file.path("R", "common.R"))
x <- seq(-3, 3, length.out=100)
params <- data.frame(
  skewness = c(0.00, 0.52, 0.00, 0.52),
  kurtosis = c(0.00, 0.00, 0.70, 0.70),
  linetypes = c("solid", "dashed", "dotdash", "dotted")
)
arma.skew_normal_1_plot(x, params)
legend(
  "topleft",
  mapply(
    function (s, k) {
      as.expression(bquote(list(
        gamma[1] == .(arma.fmt(s, 2)),
        gamma[2] == .(arma.fmt(k, 2))
      )))
    },
    params$skewness,
    params$kurtosis
  ),
  lty = paste(params$linetypes)
)
#+end_src

#+caption: Вид плотности распределения eqref:eq:skew-normal-1 аппликат взволнованной морской поверхности при различных значениях асимметрии $\gamma_1$ и эксцесса $\gamma_2$.
#+RESULTS: fig:skew-normal-1
[[file:build/skew-normal-1.pdf]]

**** Асимметричное нормальное распределение.
Альтернативной аппроксимацией распределения волновых аппликат служит формула
асимметричного нормального распределения:
\begin{align}
    \label{eq:skew-normal-2}
    F(z; \alpha) & = \frac{1}{2}
   \mathrm{erfc}\left[-\frac{z}{\sqrt{2}}\right]-2 T(z,\alpha ), \nonumber \\
    f(z; \alpha) & = \frac{e^{-\frac{z^2}{2}}}{\sqrt{2 \pi }}
   \mathrm{erfc}\left[-\frac{\alpha z}{\sqrt{2}}\right],
\end{align}
где $T$ --- функция Оуэна cite:owen1956tables. Эта формула не позволяет задать
значения асимметрии и эксцесса по отдельности --- оба значения регулируются
параметром $\alpha$. Преимущество данной формулы лишь в относительной простоте
вычисления: эта функция встроена в некоторые программы и библиотеки
математических функций. График функции для разных значений $\alpha$ представлен
на [[fig:skew-normal-2]].

#+name: fig:skew-normal-2
#+begin_src R :results output graphics :exports results :file build/skew-normal-2-ru.pdf
source(file.path("R", "common.R"))
x <- seq(-3, 3, length.out=100)
alpha <- c(0.00, 0.87, 2.25, 4.90)
params <- data.frame(
  alpha = alpha,
  skewness = arma.bits.skewness_2(alpha),
  kurtosis = arma.bits.kurtosis_2(alpha),
  linetypes = c("solid", "dashed", "dotdash", "dotted")
)
arma.skew_normal_2_plot(x, params)
legend(
  "topleft",
  mapply(
    function (a, s, k) {
      as.expression(bquote(list(
        alpha == .(arma.fmt(a, 2)),
        gamma[1] == .(arma.fmt(s, 2)),
        gamma[2] == .(arma.fmt(k, 2))
      )))
    },
    params$alpha,
    params$skewness,
    params$kurtosis
  ),
  lty = paste(params$linetypes)
)
#+end_src

#+caption: Вид плотности распределения eqref:eq:skew-normal-2 волновых аппликат при различных значениях коэффициента асимметрии $\alpha$.
#+RESULTS: fig:skew-normal-2
[[file:build/skew-normal-2.pdf]]

**** Тестирование.
Решение уравнения eqref:eq:distribution-transformation с выбранной функцией
распределения можно произвести либо в каждой точке генерируемой поверхности, что
даст наиболее точные результаты, либо в каждой точке фиксированной сетки,
интерполировав решение методом наименьших квадратов (МНК). Во втором случае
точность будет меньше. Например, интерполяция многочленом 12-го порядка на сетке
из 500 узлов, построенной на промежутке $-5\sigma_z\leq{z}\leq{5}\sigma_z$, дает
погрешность $\approx{0,43}\cdot10^{-3}$. Увеличение порядка многочлена приводит
либо к переполнениям при интерполяции МНК, либо к дополнительным коэффициентам
близким к нулю; увеличение размера сетки влияет на результат незначительно. В
большинстве случаев трех коэффициентов ряда Грама---Шарлье было достаточно для
преобразования АКФ; относительная погрешность без интерполяции составляет
$10^{-5}$.

*** Алгоритм генерации белого шума
Чтобы исключить периодичность из сгенерированной моделью ветрового волнения
реализации взволнованной поверхности, для генерации белого шума нужно
использовать ГПСЧ с достаточно большим периодом. В качестве такого генератора в
работе используется параллельная реализация вихря Мерсенна
cite:matsumoto1998mersenne с периодом $2^{19937}-1$. Это позволяет создавать
апериодичные реализации взволнованной морской поверхности для любых сценариев
применения, встречаемых на практике.

Запуск нескольких ГПСЧ с разными начальными состояниями в параллельных потоках
не гарантирует некоррелированность генерируемых последовательностей
псевдослучайных чисел, однако, можно воспользоваться алгоритмом динамического
создания вихрей Мерсенна cite:matsumoto1998dynamic, чтобы дать такую гарантию.
Суть алгоритма заключается в поиске таких матриц начальных состояний
генераторов, которые бы дали максимально некоррелированные последовательности
псевдослучайных чисел при параллельном запуске нескольких вихрей Мерсенна с
этими начальными состоянями. Поскольку на поиск начальных состояний можно
потратить значительное количество процессорного времени, то вектор состояний
создается предварительно для заведомо большего количества параллельных потоков и
сохраняется в файл, который впоследствиии считывается основной программой перед
началом генерации белого шума.

*** Алгоритм генерации взволнованной поверхности
В модели АРСС значение подъема взволнованной поверхности в каждой точке зависит
от предыдущих по пространству и времени значений, из-за чего в начале реализации
образуется так называемый /интервал разгона/ (см. рис. [[fig:ramp-up-interval]]) ---
промежуток, на котором реализация не соответствует заданной АКФ. Способ решения
этой проблемы зависит от контекста, в котором происходит моделирование.

Если реализация используется в контексте расчета остойчивости судна без учета
маневрирования, то интервал никак не повлияет результаты эксперимента, поскольку
находится на границе (далеко от исследуемого морского объекта). Если изучается
остойчивость судна в условиях маневрирования, то интервал проще всего исключить
из реализации (размер интервала примерно равен числу коэффициентов АР по каждому
из измерений). Однако, это приводит к потере большого числа точек, поскольку
исключение происходит по каждому из трех измерений. Альтернативным подходом
является генерация взволнованной поверхности на интервале разгона моделью ЛХ и
генерация остальной реализации с помощью модели АРСС.

В алгоритме генерации взволнованной поверхности используется параллелизм по
данным: реализация делится на равные части, каждая из которых генерируется
независимо, --- однако, в начале каждой из частей также присутствует интервал
разгона. Для его исключения используется метод /сшивания/, часто применяемый в
обработке цифровых сигналов
cite:oppenheim1989discrete,svoboda2011efficient,pavel2013algorithms. Суть метода
заключается в добавлении интервала равного по размеру интервалу разгона в конец
каждой из частей. Затем взволнованная поверхность генерируется в каждой точки
каждой из частей (включая добавленный интервал), интервал в конце части $N$
накладывается на интервал разгона в начале части $N+1$, и значения в
соответствующих точках складываются.

#+name: fig:ramp-up-interval
#+begin_src R :results output graphics :exports results :file build/ramp-up-interval-ru.pdf
source(file.path("R", "common.R"))
arma.plot_ramp_up_interval(label="Интервал разгона")
#+end_src

#+caption: Интевал разгона в начале оси $OX$ реализации.
#+RESULTS: fig:ramp-up-interval
[[file:build/ramp-up-interval-ru.pdf]]

*** Формулы нормировки для потенциалов скоростей
:PROPERTIES:
:CUSTOM_ID: sec:compute-delta
:END:

В решениях eqref:eq:solution-2d и eqref:eq:solution-2d-full двухмерной задачи
определения поля давлений присутствуют функции
$\Fun{z}=\InverseFourierY{e^{2\pi{u}{z}}}{x}$ и
$\FunSecond{z}=\InverseFourierY{\Sinh{2\pi{u}{z}}}{x}$, которые могут быть
записаны аналитически различными выражениями и представляют сложность при
вычислении на компьютере. Каждая функция --- это преобразование Фурье от
линейной комбинации экспонент, которое сводится к плохо определенной дельта
функции комплексного аргумента (см. [[tab:delta-functions]]). Обычно такого типа
функции записывают как произведение дельта функций от действительной и мнимой
части, однако, такой подход не работает здесь, поскольку взятие обратного
преобразования Фурье не даст экспоненту, что сильно исказит результирующее поле
скоростей. Для получения однозначного аналитического выражения можно
воспользоваться нормировкой $1/\Sinh{2\pi{u}{h}}$ (которая также включается в
выражение для коэффициентов $E(u)$). Численные эксперименты показывают, что
нормировка хоть и позволяет получить адекватное поле скоростей, оно мало
отличается от выражений из линейной теории волн, в которых члены с $\zeta$
опускаются.

#+name: tab:delta-functions
#+caption: Формулы для вычисления $\Fun{z}$ и $\FunSecond{z}$ из [[#sec:pressure-2d]], использующие нормировку для исключения неоднозначности определения дельта функции комплексного аргумента.
#+attr_latex: :booktabs t
| Функция         | Без нормировки                                             | С нормировкой                                                                                                                        |
|-----------------+------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------|
| $\Fun{z}$       | $\delta (x+i z)$                                           | $\frac{1}{2 h}\mathrm{sech}\left(\frac{\pi  (x-i (h+z))}{2 h}\right)$                                                                |
| $\FunSecond{z}$ | $\frac{1}{2}\left[\delta (x-i z) + \delta (x+i z) \right]$ | $\frac{1}{4 h}\left[\text{sech}\left(\frac{\pi  (x-i (h+z))}{2 h}\right)+\text{sech}\left(\frac{\pi  (x+i(h+z))}{2 h}\right)\right]$ |

** Верификация модели АРСС
:PROPERTIES:
:CUSTOM_ID: sec:verification
:END:

Для модели АР в работах
cite:degtyarev2011modelling,degtyarev2013synoptic,boukhanovsky1997thesis
экспериментальным путем были верифицированы
- распределения различных характеристик волн (высоты волн, длины волн, длины
  гребней, период волн, уклон волн, показатель трехмерности),
- дисперсионное соотношение,
- сохранение интегральных характеристик для случая смешанного волнения.
В данной работе верифицируются как модель АР, так и СС путем сравнения
распределений различных характеристик волн.

*** Верификация интегральных характеристик взволнованной поверхности
В cite:рожков1990вероятностные авторы показывают, что некоторые характеристики
морских волн (перечисленные в таблице [[tab:weibull-shape]]) имеют распределение
Вейбулла, а подъем взволнованной поверхности --- нормальное распределение. Для
верификации генерируемых моделями АР и СС реализаций используются спрямленные
диаграммы (графики, в которых по оси $OX$ откладываются квантили функции
распределения, вычисленные аналитически, а по оси $OY$ --- вычисленные
экспериментально). Если экспериментально полученное распределение соответствует
аналитическому, то график представляет собой прямую линию. Концы графика могут
отклоняться от прямой линии, поскольку не могут быть надежно получены из
реализации конечной длины. Различные методы извлечения волн из реализации также
могут привести к вариациям на концах графиков, извлечь каждую волну из
реализации практически невозможно, поскольку они могут (и часто) накладываются
друг на друга.

#+name: tab:weibull-shape
#+caption: Значение коэффициента формы $k$ распределения Вейбулла для различных характеристик волн.
#+attr_latex: :booktabs t
| Характеристика          | Коэффициент формы $k$ |
|-------------------------+-----------------------|
| Высота волны            |                     2 |
| Длина волны             |                   2,3 |
| Длина гребня волны      |                   2,3 |
| Период волны            |                     3 |
| Уклон волны             |                   2,5 |
| Показатель трехмерности |                   2,5 |

Верификация производится для стоячих и прогрессивных волн. Соответствующие АКФ и
спрямленные диаграммы распределений характеристик волн представлены на рис.
[[acf-slices]], [[standing-wave-distributions]], [[propagating-wave-distributions]].

#+name: propagating-wave-distributions
#+begin_src R :results output graphics :exports results :file build/propagating-wave-qqplots-ru.pdf
source(file.path("R", "common.R"))
par(pty="s", mfrow=c(2, 2))
arma.qqplot_grid(
  file.path("build", "propagating_wave"),
  c("elevation", "heights_y", "lengths_y", "periods"),
  c("подъем", "высота по Y", "длина по Y", "период"),
  xlab="x",
  ylab="y"
)
#+end_src

#+caption: Спрямленные диаграммы для прогрессивных волн.
#+RESULTS: propagating-wave-distributions
[[file:build/propagating-wave-qqplots.pdf]]

#+name: standing-wave-distributions
#+begin_src R :results output graphics :exports results :file build/standing-wave-qqplots-ru.pdf
source(file.path("R", "common.R"))
par(pty="s", mfrow=c(2, 2))
arma.qqplot_grid(
  file.path("build", "standing_wave"),
  c("elevation", "heights_y", "lengths_y", "periods"),
  c("подъем", "высота по Y", "длина по Y", "период"),
  xlab="x",
  ylab="y"
)
#+end_src

#+caption: Спрямленные диаграммы для стоячих волн.
#+RESULTS: standing-wave-distributions
[[file:build/standing-wave-qqplots-ru.pdf]]

#+name: acf-slices
#+header: :width 6 :height 9
#+begin_src R :results output graphics :exports results :file build/acf-slices-ru.pdf
source(file.path("R", "common.R"))
propagating_acf <- read.csv(file.path("build", "propagating_wave", "acf.csv"))
standing_acf <- read.csv(file.path("build", "standing_wave", "acf.csv"))
par(mfrow=c(5, 2), mar=c(0,0,0,0))
for (i in seq(0, 4)) {
  arma.wavy_plot(standing_acf, i, zlim=c(-5,5))
  arma.wavy_plot(propagating_acf, i, zlim=c(-5,5))
}
#+end_src

#+caption: Временные срезы АКФ для стоячих (слева) и прогрессивных (справа) волн.
#+RESULTS: acf-slices
[[file:build/acf-slices-ru.pdf]]

*** Верификация полей потенциалов скоростей
:PROPERTIES:
:CUSTOM_ID: sec:compare-formulae
:END:

Сравнение полученных общих формул eqref:eq:solution-2d и
eqref:eq:solution-2d-full с известными формулами линейной теории волн позволяет
оценить различие между полями скоростей для волн как больших, так и малых
амплитуд. В общем случае аналитическое выражение для потенциала скорости
неизвестно даже для плоских волн, поэтому сравнение производится численно. Имея
ввиду выводы раздела [[#sec:pressure-2d]], сравниваются только формулы для случая
конечной глубины.

**** Отличие от формул линейной теории волн.
Эксперимент показывает, что поля потенциалов скоростей, полученные по формуле
eqref:eq:solution-2d-full для конечной глубины и по формуле
eqref:eq:solution-2d-linear линейной теории, качественно отличаются (см.
[[fig:potential-field-nonlinear]]). Во-первых, контуры потенциала скорости имеют вид
затухающей синусоиды, что отличается от овальной формы, описываемой линейной
теории волн. Во-вторых, по мере приближения к дну водоема потенциал скорости
затухает гораздо быстрее, чем в линейной теории, а область, где сконцентрирована
большая часть энергии волны, еще больше приближена к ее гребню. Аналогичный
численный эксперимент, в котором из формулы eqref:eq:solution-2d-full были
исключены члены, которыми пренебрегают в рамках линейной теории волн, показал,
что полное соотвествие получившихся полей потенциалов скоростей (насколько это
позволяет сделать машинная точность).

#+name: fig:potential-field-nonlinear
#+caption: Поле потенциала скорости прогрессивной волны $\zeta(x,y,t) = \cos(2\pi x - t/2)$. Поле, полученное по формуле eqref:eq:solution-2d-full (слева) и по формуле линейной теории волн (справа).
#+attr_latex: :width 0.47\textwidth
#+begin_figure
[[file:graphics/pressure/potential-5.eps]]
[[file:graphics/pressure/potential-6.eps]]
#+end_figure

**** Отличие от формул теории волн малой амплитуды.
Эксперимент показывает, что поля скоростей, полученные по формуле
eqref:eq:solution-2d-full и формуле для волн малой амплитуды
eqref:eq:old-sol-2d, сопоставимы для волн малых амплитуд. В этом эксперименте
используются две реализации взволнованной морской поверхности, полученные по
модели АР: одна содержит волны малой амплитуды, другая --- большой.
Интегрирование в формуле eqref:eq:solution-2d-full ведется диапазону волновых
чисел, полученному из морской поверхности. Для волн малой амплитуды обе формулы
показывают сопоставимые результаты (разница в значениях скорости приписывается
стохастической природе модели АР), в то время как для волн больших амплитуд
устойчивое поле скоростей дает только формула eqref:eq:solution-2d-full (рис.
[[fig:velocity-field-2d]]). Таким образом, общая формула eqref:eq:solution-2d-full
показывает удовлетворительные результаты, не вводя ограничения на амплитуду
волн.

#+name: fig:velocity-field-2d
#+caption: Сравнение полей скоростей на поверхности моря, полученных по общей формуле ($u_1$) и формуле для волн малой амплитуды ($u_2$). Поле скоростей для поверхности волн малой амплитуды (слева) и большой амплитуды (справа).
#+begin_figure
[[file:build/low-amp-nocolor.eps]]
[[file:build/high-amp-nocolor.eps]]
#+end_figure

*** Нефизическая природа модели
Благодаря своей нефизической природе модель АРСС не включает в себя понятие
морской волны; вместо этого она моделирует взволнованную поверхность как единое
целое. Движения отдельных волн и их форма часто получаются грубыми, а точное
количество генерируемых волн неизвестно. Несмотря на это, интегральные
характеристики взволнованной поверхности соответствуют реальным морским волнам.

Теоретически, профили самих морских волн могут быть использованы в качестве АКФ,
если предварительно обеспечить их экспоненциальное затухание. Это может
позволить генерировать волны произвольных профилей и является одной из тем
дальнейших исследований.

* Высокопроизводительный программный комплекс для моделирования морского волнения
** Модель вычислений
*** Отображение алгоритма генерации взволнованной поверхности на вычислительную модель
Модель АРСС реализована в программном комплексе, работающем по принципу
вычислительного конвейера, в котором каждое звено применяет некоторую функцию к
выходным данным предыдущего звена. Звенья конвейера распределяются по узлам
вычислительного кластера, чтобы сделать возможным параллелизм по операциям, а
затем данные, перемещающиеся между звеньями конвейера распределяются между
ядрами процессора, чтобы сделать возможным параллелизм по данным. На
[[fig:pipeline]] представлена схема конвейера обработки данных, в которой
прямоугольниками со скругленными углами обозначены звенья конвейера, обычными
прямоугольниками --- массивы объектов из предметной области задачи, передаваемые
от одного звена к другому, а стрелками --- направление передачи данных.
Некоторые звенья разделены на /секции/, каждая из которых обрабатывает отдельную
часть массива. Если звенья соединены без использования /барьера/ (горизонтальная
или вертикальная полоса), то передача отдельных объектов между такими звеньями
происходит параллельно с вычислениями, по мере их готовности. Секции работают
параллельно на нескольких ядрах процессора (нескольких узлах кластера). Таким
образом, между множеством ядер процессора, секций звеньев конвейера и объектами
устанавливается сюръективное отображение, т.е. на одном ядре процессора может
работать несколько секций звеньев конвейера, каждая из которых может
обрабатывать несколько объектов последовательно, но одна секция не может
работать сразу на нескольких ядрах, а объект не может обрабатываться сразу
несколькими секциями конвейера.

#+name: fig:pipeline
#+begin_src dot :exports results :file build/pipeline-ru.pdf
digraph {

  node [fontsize=14,margin="0.055,0"]
  graph [nodesep="0.25",ranksep="0.25",rankdir="TB"]
  edge [arrowsize=0.66]

  # data
  subgraph xcluster_linear {
    label="Линейная модель"

    start [label="",shape=circle,style=filled,fillcolor=black,width=0.23]
    spectrum [label="S(ω,θ)",shape=box]
    acf [label="K(i,j,k)",shape=box]
    phi [label="Φ(i,j,k)",shape=box]

    # transformations
    fourier_transform [label="Преобразование Фурье",shape=box,style=rounded]
    solve_yule_walker [label="Решение уравнений\nЮла—Уокера",shape=box,style=rounded]

    subgraph cluster_nonlinear_1 {
      label="Моделир. нелинейности\l"
      labeljust=left
      style=filled
      color=lightgrey
      acf2 [label="K*(i,j,k)",shape=box]
      transform_acf [label="Преобразование АКФ",shape=box,style=rounded]
    }
  }

  subgraph xcluster_linear2 {

    eps_parts [label="<e1> ε₁|<e2> ε₂|<e3> …|<e4> εₙ|<e> ε(t,x,y)",shape=record]
    end [label="",shape=doublecircle,style=filled,fillcolor=black,width=0.23]

    generate_white_noise [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Генерация\lбелого шума",shape=record,style=rounded]
    generate_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Генерация частей\lвзволнованной мор-\lской поверхности\l",shape=record,style=rounded]

    zeta_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Несшитые части реализации",shape=record]
    overlap_add [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Сшивание час-\lтей реализации\l",shape=record,style=rounded]

    zeta_parts:g1->overlap_add:g1
    zeta_parts:g2->overlap_add:g2
    zeta_parts:g3->overlap_add:g3
    zeta_parts:g4->overlap_add:g4

    zeta_parts:g2->overlap_add:g1 [constraint=false]
    zeta_parts:g3->overlap_add:g2 [constraint=false]
    zeta_parts:g4->overlap_add:g3 [constraint=false]

    overlap_add:g1->zeta2_parts:g1
    overlap_add:g2->zeta2_parts:g2
    overlap_add:g3->zeta2_parts:g3
    overlap_add:g4->zeta2_parts:g4

    zeta2_parts:g1->transform_zeta:g1->zeta3_parts:g1->write_zeta:g1->eps_end
    zeta2_parts:g2->transform_zeta:g2->zeta3_parts:g2->write_zeta:g2->eps_end
    zeta2_parts:g3->transform_zeta:g3->zeta3_parts:g3->write_zeta:g3->eps_end
    zeta2_parts:g4->transform_zeta:g4->zeta3_parts:g4->write_zeta:g4->eps_end

  }

  subgraph part3 {

    zeta2_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Поверхность с нормаль-\lным законом распреде-\lления\l",shape=record]

    subgraph cluster_nonlinear_2 {
      label="Моделир. нелинейности\r"
      labeljust=right
      style=filled
      color=lightgrey
      zeta3_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> ζ(t,x,y)",shape=record]
      transform_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Преобразование за-\lкона распределения\lвзволнованной мор-\lской поверхности\l",shape=record,style=rounded]
    }

    # barriers
    eps_start [label="",shape=box,style=filled,fillcolor=black,height=0.05]
    eps_end [label="",shape=box,style=filled,fillcolor=black,height=0.05]

    write_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Запись готовых\lчастей в файл\l",shape=record,style=rounded]
  }

  # edges
  start->spectrum->fourier_transform->acf->transform_acf
  transform_acf->acf2
  acf2->solve_yule_walker
  solve_yule_walker->phi
  phi->eps_start [constraint=false]
  eps_start->generate_white_noise:g1
  eps_start->generate_white_noise:g2
  eps_start->generate_white_noise:g3
  eps_start->generate_white_noise:g4
  generate_white_noise:g1->eps_parts:e1->generate_zeta:g1->zeta_parts:g1
  generate_white_noise:g2->eps_parts:e2->generate_zeta:g2->zeta_parts:g2
  generate_white_noise:g3->eps_parts:e3->generate_zeta:g3->zeta_parts:g3
  generate_white_noise:g4->eps_parts:e4->generate_zeta:g4->zeta_parts:g4

  eps_end->end
}
#+end_src

#+caption: Схема конвейера обработки данных, реализующего генерацию взволнованной морской поверхности по АР модели.
#+RESULTS: fig:pipeline
[[file:build/pipeline-ru.pdf]]

Конвейер объектов можно считать развитием модели BSP (Bulk Synchronous Parallel)
cite:valiant1990bridging, применяемой в системах обработки графов
cite:malewicz2010pregel,seo2010hama. Конвейер позволяет исключить глобальную
синхронизацию (где это возможно) между последовательно идущим этапами вычислений
путем передачи данных между звеньев параллельно с вычислениями, в то время как в
модели BSP глобальная синхронизация происходит после каждого шага.

Поскольку передача данных между звеньями конвейера происходит параллельно с
вычислениями, то на одном и том же конвейере можно запустить сразу несколько
копий приложения с разными параметрами (генерировать сразу несколько
взволнованных морских поверхностей с разными характеристиками). На практике
оказывается, что высокопроизводительные приложения не всегда загружают
процессор на 100%, тратя время на синхронизацию параллельных процессов и
запись данных на диск. Использование конвейера в таком случае позволит на одном
и том же множестве процессов запустить сразу несколько расчетов и максимально
эффективно использовать все устройства компьютера. Например, во время записи в
файл одной задачей может производиться расчет на процессоре другой задачей. Это
минимизирует время простоя процессора и других устройств компьютера и повышает
общую пропускную способность кластера.

*** Обзор вычислительной модели
Основное назначение модели состоит в упрощении разработки распределенных
приложений для пакетной обработки данных и промежуточного программного
обеспечения. Основное внимание направлено на обеспечение устойчивости приложений
к поломкам оборудования, т.е. обеспечение отказоустойчивости и высокой
доступности, которое прозрачно для программиста. Реализация модели состоит из
двух слоев: на нижнем слое находятся подпрограммы и классы для приложений,
работающих на одном узле (без сетевых взаимодействий), на верхнем слое --- для
приложений, работающих на произвольном количестве узлов. Модель включает в себя
два вида сильно связанных друг с другом сущностей --- /управляющие объекты/ (или
/ядра/) и /конвейеры/, --- которые используются совместно для написания
программы.

Управляющие объекты реализуют логику (порядок выполнения) программы в методах
~act~ и ~react~ и хранят состояние текущей ветки исполнения. Как логика так и
состояние задаются программистом. В методе ~act~ какая-либо функция либо
вычисляется непосредственно, либо разлагается на вложенные функции
(представляемые подчиненными управляющими объектами), которые впоследствии
отправляются на конвейер. В методе ~react~ подчиненные управляющие объекты,
вернувшиеся с конвейера, обрабатываются их родительским объектом. Вызовы методов
~act~ и ~react~ производятся асинхронно внутри потоков, присоединенных к
конвейеру. Для каждого управляющего объекта метод ~act~ вызывается только один
раз, и для нескольких объектов вызовы происходят параллельно друг другу, в то
время как метод ~react~ вызывается один раз для каждого подчиненного объекта, и
все вызовы происходят в одном потоке для предотвращения одновременного изменения
состояния несколькими потоками (для разных родительских объектов могут
использоваться разные потоки).

Конвейеры осуществляют асинхронные вызовы методов ~act~ и ~react~, стараясь
сделать как можно больше вызовов параллельно, учитывая предоставляемый
платформой параллелизм (количество процессорных ядер на узле и количество узлов
в кластере). Конвейер включает в себя пул управляющих объектов, содержащий все
подчиненные объекты, отправленные в него родителями, и пул потоков,
обрабатывающий эти объекты в соответствии с правилами, описанными в предыдущем
параграфе. Для каждого устройства используется отдельный конвейер. Существуют
конвейеры для параллельной обработки, обработки по расписанию (периодические и
отложенные задачи) и промежуточный конвейер для обработки управляющих объектов
на узлах кластера (см. рис. [[fig:subord-ppl]]).

По принципу работу механизм управляющих объектов и конвейеров напоминает
механизм работы процедур и стеков вызовов, с тем лишь преимуществом, что методы
объектов вызываются асинхронно и параллельно друг другу (насколько это позволяет
логика программы). Поля управляющего объекта --- это локальные переменные стека,
метод ~act~ --- это последовательность процессорных инструкций перед вложенным
вызовом процедуры, а метод ~react~ --- это последовательность инструкций после
вложенного вызова. Создание и отправка на конвейер подчиненного объекта --- это
вложенный вызов процедуры. Наличие двух методов обуславливается асинхронностью
вложенных вызовов и помогает заменить активное ожидание завершения подчиненных
объектов пассивным при помощи конвейеров. Конвейеры, в свою очередь, позволяют
реализовать пассивное ожидание и вызывают правильные методы, анализируя
внутреннее состояние объектов.

#+name: fig:subord-ppl
#+begin_src dot :exports results :file build/subord-ppl-ru.pdf
graph G {

  node [fontsize=14,margin="0.055,0",shape=box]
  graph [nodesep="0.25",ranksep="0.25",rankdir="LR"]
  edge [arrowsize=0.66]

  subgraph cluster_daemon {
    label="Родительский процесс"
    style=filled
    color=lightgrey

    factory [label="Фабрика"]
    parallel_ppl [label="Параллельный\nконвейер"]
    io_ppl [label="Конвейер\nввода/вывода"]
    sched_ppl [label="Конвейер\nдля таймера"]
    net_ppl [label="Конвейер для\nсетевых устройств"]
    proc_ppl [label="Конвейер\nдля процессов"]

    upstream [label="Пул потоков upstream"]
    downstream [label="Пул потоков downstream"]
  }

  factory--parallel_ppl
  factory--io_ppl
  factory--sched_ppl
  factory--net_ppl
  factory--proc_ppl

  subgraph cluster_hardware {
    label="Вычислительные устройства"
    style=filled
    color=lightgrey

    cpu [label="CPU"]
    core0 [label="Ядро 0"]
    core1 [label="Ядро 1"]
    core2 [label="Ядро 2"]
    core3 [label="Ядро 3"]

    storage [label="Устройства\nхранения"]
    disk0 [label="Диск 0"]

    network [label="Сетевые\nкарты"]
    nic0 [label="СК 0"]

    timer [label="Таймер"]

  }

  core0--cpu
  core1--cpu
  core2--cpu
  core3--cpu

  disk0--storage
  nic0--network

  parallel_ppl--upstream
  parallel_ppl--downstream

  upstream--{core0,core1,core2,core3} [style="dashed"]
  downstream--core0 [style="dashed"]

  io_ppl--core0 [style="dashed"]
  io_ppl--disk0 [style="dashed"]
  sched_ppl--core0 [style="dashed"]
  sched_ppl--timer [style="dashed"]
  net_ppl--core0 [style="dashed"]
  net_ppl--nic0 [style="dashed"]
  proc_ppl--core0 [style="dashed"]

  subgraph cluster_children {
    style=filled
    color=white

    subgraph cluster_child0 {
      label="Дочерний процесс 0"
      style=filled
      color=lightgrey

      app0_factory [label="Фабрика"]
      app0 [label="Конвейер\nдочернего процесса"]
    }

    subgraph cluster_child1 {
      label="Дочерний процесс 1"
      style=filled
      color=lightgrey

      app1_factory [label="Фабрика"]
      app1 [label="Конвейер\nдочернего процесса"]
    }
  }

  proc_ppl--app0
  proc_ppl--app1

  app0_factory--app0 [constraint=false]
  app1_factory--app1 [constraint=false]

}
#+end_src

#+caption: Отображение конвейеров родительского и дочернего процессов на вычислительные устройства.
#+RESULTS: fig:subord-ppl
[[file:build/subord-ppl-ru.pdf]]

*** Основополагающие принципы модели
Модель конвейера обработки данных строится по следующим принципам, следование
которым обеспечивает максимальную эффективность программы.
- В модели отсутствует понятие сообщения, роль сообщения выполняет сам
  управляющий объект: он может быть передан по сети на другой узел и получить
  доступ к полям любого другого управляющего объекта на этом узле. Гарантировать
  существование такого объекта может только логика программы.
- Управляющий объект представляет собой /сопрограмму/, которая при вызове
  отправляется в пул управляющих объектов и затем выполняется планировщиком
  асинхронно. Тело сопрограммы может содержать произвольное количество вызовов
  других сопрограмм. Каждый вызов отправляет соответствующую сопрограмму в пул и
  сразу завершается. Управляющие объекты, находящиеся в пуле, могут быть
  обработаны в любом порядке; это используется планировщиком для извлечения
  максимального параллелизма из вычислительной системы путем распределения
  объектов из пула между доступными узлами кластера и ядрами процессора.
- Асинхронное выполнение управляющих объектов позволяет избежать явной
  синхронизации после вызова сопрограммы (отправки объекта в очередь);
  планировщик возвращает поток управления в родительский управляющий объект
  каждый раз когда какой-либо его дочерний объект завершает выполнение. Такое
  взаимодействие превращает сопрограмму в некоторого рода обработчик событий, в
  котором событием является дочерний объект, а обработчиком --- родительский.
- Сопрограмма может взаимодействовать с произвольным количеством управляющих
  объектов, адреса которых известны; взаимодействие с объектами, осуществляемое
  вразрез с иерархией сильно усложняет поток управления и стек вызовов
  сопрограмм теряет древовидную структуру. Только логика программы может
  гарантировать существование в памяти машины двух взаимодействующих объектов.
  Один из способов обеспечения такой гарантии --- взаимодействие между
  вложенными сопрограммами, вызванными из одной родительской сопрограммы.
  Поскольку такого рода взаимодействие можно осуществить в рамках иерархии через
  родительскую сопрограмму, его можно считать оптимизацией, позволяющей
  избавиться от накладных расходов при передаче данных через промежуточный узел.
  Для программ, логика которых полностью основана на событиях (например, для
  серверов и программ с графическим интерфейсом), ситуация иная, и такого рода
  взаимодействия являются основными.
- Также, взаимодействия, идущие вразрез с иерархией и поверх сети кластера,
  усложняют разработку алгоритмов обеспечения отказоустойчивости. Гарантировать
  нахождение определенного управляющего объекта в памяти соседнего узла
  невозможно, поскольку узел может выйти из строя прямо во время выполнения
  соответствующей сопрограммы. В результате, при аварийном завершении
  сопрограммы, все его вложенные сопрограммы должны быть выполнены заново. Это
  подталкивает программиста к созданию
  - глубоких древовидных иерархий сильно связанных управляющих объектов (которые
    взаимодействуют между собой на одном уровне иерархии), уменьшающих накладные
    расходы на повторное выполнение сопрограмм;
  - толстых древовидных иерархий слабо связанных управляющих объектов,
    обеспечивающих максимальную степень параллелизма.
  Глубокие иерархии это не только требование технологии, они помогают
  оптимизировать сетевое взаимодействие большого количества узлов кластера,
  сводя его к взаимодейсвтвию соседних узлов.

Таким образом, управляющие объекты обладают свойствами как сопрограмм, так и
обработчиков событий одновременно.

** Реализация для систем с общей памятью (SMP)
*** Алгоритм распределения нагрузки
Наиболее простым и широко применяемым подходом к распределению нагрузки на
вычислительную систему является разбиение данных на равные части (или разбиение
задачи на однородные подзадачи) с последующим их равномерным распределением
между отдельными ядрами процессора и узлами кластера, однако такой подход не
всегда работает эффективно. Во-первых, часто общее количество частей, на которые
разбиваются входные данные, диктуется не архитектурой и конфигурацией
вычислительной системы, а самой задачей, и такое распределение не всегда
эффективно с точки зрения вычислительной машины: количество частей оказывается
либо слишком большим по сравнению с количеством процессоров, работающих
параллельно, что ведет к увеличению накладных расходов на обмен данными, либо
слишком маленьким, что не позволяет использовать все доступные вычислительные
ядра. Во-вторых, накладываемые решаемой задачей ограничения могут не позволить
разделить входные данные на равные части, что может стать причиной дисбаланса в
загрузке ядер процессора. В-третьих, в вычислительной системе в вычислениях
участвуют помимо процессора сразу несколько компонент (таких как векторные
сопроцессоры и устройства хранения), то время решения конкретной задачи зависит
от производительности всех задействованных устройств. Каким же образом сделать
алгоритм распределения нагрузки более эффективным, принимая во внимание разный
размер частей, на которые разделяются входные данные, и учитывая все устройства,
задействованные в вычислениях?

Алгоритм распределения нагрузки состоит из двух этапов. На первом этапе алгоритм
размещает часть входных данных (или подзадачу), обернутую в управляющий объект,
в соответствующем пуле управляющих объектов: для каждого устройства используется
отдельный пул управляющих объектов и сопряженный с ним пул потоков. На втором
этапе, управляющий объект извлекается из пула одним из потоков и обрабатывается.
Благодаря отдельным пулам потоков все устройства работают параллельно, уменьшая
тем самым время простоя оборудования по сравнению с использованием всех
устройств из одного потока.

Для того чтобы учесть неоднородность частей, на которые разбиваются входные
данные, и неоднородность выполняемых задач, необходимо предсказать время
выполнения каждой из задач. Соответствующее исследование сделано в
cite:degtyarev2016balance, поскольку реализация модели АРСС включает в себя, в
основном, однородные задачи.

Таким образом, распределение нагрузки осуществляется в два этапа: на первом
этапе задача в форме урпавляющего объекта направляется на подходящее устройство,
а на втором этапе она направляется в один из потоков из соответсвующего
устройству пула. Неоднородность управляющих объектов может быть учтена путем
предсказания времени их выполнения, однако такие объекты не встречаются в
реализации модели АРСС.

*** Результаты тестирования
**** Производительность реализаций на MPI, OpenMP и OpenCL.
Программная реализация состояла в создании и отладке прототипа программы и в
последующем написании компоненты виртуального полигона на языке более низкого
уровня. При этом тесты показали, что одной высокопроизводительной
многопроцессорной машины достаточно для создания типовых реализаций морского
волнения. Также использование видеокарт в качестве векторных ускорителей
эффективно только в случае расчета давлений, в то время как генерация волновой
поверхности выполняется быстрее на скалярном процессоре cite:degtyarev2011effi.

Создание программной реализации происходило в два этапа: на первом этапе был
создан и отлажен прототип в программной среде Mathematica cite:mathematica10, а
на втором этапе логика программы была переписана на более низкоуровневом языке
C++, и для получения эффективно работающего параллельного кода были проведены
эксперименты с рядом библиотек. С помощью этих библиотек были реализованы
функции генерации взволнованной морской поверхности, а также процедура расчета
гидродинамических давлений под сгенерированной поверхностью. Тестирование
производилось на вычислительных машинах кластера РЦ ВЦ СПбГУ (см.
[[tab:autoreg-testbed]]) и позволило получить два основных результата. Во-первых,
использование видеокарт неэффективно при генерации волновой поверхности (см.
[[tab:autoreg-performance]]), что обусловлено сравнительно небольшим количеством
арифметических операций по отношению к количеству операций с памятью устройства,
а также отсутствием трансцендентных функций в реализации алгоритма
cite:degtyarev2011effi. Во-вторых, для генерации одной реализации взволнованной
морского поверхности одной многопроцессорной машины достаточно для эффективного
и быстрого решения задачи (см. [[fig:autoreg-performance]]). По результатам
тестирования стандарт OpenMP был выбран в качестве основного, как наиболее
эффективный и наиболее подходящий для расчетов на многопроцессорной системе.

#+name: fig:autoreg-performance
#+caption: Скорость генерации взволнованной поверхности на многопроцессорной системе для типовых размеров реализации (сверху). Масштабируемость (относительное ускорение при увеличении количества процессоров) программной реализации на многопроцессорной системе для типовых размеров реализации (снизу). Временная протяженность 512 с.
#+begin_figure
[[file:graphics/speed.eps]]
[[file:graphics/speedup.eps]]
#+end_figure

#+name: tab:autoreg-testbed
#+caption: Конфигурация оборудования.
#+attr_latex: :booktabs t
| Вычислительная машина | HP SL390s G7                           |
| Процессор             | 2\(\times\)Intel X5650 (всего 12 ядер) |
| Оперативная память    | 96ГБ RAM                               |
| Операционная система  | CentOS 5.6 (Linux)                     |

#+name: tab:autoreg-performance
#+caption: Время (с.) генерации взволнованной морской поверхности различными программными реализациями авторегрессионной модели.
#+attr_latex: :booktabs t :align cllllll
|        |     ЛХ |     ЛХ |    ЛХ |     АР |     АР |    АР |
| Размер | OpenCL | OpenMP |   MPI | OpenCL | OpenMP |   MPI |
|--------+--------+--------+-------+--------+--------+-------|
| 400000 |   0.82 |  40.44 | 32.60 |   1.80 |  0.800 | 0.750 |
| 440000 |   0.90 |  44.59 | 35.78 |   1.92 |  0.100 | 0.930 |
| 480000 |   0.99 |  48.49 | 38.93 |   2.29 |  0.970 | 0.126 |
| 520000 |   1.07 |  52.65 | 41.92 |   2.43 |  0.118 | 0.117 |
| 560000 |   1.15 |  56.45 | 45.00 |   2.51 |  0.117 | 0.161 |
| 600000 |   1.23 |  60.85 | 48.80 |   2.54 |  0.123 | 0.132 |
| 640000 |   1.31 |  65.07 | 53.02 |   2.73 |  0.123 | 0.160 |
| 680000 |   1.40 |  68.90 | 54.92 |   2.80 |  0.138 | 0.136 |
| 720000 |   1.48 |  72.49 | 58.42 |   2.88 |  0.144 | 0.173 |
| 760000 |   1.56 |  76.86 | 61.41 |   3.47 |  0.156 | 0.155 |
| 800000 |   1.64 |  81.03 | 66.42 |   3.25 |  0.166 | 0.174 |

Кроме выбора стандарта параллельных вычислений на время работы программы влияет
выбор библиотек типовых вычислительных методов, и эффективность этих библиотек
была показана тестированием их разработчиками. В качестве библиотеки для
матричных операций (расчета коэффициентов авторегрессионной модели) была выбрана
GotoBLAS и основанная на ней LAPACK, для непрерывной аппроксимации поля волновых
чисел использовалась библиотека CGAL cite:fabri2009cgal и для статистической
проверки интегральных характеристик реализации взволнованной поверхности
использовалась библиотека GSL cite:gsl2008scientific. В случае GotoBLAS
эффективность библиотеки показана в работах cite:goto2008high,goto2008anatomy,
для других библиотек эффективность не является важной, и они были выбраны,
исходя из удобства их использования.

#+name: tab:arma-libs
#+caption: Список библиотек, используемых в реализации модели АРСС.
#+attr_latex: :booktabs t :align lp{0.6\linewidth}
| Library                                                | What it is used for              |
|--------------------------------------------------------+----------------------------------|
| DCMT cite:matsumoto1998dynamic                         | параллельный ГПСЧ                |
| Blitz cite:veldhuizen1997will,veldhuizen2000techniques | многомерные массивы              |
| GSL cite:gsl2008scientific                             | вычисление ФПР, ФР, БПФ          |
|                                                        | проверка стационарности процесса |
| LAPACK, GotoBLAS cite:goto2008high,goto2008anatomy     | определение коэффициентов АР     |
| GL, GLUT cite:kilgard1996opengl                        | трехмерная визуализация          |

**** Производительность алгоритма распределения нагрузки.
Программная реализация генерации взволнованной поверхности сбалансирована с
точки зрения нагрузки на процессорные ядра, однако, как показывают тесты,
характеризуется высокой нагрузкой на устройства хранения. До проведения
тестирования генерация взволнованной поверхности была реализована с
использованием OpenMP для параллельных вычислений, и была переписана с
использованием POSIX потоков для того чтобы реализовать алгоритм распределения
нагрузки. Производительность двух реализаций сравнивалась на платформе,
конфигурация которой приведена в таблице [[tab:multicore-specs]].

#+name: tab:multicore-specs
#+caption: Конфигурация многоядерной системы.
#+attr_latex: :booktabs t
| Компонента                    | Подробности                      |
|-------------------------------+----------------------------------|
| Язык программирования         | C++11                            |
| Библиотека потоков            | C++11 STL threads                |
| Библиотека атомарных операций | C++11 STL atomic                 |
| Подпрограммы замера времени   | ~clock_gettime(CLOCK_MONOTONIC)~ |
|                               | ~/usr/bin/time -f \%e~           |
| Компилятор                    | GCC 4.8.2                        |
| Опции компиляции              | ~-std=c++11 -O2 -march=native~   |
| Операционная система          | Debian 3.2.51-1 x86_64           |
| Файловая система              | ext4                             |
| Процессор                     | Intel Core 2 Quad Q9650          |
| Частота процессора (ГГц)      | 3.00                             |
| Количество ядер               | 4                                |
| Объем оперативной памяти (ГБ) | 8                                |
| Диск                          | Seagate ST3250318AS              |
| Скорость диска (об./мин.)     | 7200                             |

Эксперимент состоял в запуске двух программных реализаций на многоядерной
машине, изменяя размер поверхности. Размер пула потоков процессора и пула
потоков ввода/вывода оставался неизменным во время эксперимента. Пул потоков
ввода/вывода состоял из одного потока, а количество потоков процессора равнялось
количеству физических ядер процессора.

В эксперименте алгоритм распределения нагрузки показал большую эффективность по
сравнению с реализацией без него. Чем больше размер генерируемой поверхности,
тем больше разрыв в производительности (рис. [[fig:factory-performance]]), что
является следствием наложения вычислительной фазы и фазы вывода данных друг на
друга (рис. [[fig:factory-overlap]]). В реализации OpenMP фаза вывода данных
начинается только тогда, когда заканчивается вычислительная фаза, в то время как
использование алгоритма распределения нагрузки приводит почти к одновременному
завершению обеих фаз. Таким образом, /выполнение параллельных изнутри,
последовательных фаз в режиме конвейера более эффективно, чем их
последовательное выполнение/, и это позволяет сбалансировать нагрузку на
различные устройства, задействованные в вычислениях.

#+name: fig:factory-performance
#+begin_src R :results output graphics :exports results :file build/factory-vs-openmp-ru.pdf
source(file.path("R", "common.R"))
arma.plot_factory_vs_openmp(
  xlab="Размер реализации",
  ylab="Время, с.",
  power=6
)
#+end_src

#+caption: Сравнение производительности реализаций программы на OpenMP и Factory.
#+RESULTS: fig:factory-performance
[[file:build/factory-vs-openmp-ru.pdf]]

#+name: fig:factory-overlap
#+header: :width 9 :height 4
#+begin_src R :results output graphics :exports results :file build/factory-vs-openmp-overlap-ru.pdf
source(file.path("R", "common.R"))
par(mar=c(5, 6, 0, 1), pty="m")
arma.plot_factory_vs_openmp_overlap(
  xlab="Время, с.",
  labels=c("Factory", "OpenMP"),
  scale=10**9
)
#+end_src

#+caption: Наложение параллельных вычислений на $[G_0,G_1]$ и записи данных на диск на $[W_0,W_1]$. В реализации OpenMP наложение отсутствует.
#+RESULTS: fig:factory-overlap
[[file:build/factory-vs-openmp-overlap-ru.pdf]]

Предложенный алгоритм распределения нагрузки на многоядерную систему позволяет
получить прирост производительности для приложений, считывающих и записывающих
большой объем данных на диск, но может быть использован также и в других
случаях. Основная идея алгоритма состоит в определении типа нагрузки и поиске
подходящего устройства для перенаправления нагрузки на него. Таким образом любое
устройство помимо дисков может быть использовано.

** Реализация для систем с распределенной памятью (MPP)
*** Алгоритм обнаружения узлов кластера
**** Введение.
Многие распределенные системы построены по принципу /субординации/: в каждом
кластере выбирается главный (руководящий) узел, который управляет очередью
задач, планирует их запуск на подчиненных узлах и следит за их состоянием. Роль
главного узла задается либо /статически/, путем выделения конкретного
физического узла под нее, либо /динамически/, путем избрания какого-либо из
узлов кластера главным. В первом случае отказоустойчивость обеспечивается
посредством резервирования дополнительного свободного узла, который выполнит
роль главного в случае отказа текущего. Во втором случае отказоустойчивость
обеспечивается выбором нового главного узла из оставшихся. Несмотря на то что
динамическое задание ролей требует наличия специализированного распределенного
алгоритма, этот подход становится все более и более популярным, поскольку не
требует наличия простаивающих резервных узлов на случай отказа главного узла.

Алгоритмы выбора лидера (которые иногда называют алгоритмами /распределенного
консенсуса/) являются частными случаями волновых алгоритмов. В
cite:tel2000introduction Тель определяет их как алгоритмы, в которых событие
завершения программы предваряется хотя бы одним каким-либо другим событием,
происходящем в /каждом/ параллельном процессе. Волновые алгоритмы не определены
для анонимных сетей, т.е. они работают только с теми параллельными процессами,
которые могут себя уникально идентифицировать. Однако, количество процессов,
которых затрагивает "волна", может быть определено по мере выполнения алгоритма.
В рамках распределенных систем это означает, что волновые алгоритмы подходят для
вычислительных кластеров с динамически меняющимся количеством узлов, так что
включение и выключение отдельных узлов не влияет на работу алгоритма.

Подход к динамическому выбору главного узла, исследованный в данной работе, не
использует волновые алгоритмы, а значит не требует опроса всех узлов кластера
для выбора лидера. Вместо этого каждый узел кластера нумерует все узлы подсети,
в которой он находится, и преобразует список в /древовидную иерархию/ с заданным
максимальным значением ветвления (максимальным количеством подчиненных вершин).
Затем узел определяет свой уровень иерархии и пытается соединиться с
вышестоящими узлами, чтобы стать их подчиненным. Сначала он проверяет близко
расположенные к нему узлы, а потом все остальные узлы вплоть до вершины
иерархии. Если вышестоящих узлов нет или с ними невозможно соединиться, то узел
сам становится главой иерархии.

Древовидная иерархия узлов подсети определяет отношение строгого порядка на
множестве всех узлов кластера. Несмотря на то что с технической точки зрения
любая функция может быть выбрана для присвоения узлу подсети номера в списке, на
практике эта функция должна быть достаточно гладкой вдоль временной оси и иметь
лишь редкие скачки: быстрые изменения в структуре иерархии узлов (которые часто
являются следствием погрешности измерений) могут привести постоянной передаче
роли главного узла от одного узла к другому, что сделает кластер неуправляемым.
Простейшей такой функцией является позиция IP-адреса узла в диапазоне всех
IP-адресов подсети.

Следующие ключевые особенности отличают наш подход от некоторых предложенных
ранее подходов cite:brunekreef1996design,aguilera2001stable,romano2014design.
- *Многоуровневая иерархия.* Количество руководящих узлов в сети зависит от
  значения ветвления. Если оно меньше количества IP-адресов в подсети, то в
  кластере будет несколько руководящих узлов. Если оно больше или равно
  количеству IP-адресов в подсети, то в кластере будет только один руководящий
  узел. Когда какой-либо узел выходит из строя, многоуровневая иерархия
  изменятся локально, только узлы, примыкающие к вышедшему из строя,
  взаимодействуют друг с другом.
- *Отображение IP-адресов.* Поскольку структура иерархии зависит только от
  IP-адресов узлов, то в алгоритме отсутствует фаза выбора лидера. Чтобы сменить
  руководителя, каждый узел отправляет сообщение только прежнему и новому
  руководителю.
- *Полностью основан на событиях.* Сообщения отправляются только при выходе из
  строя узла, поэтому постоянной нагрузки на сеть нету. Поскольку алгоритм
  допускает ошибку при отправке любого сообщения, то нет необходимости в
  heartbeat-пакетах, являющихся индикацией нахождения узла в сети; вместо этого
  все сообщения выполняют роль heartbeat-пакетов и настраивается время ожидания
  отправки пакета.
- *Отсутствие ручной конфигурации.* Узлу не требуется никаких предварительных
  знаний, чтобы найти руководителя: он определяет сеть, узлом которой он
  является, вычисляет IP-адрес потенциального руководителя и отправляет ему
  сообщение. Если это не срабатывает, то процесс повторяется для следующего
  потенциального руководителя. Таким образом, алгоритм подходит для начальной
  загрузки кластера без ручной настройки, для этого требуется только запустить
  соответствующий сервис на каждом узле.
Суммируя вышесказанное, достоинством алгоритма является то, что он
- масштабируется на большое количество узлов посредством иерархии с несколькими
  руководящими узлами,
- не нагружает сеть отправкой сообщений с текущим состоянием узлов и
  heartbeat-пакетами,
- не требует ручной настройки для первичной загрузки кластера.

Недостатком алгоритма является то, что он требует редкого изменения IP-адресов.
Он не подходит для облачной среды, в которой только DNS имя узла сохраняется, а
IP-адрес может меняться со временем. Когда IP-адрес меняется, текущие соединения
могут закрыться, сигнализируя о "выходе из строя" узла и перестраивая иерархию
узлов. Таким образом, окружения, в которых узлы не идентифицируются IP-адресами,
не подходят для алгоритма.

Другим недостатком алгоритма является искусственная зависимость ранга узла от
IP-адреса: замена отображения IP-адресов на что-то более совершенное (например,
на отображение, которое использует загрузку текущего узла и сети для
ранжирования узлов) представляет сложность, поскольку погрешность измерений
может стать причиной неустойчивой иерархии, а полная событийность алгоритма
будет нарушена.

Алгоритм обнаружения узлов спроектирован для балансировки нагрузки на кластер
вычислительных узлов, и его применение в других приложениях не рассматривается в
данной работе. Когда распределенная или параллельная программа запускается на
одном из узлов кластера, ее подзадачи распределяются между всеми примыкающими
узлами иерархии (включая главный узел, если есть). Для того чтобы равномерно
распределить нагрузку, когда программа запускается на подчиненном узле, каждый
узел хранит вес каждого из примыкающих узлов иерархии. Вес равен количеству
узлов дерева, находящегося "за" примыкающим узлом. Например, если вес первого
примыкающего узла равен 2, то циклический алгоритм балансировки нагрузки
распределит две подзадачи на первый узел перед тем как перейти к следующему
узлу.

Суммируя вышесказанное, алгоритм обнаружения узлов
- спроектирован для облегчения распределения нагрузки на кластер,
- полностью отказоустойчивый, состояние каждого узла можно вычислить заново в
  любой момент времени,
- полностью основан на событиях, а значит не нагружает сеть периодической
  отправкой сообщений.


**** Построение древовидной иерархии.
Субординация на множестве $\mathcal{N}$ узлов одной подсети определяется как
\begin{equation*}
\forall n_1 \forall n_2 \in \mathcal{N},
\forall f \colon \mathcal{N} \rightarrow \mathcal{R}^n
\Rightarrow (f(n_1) < f(n_2) \Leftrightarrow \neg (f(n_1) \geq f(n_2))),
\end{equation*}
где $f$ --- отображение узла на его идентификационный номер, и $<$ --- оператор,
определяющий отношение строго порядка на множестве $\mathcal{R}^n$. Функция $f$
присваивает узлу его порядковый номер, а оператор $<$ делает этот номер
уникальным.

Простейшее отображение $f$ ставит в соответствие каждому узлу подсети позицию
его IP-адреса в диапазоне всех адресов подсети. Без преобразования к древовидной
структуре (когда в подсети выбирается только один лидер) рабочий узел, адрес
которого занимает наименьшую позицию в диапазоне, становится главным. Если адрес
узла занимает первую позицию в диапазоне, то для него невозможно выбрать лидера,
и он будет находится на вершине иерархии вплоть до выхода из строя. Несмотря на
то что идентификацию узлов на основе их IP-адресов легко реализовать в
программе, такой подход устанавливает искусственную зависимость роли главного
узла от IP-адреса. Тем не менее, этот подход полезен для первичного объединения
узлов в кластер, когда более сложные методы идентификации узлов неприменимы.

Для того чтобы алгоритм субординации масштабировался на большое количество
узлов, структуру диапазона адресов подсети необходимо сделать древовидной. В
древовидной иерархии каждый узел идентифицируется уровнем $l$ иерархии, на
котором он находится и отступом $o$, который равен порядковому номеру узла на
его уровне. Значения уровня и отступа определяются из следующей задачи
оптимизации.
\begin{equation*}
    n = \sum\limits_{i=0}^{l(n)} p^i + o(n), \quad
    l \rightarrow \min, \quad
    o \rightarrow \min, \quad
    l \geq 0, \quad
    o \geq 0
\end{equation*}
где $n$ --- позиция IP-адреса узла в диапазоне IP-адресов подсети и $p$ ---
значение ветвления (максимальное количество подчиненных, которых может иметь
узел). Лидер узла на уровне $l$ с отступом $o$ будет иметь уровень $l-1$ и
отступ $\lfloor{o/p}\rfloor$. Расстояние между любыми двумя узлами в иерархии,
адреса которых занимают позиции $i$ и $j$ в диапазоне определяется как
\begin{align*}
    & \langle
        \text{lsub}(l(j), l(i)), \quad
        \left| o(j) - o(i)/p \right|
    \rangle,\\
    & \text{lsub}(l_1, l_2) =
    \begin{cases}
        \infty & \quad \text{if } l_1 \geq l_2, \\
        l_1 - l_2 & \quad \text{if } l_1 < l_2.
    \end{cases}
\end{align*}
Расстояние имеет составную запись, чтобы при определении близости двух узлов
уровень иерархии учитывался в первую очередь.

Для выбора лидера каждый узел ранжирует все узлы подсети в соответствии с
$\langle{l(n),o(n)}\rangle$ и, используя формулу для определения расстояния,
выбирает ближайший к потенциальному лидеру узел, имеющий наименьший ранг. Это
позволяет пропустить IP-адреса выключенных и просто несуществующих узлов, но для
разреженных сетей, в которых некоторые IP-адреса из середины списка не
закреплены за работающими узлами, сбалансированность дерева не гарантируется.

Поскольку узлу для выбора лидера нужно соединиться только с узлом, адрес
которого известен заранее, то алгоритм субординации хорошо масштабируется на
большое количество узлов. Соединение с другими узлами из ранжированного списка
происходит только в том случае, если соединение с узлом из начала списка
прерывается. Таким образом, если адреса рабочих узлов расположены плотно в
диапазоне адресов подсети, каждый узел устанавливает соединение только со своим
узлом-лидером, и ресурсоемкого и неэффективного сканирования всей сети каждым
узлом не происходит.

**** Результаты тестирования.
Платформа, на которой осуществлялось тестирование, состоит из одного
многопроцессорного узла, на котором развертывается виртуальный кластер из
заданного количества узлов с помощью пространств имен Linux. Похожий подход
используется в
cite:lantz2010network,handigol2012reproducible,heller2013reproducible, где
обосновывается целесообразность его применения для проведения экспериментов на
виртуальных кластерах и сопоставляются результаты некоторых из них с реальными
кластерами. Преимуществом данного подхода является низкие требования к
оборудованию, на котором проводятся эксперименты, а также отсутствие влияния
внешних процессов, выполняющихся параллельно с экспериментами.

Тестирование производительности заключалось в построении графика зависимости
времени, затрачиваемого на объединение узлов в кластер, от количества узлов. В
процессе эксперимента любое изменение иерархии записывалось в файл и по
прошествии 30 сек. все процессы вынужденно останавливались системой. Пробные
запуски показали, что одновременный запуск более 100 виртуальных узлов искажал
результаты, поэтому для этого эксперимента были использованы дополнительные
физические узлы, на каждом из которых создавалось по 100 виртуальных.
Эксперимент показал, что объединение от 100 до 400 узлов в кластер занимает в
среднем 1,5 секунды (см. [[fig:bootstrap-local]]). Для полностью физического
кластера это значение может увеличиться. Пример древовидной иерархии, полученной
при запуске на 11 узлах представлен на [[fig:tree-hierarchy-11]].

#+name: fig:bootstrap-local
#+begin_src R
# TODO
#+end_src

#+caption: Зависимость времени объединения узлов в кластер в зависимости от их количества.
#+RESULTS: fig:bootstrap-local

#+name: fig:tree-hierarchy-11
#+begin_src R
# TODO
#+end_src

#+caption: Древовидная иерархия для 11 узлов.
#+RESULTS: fig:tree-hierarchy-11

*** Алгоритм восстановления после сбоев
**** Введение.
Отказы узлов распределенной системы можно разделить на три типа: отказ
подчиненного узла, отказ главного узла и отказ одновременно всех узлов
(отключение электричества). Для того чтобы запущенная на кластере задача могла
продолжиться после отказа подчиненного узла, для нее периодически создаются и
записываются в надежное хранилище контрольные точки восстановления. При
создании контрольной точки все параллельные процессы задачи временно
останавливаются, образ памяти, выделенной операционной системой для процессов
задачи копируется на диск, и выполнение задачи продолжается в нормальном
режиме. Для того чтобы отказ главного узла не повлиял на работу кластера,
состояние сервисов, запущенных на нем, непрерывно копируется на резервный узел,
который становится главным при отказе. При незапланированном отключении
электричества состояние всех запущенных на момент отказа задач
восстанавливается из контрольных точек восстановления.

Оптимизации работы контрольных точек восстановления посвящено большое
количество работ cite:egwutuoha2013survey, а альтернативным подходам
уделяется меньше внимания. Обычно высокопроизводительные приложения используют
передачу сообщений для обмена данными между параллельными процессами и хранят
свое текущее состояние в глобальной памяти, поэтому не существует способа
перезапустить завершившийся процесс, не записав образ всей выделенной для него
памяти на диск. Обычно общее число процессов фиксировано и задается
планировщиком, и в случае отказа перезапускаются сразу все процессы. Существуют
некоторые обходные решения, которые позволяют перезапустить только часть
процессов cite:meyer2012radic, восстановив их на других узлах, однако это
может привести к перегрузке, если на этих узлах уже запущены другие задачи.
Теоретически, перезапуск процесса необязателен если задача может быть
продолжена на меньшем количестве узлов, но библиотека передачи сообщений не
позволяет изменять количество параллельных процессов во время работы программы,
и большинство программ все равно предполагают, что это значение является
константой, и используют его для распределения нагрузки между узлами. Таким
образом, не существует простого способа обеспечения отказоустойчивости на
уровне библиотеки передачи сообщений кроме как путем перезапуска всех
параллельных процессов из контрольной точки восстановления.

В то же время, существует возможность продолжить выполнение задачи на меньшем
количестве узлов, чем было изначально выделено под нее планировщиком. В этом
случае нагрузка должна быть динамически перераспределена между оставшимися
узлами. Несмотря на то что динамическое распределение нагрузки было реализовано
в поверх библиотеки передачи сообщений в ряде
работ cite:bhandarkar2001adaptive,lusk2010more, оно никогда не применялось в
задаче обеспечения отказоустойчивости. В этом разделе исследуются методы
обеспечения отказоустойчивости при выходе из строя подчиненных и главных узлов
и показывается, как приемы объектно-ориентированного программирования могут
быть использованы для сохранения минимального состояния программы, необходимого
для ее перезапуска, в иерархии объектов, а не в глобальных и локальных
переменных.

**** Иерархия объектов вычисления.
Для распределения нагрузки узлы кластера объединяются в
древовидную иерархию. Нагрузка распределяется между непосредственными соседями
узла, так что  при запуске задачи на подчиненном узле главный узел также
получают часть нагрузки. Это делает систему симметричной и легкой в
обслуживании: на каждом узле установлен один и тот же набор программного
обеспечения, что позволяет заменить один узел другим при выходе из строя
первого. Похожее архитектурное решение используется в хранилищах типа
"ключ-значение" cite:anderson2010couchdb,lakshman2010cassandra для
обеспечения отказоустойчивости при выходе из строя одного из узлов, однако
автору неизвестны планировщики задач, которые используют данный подход.

Каждая программа, запущенная поверх иерархии узлов состоит из
/вычислительных объектов/ --- объектов, которых содержат данные и код для
их обработки. Для эффективного использования параллелизма, предоставляемого
кластером и многопроцессорной машиной, объект может создать подчиненные
(дочерние) объекты, которые система автоматически распределит сначала между
доступными процессорными ядрами, затем между подчиненными узлами кластера. Сама
программа также является вычислительным объектом, который либо решает
прикладную задачу последовательно, либо создает подчиненные объекты для
параллельного решения.

В отличие от функции ~main~ в программах на основе библиотеки передачи
сообщений, первый вычислительный объект выполняется только на одном узле, а
дополнительные узлы используются либо при переполнении очереди объектов
текущего узла, либо при явном указании в коде программы. Такая архитектура
позволяет использовать произвольное количество узлов для запуска задачи и
динамически менять это количество во время ее выполнения. Похожий принцип
выполнения задач используется в системах обработки больших объемов
данных cite:dean2008mapreduce,vavilapalli2013yarn --- при запуске задаче не
требуется указывать количество узлов, вместо этого система сама выбирает узлы,
на которых будет выполняться задача, в зависимости физического расположения
входных файлов.

С математической точки зрения вычислительный объект $K$ может быть определен
как векторнозначный функционал, отображающий один вычислительный объект на
\(n\)-компонентный вектор вычислительных объектов:
\begin{equation*}
    K(f): \mathbb{K} \rightarrow \mathbb{K}^n
    \qquad
    \mathbb{K}^n = \left\{ f: \mathbb{K} \rightarrow \mathbb{K}^n \right\}.
\end{equation*}
Специальный объект $\mathbb{O}: \mathbb{K} \rightarrow \mathbb{K}^0$
используется для остановки рекурсии, и передается в качестве аргумента главному
(первому созданному) объекту программы. Аргумент функционала интерпретируется
следующим образом.
- Если текущий объект является только что созданным объектом, то аргумент
  функционала --- это главенствующий над ним объект (родитель).
- Если текущий объект является родителем объекта, который его породил или
  родителем какого-либо другого объекта, то аргумент функционала --- объект,
  которые его породил.

Объекты обрабатываются в цикле, который начинается с вызова функции главного
объекта программы, затем вызываются функции всех порожденных им объектов. Цикл
продолжается до тех пор пока функция какого-либо объекта не вернет
$\mathbb{O}$. Поскольку вызов функции может породить сразу несколько объектов,
они выполняются параллельно, что приводит к быстрому заполнению пула объектов,
которые можно выполнять в произвольном порядке. Несколько потоков одновременно
выбирают из пула объекты для обработки, и при переполнении пула объекты могут
быть переданы на другие узлы кластера без явного указания в исходном коде
программы.

Вычислительные объекты реализованы в виде замыканий (функторов) ---
объектов-функций, которые сохраняют в себе аргументы, ссылку на породивший их
объект и данные из предметной области задачи. Данные обрабатываются либо при
выполнении объекта, либо для параллельной обработки создаются дочерние объекты.
Когда обработка завершена, родительский объект вызывается с дочерним объектов в
качестве аргумента для сбора результатов обработки.

**** Выход из строя одного узла.
Наиболее распространенная стратегия при выходе из строя подчиненного узла ---
перезапуск выполнявшихся на нем объектов на рабочих узлах. Этой стратегии
следует язык Erlang для перезапуска подчиненных
процессов cite:armstrong2003thesis. Для того что реализовать этот метод в
рамках иерархии вычислительных объектов необходимо сохранять каждый объект
передаваемый на другие узлы кластера. В случае отказа одного из узлов, на
которые были переданы объекты, соответствующие их копии извлекаются из очереди
на перераспределяются между оставшимися узлами без какой-либо дополнительной
обработки. Если больше узлов не осталось, то объекты перенаправляются в
локальную очередь. В отличие от "тяжеловесного" метода контрольных точек
восстановления, древовидная иерархия узлов в паре с иерархией объектов позволяет
автоматически продолжить выполнение программы при выходе из строя одного из
узлов без перезапуска каких-либо процессов задачи.

Возможная стратегия при выходе из строя узла, на котором хранится главный
вычислительный объект задачи, заключается в копировании этого объекта на
резервный узел и синхронизировать любые изменения между двумя копиями объекта
посредством распределенных транзакций. Однако, эта стратегия не соотносится с
асинхронностью вычислительных ядер и слишком сложна в реализации. На практике,
оказывается, что главный объект программы обычно не создает больше одного
дочернего объекта, каждый из которых представляет собой последовательный шаг
вычислений (внутри которого может быть, а может не быть параллельных этапов).
Поскольку шаги последовательны, то одновременно может существовать не более
одного дочернего объекта, что позволяет упростить синхронизацию состояния
главного объекта программы. Для этого главный объект передается на подчиненный
узел вместе со своим дочерним объектом. Тогда при выходе из строя узла, на
котором была запущена программа, резервный узел автоматически восстанавливает
состояние главного объекта из копии, когда дочерний объект завершает свою
работу.

Описанный выше подход предназначен только для объектов, у которых нет
объекта-родителя и которые создают по одному дочернему объекту за раз. Это
означает, что метод работает как контрольная точка восстановления, которая
сохраняет состояние только между последовательными шагами вычислений (когда оно
занимает минимальный объем памяти) и которая для сохранения состояния
использует оперативную память другого узла кластера, а не диск.

**** Обеспечение высокой доступности.
**** Программная реализация.
Из соображений эффективности методы обеспечения отказоустойчивости были
реализованы во фреймворке на языке C++: с точки зрения автора язык C слишком
низкоуровневый для написания распределенных программ, а использование языка
Java влечет за собой накладные расходы, и не популярно в высокопроизводительных
вычислениях. Для того чтобы использовать фреймворка без планировщика задач
необходимо создать сервис, который бы автоматически обновлял состояние
древовидной иерархии узлов и предоставлял программный интерфейс для запуска
задач на ней. На данный момент фреймворк запускает сервис и приложение в одном
процессе. Фреймворк называется "Фабрика" и находится на этапе проверки
концепции.

**** Результаты тестирования.
Методы отказоустойчивости были протестированы на физическом кластере
(см. [[tab:cluster]]) на примере программы, генерирующей взволнованную
морскую поверхность, подробно описанной
в cite:autoreg-stab,autoreg2011csit,autoreg1,autoreg2 и в данной работе.
Программа состоит из серии фильтров, каждый из которых применяется к результату
работы предыдущего. Некоторые из фильтров применяются параллельно, так что вся
программа состоит из последовательно выполняющихся больших шагов, некоторые из
которых внутри реализованы параллельно из соображений эффективности. Только
наиболее ресурсоемкий этап программы (генерация взволнованной морской
поверхности) выполняется параллельно на всех узлах, другие этапы выполняются
параллельно на всех процессорных ядрах главного узла.

#+name: tab:cluster
#+caption: Конфигурация кластера.
#+attr_latex: :booktabs t
| CPU                 | Intel Xeon E5440, 2.83GHz |
| RAM                 | 4Gb                       |
| HDD                 | ST3250310NS, 7200rpm      |
| Кол-во узлов        | 12                        |
| Кол-во ядер на узел | 8                         |

Программа была переписана под новую версию фреймворка, что потребовало лишь
небольших изменений исходного кода для корректной обработки выхода из строя
узла с главным объектом: главный объект был помечен, чтобы фреймворк смог
передать его на подчиненный узел. Другие изменения исходного кода были связаны
с изменением программного интерфейса фреймворка. Таким образом, обеспечение
отказоустойчивости, в основном, прозрачно для программиста и требует лишь
маркировки главного объекта для его репликации на резервный узел.

В ряде экспериментов производительность новой версии программы была измерена
при выходе из строя различных типов узлов во время выполнения программы (номера
пунктов соответствуют номерам графиков [[fig:benchmark]]):
- без выхода из строя узлов,
- выход из строя подчиненного узла (на котором генерируется часть взволнованной
  поверхности),
- выход из строя главного узла (на котором запускается программа),
- выход из строя резервного узла (на который копируется главный объект
  программы).
Древовидная иерархия узлов со значением ветвления равного 64 использовалась в
экспериментах, для того чтобы удостовериться, что все подчиненные узлы соединены
с первым узлом подсети кластера. При каждом запуске программы главный объект
запускался не на главном узле, чтобы оптимально отобразить иерархию объектов на
иерархию узлов (наложить одну на другую). Узел-жертва выводился из строя по
прошествии фиксированного временного интервала после запуска программы равного
примерно $1/3$ времени работы программы на одном узле. Способ запуска для
каждого эксперимента представлен в [[tab:benchmark]] ("корень" и "лист" относятся к
положению узла в древовидной иерархии). Результаты экспериментов приведены на
[[fig:benchmark]] и [[fig:slowdown]].

Графики 2 и 3 на [[fig:benchmark]] показывают, что производительность в
случае выхода из строя главного и подчиненного узлов примерно одинакова. В
случае отказа главного узла резервный узел сохраняет копию главного объекта и
восстанавливает главный объект из нее, когда не обнаруживает, что главный узел
вышел из строя. В случае отказа подчиненного узла, главный узел
перераспределяет невернувшиеся объекты между оставшимися подчиненными узлами. В
обоих случая состояние главного объекта программы не теряется, а значит не
тратится время на его восстановление, что объясняет схожую производительность.

График 4 на [[fig:benchmark]] показывает, что производительность в случае
выхода из строя резервного узла гораздо ниже, чем в других случаях. Это
происходит, потому что главный узел сохраняет состояние только текущего
последовательного этапа программы, в то время как резервный узел не только
хранит копию этого состояния, но и выполняет параллельные части этапа вместе с
другими подчиненными узлами. Так что, когда резервный узел выходит из строя,
главный узел начинает выполнение текущего этапа с самого начала.

#+caption: Параметры экспериментов.
#+name: tab:benchmark
#+attr_latex: :booktabs t
| Номер эксп. | Главный узел | Узел-жертва | Время до выхода из строя, сек. |
|           1 | корень       |             |                                |
|           2 | корень       | лист        |                             10 |
|           3 | корень       | лист        |                             10 |
|           4 | корень       | лист        |                             10 |

Для оценки количества времени, которое теряется при выходе из строя одного из
узлов, можно поделить общее время работы программы со сбоем на время работы
программы без сбоев, но с количеством узлов минус один. Это отношение
представлено на [[fig:slowdown]]. Разница в производительности в случае выхода из
строя главного узла и подчиненного узла находится в пределах 5%, а в случае
выхода из строя резервного узла --- в пределах 50% для количества узлов меньше
6[fn::Измерение разницы для большего количества узлов не имеет смысла, поскольку
программа завершается еще до наступления сбоя.]. Разница в 50% больше, чем $1/3$
времени работы программы, после которого происходит сбой, однако отказ
резервного узла требует некоторого времени, чтобы быть обнаруженным другими
узлами. Сбой узла обнаруживается только тогда, когда подчиненный объект
завершает свое выполнение и пытается вернуться на исходный узел к родителю.
Мгновенное обнаружение сбоя узла требует остановки выполнения объектов, что
может быть неприменимо для программ со сложной логикой.

#+name: fig:benchmark
#+begin_src R
# TODO
#+end_src

#+caption: Производительность программы генерации взволнованной морской поверхности при различных типах сбоев узлов.
#+RESULTS: fig:benchmark

Результаты экспериментов позволяют сделать вывод о том, что /не важно,
вышел ли из строя главный узел или подчиненный, итоговое время работы программы
будет примерно равно времени ее работы без сбоев, но с уменьшенным на единицу
количеством узлов/, однако, в случае выхода из строя резервного узла теряется
гораздо больше времени.

#+name: fig:slowdown
#+begin_src R
# TODO
#+end_src

#+caption: Замедление программы генерации взволнованной морской поверхности при различных типах сбоев по сравнению с запуском без сбоев но с уменьшенным на единицу количеством узлов.
#+RESULTS: fig:slowdown

**** Выводы по результатам тестирования.
Проведенные эксперименты показывают, что параллельной программе необходимо
иметь несколько последовательных этапов выполнения, чтобы сделать ее устойчивой
к сбоям узлов. Несмотря на то что вероятность сбоя резервного узла меньше
вероятности сбоя одного из подчиненных узлов, это не повод потерять все данные,
когда выполнявшаяся несколько дней задача почти завершилась. В общем случае,
чем больше последовательных этапов вычислений содержит программа, тем меньше
времени потеряется в случае сбоя резервного узла, и, аналогично, чем больше
параллельных частей содержит каждый этап, тем меньше времени потеряется при
сбое главного или подчиненного узла. Другими словами, /чем больше
количество узлов, на которое масштабируется программа, тем она более устойчива
к сбою оборудования/.

В проведенных экспериментах узел, на котором запускается программа, выбирается
вручную, чтобы совместить иерархию объектов и иерархию узлов, однако, такой
подход не применим в реальных системах. Разработанный фреймворк должен делать
это автоматически и эффективно распределять нагрузку между подчиненными узлами
в независимости от местоположения главного узла в иерархии: выделение одного и
того же узла в качестве главного для запуска нескольких приложений уменьшает
общую отказоустойчивость системы.

Хотя это неочевидно из экспериментов, Фабрика не только обеспечивает
отказоустойчивость, но и позволяет автоматически вводить новые узлы в кластер и
распределять на них часть нагрузки уже запущенных программ. В контексте
фреймворка этот процесс тривиален, поскольку не требует перезапуска
незавершившихся объектов и копирования их состояния, и не изучался
экспериментально в данной работе.

Теоретически отказоустойчивость, основанная на иерархии может быть реализована
поверх библиотеки передачи сообщений без потери общности. Хотя использование
незагруженных узлов заместо вышедших из строя в рамках такой библиотеки
представляет определенную сложность, поскольку количество узлов, на которых
запущена программа фиксировано, но выделение достаточно большого количества
узлов для программы будет достаточно для обеспечения отказоустойчивости.

Слабым местом описанных методов является период времени, начиная с отказа
главного узла и заканчивая обнаружением сбоя подчиненным узлом. Если до момента
восстановления главного объекта из копии резервный узел выходит из строя, то
состояние выполнения программы полностью теряется без возможности его
восстановить, кроме как перезапуском с самого начала. Длина этого опасного
промежутка времени может быть уменьшена, но исключить его полностью невозможно.
Этот результат согласуется с исследованиями теории "невыполнимости" в рамках
которой доказывается невозможность распределенного консенсуса с хотя бы одним
процессом, дающим сбой cite:fischer1985impossibility и невозможность надежной
передачи данных в случае сбоя одного из узлов cite:fekete1993impossibility.

* Заключение
**** Итоги исследования.
В изучении возможностей математического аппарата для имитационного моделирования
морского волнения, выходящего за рамки линейной теории волн, были достигнуты
следующие основные результаты.
- Разработана модель ветрового волнения для генерации волн произвольных
  амплитуд.
- Разработан гибридный метод расчета давлений в двухмерной постановке,
  использующий как аналитические выражения, так и численное интегрирование по
  алгоритму быстрого преобразования Фурье.
- Разработанный метод позволил упростить программную реализацию комплекса, и
  свести реализацию алгоритма к параллельному вычислению большого количества
  преобразований Фурье.
- Предварительная апробация авторегрессионной модели и метода расчета давлений
  была произведена в пакете Large Amplitude Motion Program 4.

**** Перспективы дальнейших исследований.
Хотя задача генерации взволнованной морской поверхности была решена в трехмерной
постановке, для задачи расчета гидродинамических давлений было найдено
аналитическое решение только в двухмерном случае. В трехмерной постановке
полученные формулы не были всесторонне исследованы. Таким образом, дальнейшие
исследования предполагают изучение аналитического решения для трехмерный случая,
а также создание виртуального полигона на основе модели АРСС и метода расчета
давлений по результатам апробации в пакете Large Amplitude Motion Program 4.

* Выводы
Результаты исследования позволяют сделать вывод о том, что задача вычисления
давлений под реальной морской поверхностью может быть решена аналитически в
двухмерной постановке, минуя предположения линейной теории волн и теории волн
малой амплитуды. Это аналитическое решение в паре с моделью АРСС ветрового
волнения, способной генерировать волны произвольных амплитуд, может быть
использовано для расчета влияния колебаний волн на поведение динамического
объекта в открытом море, и дает более точные результаты чем аналогичное решение
для волн малых амплитуд. Результаты проведенных экспериментов позволяют сделать
вывод о том, что как генерация взволнованной поверхности так и расчет
гидродинамических давлений могут быть реализованы эффективно с использованием
алгоритмов быстрого преобразования Фурье, а распределенная система научных
расчетов может быть использвана для длительных сессий имитационного
моделирования. Разработанный в работе математический аппарат и его программная
реализация могут стать основой виртуального полигона, предназанченного для
расчетов динамики морских объектов.

* Благодарности
Графики в этой работе были подготовлены с помощью языка для статистических
вычислений R cite:rlang2016,Sarkar2008lattice и программного обеспечения
Graphviz cite:Gansner00anopen. Документ был подготовлен с использованием
Org-mode cite:Schulte2011org2,Schulte2011org1,Dominik2010org для GNU Emacs, предоставляющего вычислительное окружение для
воспроизводимых исследований. Это означает, что все графики можно воспроизвести
и соответствующие утверждения проверить, скопировав репозиторий
диссертации[fn:repo], установив Emacs и экспортировав документ.

* Список сокращений и условных обозначений
- <<<MPP>>> :: Massively Parallel Processing, класс вычислительных систем с разделенной памятью.
- <<<SMP>>> :: Symmetric Multi-Processing, класс вычислительных систем с общей памятью.
- <<<АКФ>>> :: автоковариационная функция.
- <<<БПФ>>> :: быстрое преобразование Фурье.
- <<<ГПСЧ>>> :: генератор псевдослучайных чисел.
- <<<ГУ>>> :: граничное условие.
- <<<ДУЧП>>> :: дифференциальное уравнение в частных производных.
- <<<НБП>>> :: нелинейное безынерционное преобразование.
- <<<АР>>> :: процесс авторегрессии.
- <<<АРСС>>> :: процесс авторегрессии скользящего среднего.
- <<<СС>>> :: процесс скользящего среднего.
- <<<ЛХ>>> :: модель Лонге---Хиггинса.
- <<<LAMP>>> :: Large Amplitude Motion Programme, программа для моделирования качки судна на морских волнах.
- <<<ЦПТ>>> :: центральная предельная теорема.
- <<<ПМ>>> :: аппроксимация Пирсона---Московица для спектра морского волнения.
- <<<ЮУ>>> :: система уравнений Юла---Уокера.
- <<<МНК>>> :: метод наименьших квадратов.
- <<<ФПР>>> :: функция плотности распределения.
- <<<ФР>>> :: функция распределения.
- <<<BSP>>> :: Bulk Synchronous Parallel.
- <<<OpenCL>>> :: Open Computing Language.
- <<<OpenMP>>> :: Open Multi-Processing.
- <<<MPI>>> :: Message Passing Interface.
- <<<POSIX>>> :: Portable Operating System.
- <<<FMA>>> :: Fused multiply-add.
- <<<DCMT>>> :: Dynamic creation of Mersenne Twisters.
- <<<GSL>>> :: GNU Scientific Library.
- <<<BLAS>>> :: Basic Linear Algebra Sub-programmes.
- <<<LAPACK>>> :: Linear Algebra Package.
- <<<DNS>>> :: Dynamic name resolution.

#+begin_export latex
\input{postamble}
#+end_export

bibliographystyle:ugost2008
bibliography:bib/refs.bib

* Приложение
** TODO Вывод формулы модели Лонге---Хиггинса
