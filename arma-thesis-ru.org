#+TITLE: Имитационное моделирование нерегулярного волнения для программ динамики морских объектов
#+AUTHOR: Иван Ганкевич
#+DATE: Санкт-Петербург, 2017
#+LANGUAGE: ru
#+SETUPFILE: setup.org
#+LATEX_HEADER_EXTRA: \organization{Санкт-Петербургский государственный университет}
#+LATEX_HEADER_EXTRA: \manuscript{на правах рукописи}
#+LATEX_HEADER_EXTRA: \degree{Диссертация на соискание ученой степени\\кандидата физико-математических наук}
#+LATEX_HEADER_EXTRA: \speciality{Специальность 05.13.18\\Математическое моделирование, численные методы и комплексы программ}
#+LATEX_HEADER_EXTRA: \supervisor{Научный руководитель\\д.т.н Дегтярев Александр Борисович}
#+LATEX_HEADER_EXTRA: \newcites{published}{Список опубликованных по теме диссертации работ}

* Введение
**** Актуальность темы.
Программы, моделирующие поведение судна на морских волнах, широко применяются
для расчета качки судна, оценки величины воздействия внешних сил на плавучую
платформу или другой морской объект, а также для оценки вероятности
опрокидывания судна при заданных погодных условиях; однако, большинство из них
используют линейную теорию для моделирования морского
волнения\nbsp{}cite:shin2003nonlinear,van2007forensic,kat2001prediction,van2002development,
в рамках которой сложно воспроизвести определенные особенности ветро-волнового
климата. Среди них можно выделить переход от нормальных погодных условий к
шторму и волнение, вызванное наложением множества систем ветровых волн и волн
зыби, распространяющихся в нескольких направлениях. Другой недостаток линейной
теории волн заключается в предположении, что высота волн много меньше их длины.
Это делает расчеты грубыми при моделировании качки судна в условиях
нерегулярного волнения, когда такое предположение несправедливо. Разработка
новых и более совершенных моделей и методов, используемых в программах расчета
динамики судна, может увеличить количество сценариев применения таких программ
и, в частности, способствовать исследованию поведения судна в экстремальных
условиях.

**** Степень разработанности.
Модель авторегрессии скользящего среднего (АРСС) возникла как ответ на
сложности, с которыми на практике сталкиваются ученые, использующие в своей
работе модели морского волнения, разработанные в рамках линейной теории волн.
Проблемы, с которыми они сталкиваются при использовании модели Лонге---Хиггинса
(которая полностью основана на линейной теории волн) перечислены ниже.
1. /Периодичность/. В рамках линейной теории волны аппроксимируются суммой
   гармоник, а период реализации взволнованной поверхности зависит от их
   количества. Чем больше размер реализации, тем больше коэффициентов требуется
   для исключения периодичности, поэтому с увеличением размера реализации время
   ее генерации растет нелинейно. Это приводит к тому, что любая модель,
   основанная на линейной теории, неэффективна при генерации больших реализаций
   взволнованной поверхности, независимо от того, насколько оптимизирован
   исходный код программы.
2. /Линейность/. В рамках линейной теории волн дается математическое определение
   морским волнам в предположении малости их амплитуд по сравнению с длинами.
   Такие волны, в основном, характерны для открытого океана, а волны в
   прибрежных районах и штормовые волны, для которых это предположение
   несправедливо, грубо описываются в рамках линейной теории.
3. /Вероятностная сходимость/. Фаза волны, значение которой обычно получается с
   помощью генератора псевдослучайных чисел (ГПСЧ), имеет равномерное
   распределение, что иногда приводит к медленной сходимости интегральных
   характеристик взволнованной поверхности (таких как распределение высот волн,
   их периодов, длин и т.п.). Скорость сходимости зависит от значений,
   полученных от ГПСЧ, поэтому быстрая сходимость не гарантируется.

Эти сложности стали отправной точкой в поиске модели, не основанной на линейной
теории волн, и в исследованиях процесса АРСС был найден необходимый
математический аппарат.
1. Параметром процесса АРСС является автоковариационная функция (АКФ), которая
   может быть напрямую получена из энергетического или частотно-направленного
   спектра морского волнения (который, в свою очередь является входным
   параметром для модели Лонге---Хиггинса). Так что входные параметры одной
   модели могут быть легко преобразованы во входные параметры другой.
2. Процесс АРСС не имеет ограничение на амплитуду генерируемых волн: их крутизна
   может быть увеличена на столько, на сколько это позволяет АКФ реальных
   морских волн.
3. Период реализации равен периоду ГПСЧ, поэтому время генерации растет линейно
   с увеличением размера реализации.
4. Белый шум, который является единственным вероятностным членом формулы
   процесса АРСС, имеет нормальное распределение; так что скорость сходимости не
   носит вероятностный характер.

**** Цели и задачи.
Процесс АРСС является основой модели ветрового волнения АРСС, однако он
нуждается в доработке перед тем, как его можно использовать на практике.
1. Исследовать, как различные формы АКФ влияют на выбор параметров процесса АРСС
   (количество коэффициентов процесса скользящего среднего и процесса
   авторегрессии).
2. Исследовать возможность генерации волн с произвольным профилем, а не только с
   профилем синусоиды (учесть асимметричность распределения волновых аппликат
   взволнованной поверхности).
3. Разработать метод для определения поля давлений под дискретно заданной
   взволнованной поверхностью. Такие формулы обычно выводятся для конкретной
   модели путем подстановки формулы профиля волны в\nbsp{}eqref:eq-problem,
   однако процесс АРСС не содержит в себе формулу профиля волны в явном виде,
   поэтому для него необходимо получить решение для взволнованной поверхности
   общего вида (для которой не существует аналитического выражения) без
   линеаризации граничных условий (ГУ) и предположении о малости амплитуд волн.
4. Верифицировать интегральные характеристики взволнованной поверхности
   на соответствие реальным морским волнам.
5. Разработать комплекс программ, реализующий созданную модель и метод расчета
   давлений и позволяющий проводить расчеты как на многопроцессорной машине с
   общей памятью (SMP), так и на компьютерном кластере (MPP).

**** Научная новизна.
Модель АРСС в отличие от других моделей ветрового волнения не основана на
линейной теории волн, что позволяет
- генерировать волны произвольной амплитуды, регулируя крутизну посредством АКФ;
- генерировать волны произвольной формы, регулируя асимметричность распределения
  волновых аппликат посредством нелинейного безынерционного преобразования
  (НБП).
В то же время математический аппарат процесса АРСС хорошо изучен в других
научных областях, что позволяет его обобщить для моделирования развития морского
волнения в условиях шторма с учетом климатических спектров и данных ассимиляции
определенных районов мирового океана, что невозможно сделать с помощью модели,
основанной на линейной теории волн.

Отличительной особенностью данной работы является использование во всех
экспериментах /трехмерных/ моделей АР и СС и разработка комплекса программ,
реализующего генерацию взволнованной морской поверхности и вычисления поля
давлений на системах с общей (SMP) и распределенной (MPP) памятью, а также
гибридных (GPGPU) системах, использующих графические сопроцессоры для ускорения
вычислений.

**** Теоретическая и практическая значимость работы.
Применение модели АРСС и формулы поля давлений, не использующей предположения
линейной теории волн, качественно повысит работу комплексов программ для расчета
воздействия океанских волн на морские объекты.

1. Поскольку метод для поля давлений выводится для дискретно заданной
   взволнованной поверхности и без каких-либо предположений об амплитудах волн,
   то он применим для любой взволнованной поверхности невязкой несжимаемой
   жидкости (в частности он применим для поверхности, генерируемой моделью
   Лонге---Хиггинса). Это позволяет использовать этот метод без привязки к
   модели АРСС.
2. С вычислительной точки зрения этот метод более эффективен, чем
   соответствующий метод для модели ЛХ, поскольку интегралы в формуле сводятся к
   преобразованиям Фурье, для которых существует семейство алгоритмов быстрого
   преобразования Фурье (БПФ), оптимизированных под разные архитектуры
   процессоров.
3. Поскольку используемая в методе формула явная, то обмена данными между
   параллельными процессами можно избежать, что позволяет достичь высокой
   масштабируемости на компьютерном кластере.
4. Наконец, сама модель АРСС более эффективна, чем модель ЛХ, ввиду отсутствия
   тригонометрических функций в ее формуле. Взволнованная поверхность
   вычисляется как сумма большого числа многочленов, для которых существует
   низкоуровневая ассемблерная инструкция FMA (Fused Multiply-Add), а шаблон
   доступа к памяти позволяет эффективно использовать кэш центрального
   процессора.

**** Методология и методы исследования.
Программная реализация модели АРСС и метода вычисления поля давлений создавалась
поэтапно: прототип, написанный на высокоуровневом инженерных языках
(Mathematica\nbsp{}cite:mathematica10 и Octave\nbsp{}cite:octave2015), был
преобразован в программу на языке более низкого уровня (C++). Реализация одних и
тех же алгоритмов и методов на языках разного уровня (ввиду использования
различных абстракций и языковых примитивов) позволяет выявить и исправить
ошибки, которые остались бы незамеченными в случае использования лишь одного
языка. Генерируемая моделью АРСС взволнованная поверхность, а также все входные
параметры (АКФ, формула распределения волновых аппликат и т.п.) были проверены с
помощью встроенных в язык программирования графических средств для визуального
контроля корректности работы программы.

**** Положения, выносимые на защиту.
- Имитационная модель морского волнения, способная генерировать реализации
  взволнованной морской поверхности, имеющие большой период и состоящие из волн
  произвольной амплитуды;
- Метод вычисления поля давлений, разработанный для этой модели без
  предположений линейной теории волн;
- Программная реализация созданной модели и метода для вычислительных систем с
  общей (SMP) и распределенной памятью (MPP).

**** Степень достоверности и апробация результатов.
Верификация модели АРСС проводится путем сравнения интегральных характеристик
(распределений волновых аппликат, высот и длин волн и т.п.) генерируемой
взволнованной поверхности с характеристиками реальных морских волн. Метод
вычисления поля давлений был разработан с помощью языка Mathematica, в котором
полученные выражения проверяются с помощью встроенных в язык графических
средств.

Модель АРСС и метод вычислений поля давлений были реализованы в Large Amplitude
Motion Programme (LAMP), программе для моделирования качки судна, и сопоставлены
с используемой ранее моделью ЛХ. Численные эксперименты показали более высокую
вычислительную эффективность модели АРСС.

* Постановка задачи
Задача состоит в исследовании возможности применении математического аппарата
процесса АРСС для моделирования морских волн и в выводе формулы для поля
давлений под генерируемой взволнованной морской поверхностью для случая
идеальной несжимаемой жидкости без предположений линейной теории волн.
- Для случая волн малых амплитуд полученная формула должна быть сопоставимо с
  соответствующей формулой линейной теории волн; для остальных случаев формула
  не должна расходиться.
- Интегральные характеристики генерируемой взволнованной поверхности должны
  совпадать с характеристиками реальных морских волн.
- Программная реализация модели АРСС и формулы вычисления давлений должна
  работать на системах с общей (SMP) и распределенной памятью (MPP).

**** Формула для поля давлений.
Задача определения поля давлений под взволнованной морской поверхностью
представляет собой обратную задачу гидродинамики для несжимаемой невязкой
жидкости. Система уравнений для нее в общем виде записывается
как\nbsp{}cite:kochin1966theoretical
\begin{align}
    & \nabla^2\phi = 0,\nonumber\\
    & \phi_t+\frac{1}{2} |\vec{\upsilon}|^2 + g\zeta=-\frac{p}{\rho}, & \text{на }z=\zeta(x,y,t),\label{eq-problem}\\
    & D\zeta = \nabla \phi \cdot \vec{n}, & \text{на }z=\zeta(x,y,t),\nonumber
\end{align}
где \(\phi\)\nbsp{}--- потенциал скорости, \(\zeta\)\nbsp{}--- подъем (аппликата)
взволнованной поверхности, \(p\)\nbsp{}--- давление жидкости, \(\rho\)\nbsp{}--- плотность
жидкости, \(\vec{\upsilon}=(\phi_x,\phi_y,\phi_z)\)\nbsp{}--- вектор скорости, \(g\)\nbsp{}--- ускорение свободного падения и \(D\)\nbsp{}--- субстанциональная производная
(производная Лагранжа). Первое уравнение является уравнением неразрывности
(уравнение Лапласа), второе\nbsp{}--- законом сохранения импульса (которое иногда
называют динамическим граничным условием); третье уравнение\nbsp{}--- кинематическое
граничное условие, которое сводится к равенству скорости перемещения этой
поверхности (\(D\zeta\)) нормальной составляющей скорости жидкости
(\(\nabla\phi\cdot\vec{n}\), см.\nbsp{}разд.\nbsp{}[[#directional-derivative]]).

Обратная задача гидродинамики заключается в решении этой системы уравнений
относительно \(\phi\). В такой постановке динамическое ГУ становится явной
формулой для определения поля давлений по значениям производных потенциалов
скорости, полученных из оставшихся уравнений. Таким образом, с математической
точки зрения обратная задача гидродинамики сводится к решению уравнения Лапласа
со смешанным ГУ\nbsp{}--- задаче Робена.

Обратная задача возможна, поскольку модель АРСС генерирует гидродинамически
адекватную взволнованную морскую поверхность: распределения интегральных
характеристик и дисперсионное соотношение соответствуют реальным
волнам\nbsp{}cite:boukhanovsky1997thesis,degtyarev2011modelling.

* Модель АРСС в задаче имитационного моделирования морского волнения
** Анализ моделей морского волнения
Вычисление давлений возможно только при условии знания формы взволнованной
поверхности, которая задается либо дискретно в каждой точке пространственной
сетки, либо непрерывно с помощью аналитической формулы. Как будет показано в
разделе [[#linearisation]], знание такой формулы может упростить вычисление
давлений, фактически сведя задачу к генерации поля давлений, а не самой
взволнованной поверхности.

**** Модель Лонге---Хиггинса.
Наиболее простой моделью, формула которой выводится в рамках линейной теории
волн (см.\nbsp{}разд.\nbsp{}[[#longuet-higgins-derivation]]), является модель
Лонге---Хиггинса (ЛХ)\nbsp{}cite:longuet1957statistical. Подробный сравнительный
анализ этой модели и модели АРСС проведен в
работах\nbsp{}cite:degtyarev2011modelling,boukhanovsky1997thesis.

Модель ЛХ представляет взволнованную морскую поверхность в виде суперпозиции
элементарных гармонических волн случайных амплитуд \(c_n\) и фаз \(\epsilon_n\),
непрерывно распределенных на интервале \([0,2\pi]\). Подъем (координата \(z\))
поверхности определяется формулой
#+name: eq-longuet-higgins
\begin{equation}
    \zeta(x,y,t) = \sum\limits_n c_n \cos(u_n x + v_n y - \omega_n t + \epsilon_n).
\end{equation}
Здесь волновые числа \((u_n,v_n)\) непрерывно распределены на плоскости \((u,v)\),
т.е. площадка \(du \times dv\) содержит бесконечно большое количество волновых
чисел. Частота связана с волновыми числами дисперсионным соотношением
\(\omega_n=\omega(u_n,v_n)\). Функция \(\zeta(x,y,t)\) является трехмерным
эргодическим стационарным однородным гауссовым процессом, определяемым
соотношением
\begin{equation*}
    2E_\zeta(u,v)\, du\,  dv = \sum\limits_n c_n^2,
\end{equation*}
где \(E_\zeta(u,v)\)\nbsp{}--- двумерная спектральная плотность энергии волн.
Коэффициенты \(c_n\) определяются из энергетического спектра волнения \(S(\omega)\)
по формуле
\begin{equation*}
    c_n = \sqrt{ \textstyle\int\limits_{\omega_n}^{\omega_{n+1}} S(\omega) d\omega}.
\end{equation*}

**** Основные недостатки модели Лонге---Хиггинса.
Модель Лонге---Хиггинса отличается простотой численного алгоритма и
наглядностью, однако, на практике она обладает рядом недостатков.

1. Модель рассчитана на представление стационарного гауссова поля. Это является
   следствием центральной предельной теоремы (ЦПТ): сумма большого числа
   гармоник со случайными амплитудами и фазами имеет нормальное распределение в
   независимости от спектра, подаваемого на вход модели. Использование меньшего
   количества коэффициентов может решить проблему, но также уменьшит период
   реализации. Таким образом, использование модели ЛХ для генерации волн с
   негауссовым распределением аппликат (которое имеют реальные морские
   волны\nbsp{}cite:huang1980experimental,rozhkov1996theory) не реализуемо на
   практике.
2. С вычислительной точки зрения, недостатком модели является нелинейный рост
   времени генерации поверхности с увеличением размера реализации. Чем больше
   размер реализации, тем больше коэффициентов (дискретных точек
   частотно-направленного спектра) требуется для исключения периодичности. Это
   делает модель неэффективной для проведения длительных численных
   экспериментов.
3. Наконец, с инженерной точки зрения, модель обладает рядом особенностей,
   которые не позволяют использовать ее в качестве фундамента для построения
   более совершенных моделей.
   - В программной реализации скорость сходимости выражения
     ур.\nbsp{}[[eq-longuet-higgins]] может быть низкой, т.к. фазы \(\epsilon_n\)
     имеют вероятностный характер.
   - Обобщение модели для негауссовых и нелинейных процессов возможно при
     включении нелинейных членов в ур.\nbsp{}[[eq-longuet-higgins]], для которого не
     известна формула вычисления
     коэффициентов\nbsp{}cite:rozhkov1990stochastic.

Таким образом, модель ЛХ применима для решения задачи генерации взволнованной
морской поверхности только в рамках линейной теории волн, неэффективна для
длительных экспериментов и имеет ряд недостатков, не позволяющих использовать ее
в качестве основы для построения более совершенных моделей.

**** Модель АРСС.
В\nbsp{}cite:spanos1982arma модель АРСС используется для генерации временного
ряда, спектр которого совпадает с аппроксимацией Пирсона---Московица для
спектров морского волнения. Авторы проводят эксперименты для одномерных моделей
АР, СС и АРСС. Они отмечают превосходное совпадение полученного и исходного
спектров и более высокую вычислительную эффективность модели АРСС по сравнению с
моделями, основанными на суммировании большого числа гармоник со случайными
фазами. Также отмечается, что для того чтобы спектр полученного временного ряда
совпадал с заданным, модели СС требуется меньшее количество коэффициентов, чем
модели АР. В\nbsp{}cite:spanos1996efficient автор обобщает формулы для
нахождения коэффициентов модели АРСС для случая нескольких (векторов)
переменных.

Отличие данной работы от вышеперечисленных отличается в исследовании трехмерной
модели АРСС (два пространственных и одно временное измерение), что во многом
является другой задачей.
1. Система уравнений Юла---Уокера, используемая для определения коэффициентов
   АР, имеет более сложную блочно-блочную структуру.
2. Оптимальный (для совпадения заданного и исходного спектров) порядок модели
   определяется вручную.
3. Вместо аппроксимации ПМ в качестве входа модели используются аналитические
   выражения для АКФ стоячих и прогрессивных волн.
4. Трехмерная взволнованная поверхность должна быть сопоставима с реальной
   морской поверхностью не только по спектральным характеристикам, но и по форме
   волновых профилей, поэтому верификация модели производится и для
   распределений различных параметров генерируемых волн (длин, высот, периодов и
   др.).
Многомерность исследуемой модели не только усложняет задачу, но и позволяет
провести визуальную проверку генерируемой взволнованной поверхности. Именно
возможность визуализировать результат работы программы позволила удостовериться,
что генерируемая поверхность действительно похожа на реальное морское волнение,
а не является абстрактным многомерным случайным процессом, совпадающим с
реальным лишь статистически.

В\nbsp{}cite:fusco2010short модель АР используется для прогнозирования волн зыби
для управления преобразователем энергии волн (ПЭВ) в реальном времени. Для
эффективной работы ПЭВ необходимо чтобы частота встроенного осциллятора
совпадала с частотой морских волн. Авторы статьи представляют подъем волны как
временной ряд и сравнивают эффективность модели АР, нейронных сеть и циклических
моделей в прогнозировании будущих значения ряда. Модель АР дает наиболее точный
прогноз для низкочастотных волн зыби вплоть до двух типовых периодов волн. Это
пример успешного применения модели процесса АР для моделирования морских волн.

** Основные формулы трехмерного процесса АРСС
Модель АРСС для морского волнения определяет взволнованную морскую поверхность
как трехмерный (два пространственных и одно временное измерение) процесс
авторегрессии скользящего среднего: каждая точка взволнованной поверхности
представляется в виде взвешенной суммы предыдущих по времени и пространству
точек и взвешенной суммы предыдущих по времени и пространству нормально
распределенных случайных импульсов. Основным уравнением для трехмерного процесса
АРСС является
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j} \zeta_{\vec i - \vec j}
    +
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j} \epsilon_{\vec i - \vec j}
    ,
    \label{eq-arma-process}
\end{equation}
где \(\zeta\)\nbsp{}--- подъем (аппликата) взволнованной поверхности,
\(\Phi\)\nbsp{}--- коэффициенты процесса АР, \(\Theta\)\nbsp{}--- коэффициенты
процесса СС, \(\epsilon\)\nbsp{}--- белый шум, имеющий Гауссово распределение,
\(\vec{N}\)\nbsp{}--- порядок процесса АР, \(\vec{M}\)\nbsp{}--- порядок
процесса СС, причем \(\Phi_{\vec{0}}\equiv0\), \(\Theta_{\vec{0}}\equiv0\).
Здесь стрелки обозначают многокомпонентные индексы, содержащие отдельную
компоненту для каждого измерения. В общем случае в качестве компонент могут
выступать любые скалярные величины (температура, соленость, концентрация
какого-либо раствора в воде и т.п.). Параметрами уравнения служат коэффициенты и
порядки процессов АР и СС.

Модель ветрового волнения выводится для воспроизведения реалистичных реализаций
ветро-волнового поля и пригодна для использования в расчетах динамики судна.
Свойства стационарности и обратимости являются основными критериями выбора того
или иного процесса для моделирования волн разных профилей, которые обсуждаются в
разд.\nbsp{}[[#sec-process-selection]].

**** Процесс авторегрессии (АР).
Процесс АР\nbsp{}--- это процесс АРСС только лишь с одним случайным импульсом вместо их
взвешенной суммы:
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j} \zeta_{\vec i - \vec j}
    +
    \epsilon_{i,j,k}
    .
    \label{eq-ar-process}
\end{equation}
Коэффициенты авторегрессии \(\Phi\) определяются из многомерных уравнений
Юла---Уокера, получаемых после домножения на \(\zeta_{\vec{i}-\vec{k}}\) обеих
частей уравнения и взятия математического ожидания. В общем виде уравнения
Юла---Уокера записываются как
\begin{equation}
    \label{eq-yule-walker}
    \gamma_{\vec k}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j}
    \text{ }\gamma_{\vec{k}-\vec{j}}
    +
    \Var{\epsilon} \delta_{\vec{k}},
    \qquad
    \delta_{\vec{k}} =
    \begin{cases}
        1, \quad \text{if } \vec{k}=0 \\
        0, \quad \text{if } \vec{k}\neq0,
    \end{cases}
\end{equation}
где \(\gamma\)\nbsp{}--- АКФ процесса \(\zeta\), \(\Var{\epsilon}\)\nbsp{}--- дисперсия
белого шума. Матричная форма трехмерной системы уравнений Юла---Уокера,
используемой в данной работе, имеет следующий вид.
\begin{equation*}
    \Gamma
    \left[
        \begin{array}{l}
            \Phi_{\vec 0}\\
            \Phi_{0,0,1}\\
            \vdotswithin{\Phi_{\vec 0}}\\
            \Phi_{\vec N}
        \end{array}
    \right]
    =
    \left[
        \begin{array}{l}
            \gamma_{0,0,0}-\Var{\epsilon}\\
            \gamma_{0,0,1}\\
            \vdotswithin{\gamma_{\vec 0}}\\
            \gamma_{\vec N}
        \end{array}
    \right],
    \qquad
    \Gamma=
    \left[
        \begin{array}{llll}
            \Gamma_0 & \Gamma_1 & \cdots & \Gamma_{N_1} \\
            \Gamma_1 & \Gamma_0 & \ddots & \vdotswithin{\Gamma_0} \\
            \vdotswithin{\Gamma_0} & \ddots & \ddots & \Gamma_1 \\
            \Gamma_{N_1} & \cdots & \Gamma_1 & \Gamma_0
        \end{array}
    \right],
\end{equation*}
где \(\vec N = \left( N_1, N_2, N_3 \right)\) и
\begin{equation*}
    \Gamma_i =
    \left[
    \begin{array}{llll}
        \Gamma^0_i & \Gamma^1_i & \cdots & \Gamma^{N_2}_i \\
        \Gamma^1_i & \Gamma^0_i & \ddots & \vdotswithin{\Gamma^0_i} \\
        \vdotswithin{\Gamma^0_i} & \ddots & \ddots & \Gamma^1_i \\
        \Gamma^{N_2}_i & \cdots & \Gamma^1_i & \Gamma^0_i
    \end{array}
    \right]
    \qquad
    \Gamma_i^j=
    \left[
    \begin{array}{llll}
        \gamma_{i,j,0} & \gamma_{i,j,1} & \cdots & \gamma_{i,j,N_3} \\
        \gamma_{i,j,1} & \gamma_{i,j,0} & \ddots &x \vdotswithin{\gamma_{i,j,0}} \\
        \vdotswithin{\gamma_{i,j,0}} & \ddots & \ddots & \gamma_{i,j,1} \\
        \gamma_{i,j,N_3} & \cdots & \gamma_{i,j,1} & \gamma_{i,j,0}
    \end{array}
    \right],
\end{equation*}
Поскольку по определению \(\Phi_{\vec 0}\equiv0\), то первую строку и столбец
матрицы \(\Gamma\) можно отбросить. Матрица \(\Gamma\), как и оставшаяся от нее
матрица, будут блочно-теплицевы, положительно определены и симметричны, поэтому
систему уравнений Юла---Уокера можно эффективно решить методом Холецкого,
специально предназначенного для таких матриц.

После нахождения решения системы уравнений дисперсия белого шума определяется из
уравнения\nbsp{}eqref:eq-yule-walker при \(\vec k = \vec 0\) как
\begin{equation*}
    \Var{\epsilon} =
    \Var{\zeta}
    -
    \sum\limits_{\vec j = \vec 0}^{\vec N}
    \Phi_{\vec j}
    \text{ }\gamma_{\vec{j}}.
\end{equation*}

**** Процесс скользящего среднего (СС).
Процесс СС\nbsp{}--- это процесс АРСС, в котором \(\Phi\equiv0\):
\begin{equation}
    \zeta_{\vec i}
    =
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j} \epsilon_{\vec i - \vec j}
    .
    \label{eq-ma-process}
\end{equation}
Коэффициенты СС \(\Theta\) определяются неявно из системы нелинейных уравнений
\begin{equation*}
  \gamma_{\vec i} =
  \left[
    \displaystyle
    \sum\limits_{\vec j = \vec i}^{\vec M}
    \Theta_{\vec j}\Theta_{\vec j - \vec i}
  \right]
  \Var{\epsilon}.
\end{equation*}
Система решается численно с помощью метода простой итерации по формуле
\begin{equation*}
  \Theta_{\vec i} =
    -\frac{\gamma_{\vec 0}}{\Var{\epsilon}}
    +
    \sum\limits_{\vec j = \vec i}^{\vec M}
    \Theta_{\vec j} \Theta_{\vec j - \vec i}.
\end{equation*}
Здесь новые значения коэффициентов \(\Theta\) вычисляются, начиная с последнего:
от \(\vec{i}=\vec{M}\) до \(\vec{i}=\vec{0}\). Дисперсия белого шума вычисляется из
\begin{equation*}
    \Var{\epsilon} = \frac{\gamma_{\vec 0}}{
    1
    +
    \sum\limits_{\vec j = \vec 0}^{\vec M}
    \Theta_{\vec j}^2
    }.
\end{equation*}
Авторы\nbsp{}cite:box1976time предлагают использовать метод Ньютона---Рафсона
для решения этого уравнения с большей точностью, однако, этот метод не подходит
для трех измерений. Использование более медленного метода не оказывает большого
эффекта на общую производительность программы, потому что количество
коэффициентов мало, и большую часть времени программа тратит на генерацию
взволнованной поверхности.

**** Стационарность и обратимость процессов АР и СС
Для того чтобы моделируемая взволнованная поверхность представляла собой
физическое явление, соответствующий процесс должен быть стационарным и
обратимым. Если процесс обратим, то существует разумная связь текущих событий с
событиями в прошлом, и, если процесс стационарен, то амплитуда моделируемого
физического сигнала не увеличивается бесконечно в пространстве и времени.

Процесс АР всегда обратим, а для стационарности необходимо, чтобы корни
характеристического уравнения
\begin{equation*}
1 - \Phi_{0,0,1} z - \Phi_{0,0,2} z^2
- \cdots
- \Phi_{\vec N} z^{N_0 N_1 N_2} = 0,
\end{equation*}
лежали \emph{вне} единичного круга. Здесь \(\vec{N}\)\nbsp{}--- порядок процесса
АР, а \(\Phi\)\nbsp{}--- коэффициенты.

Процесс СС всегда стационарен, а для обратимости необходимо, чтобы корни
характеристического уравнения
\begin{equation*}
1 - \Theta_{0,0,1} z - \Theta_{0,0,2} z^2
- \cdots
- \Theta_{\vec M} z^{M_0 M_1 M_2} = 0,
\end{equation*}
лежали \emph{вне} единичного круга. Здесь \(\vec{M}\)\nbsp{}--- порядок процесса
СС, а \(\Theta\)\nbsp{}--- коэффициенты.

**** Смешанный процесс авторегрессии скользящего среднего (АРСС).
:PROPERTIES:
:CUSTOM_ID: sec:how-to-mix-ARMA
:END:
В общем и целом, процесс АРСС получается путем подстановки сгенерированной
процессом СС взволнованной поверхности в качестве случайного импульса процесса
АР, однако, для того чтобы АКФ результирующего процесса соответствовала
заданной, необходимо предварительно скорректировать значения коэффициентов АР.
Существует несколько способов "смешивания" процессов АР и СС.
- Подход, предложенный авторами\nbsp{}cite:box1976time, который включается в
  себя разделение АКФ на часть для процесса АР и часть для процесса СС по
  каждому из измерений, не подходит в данной ситуации, поскольку в трех
  измерениях невозможно таким образом разделить АКФ: всегда останутся части,
  которые не будут учтены ни в процессе АР, ни в процессе СС.
- Альтернативный подход состоит в использование одной и той же (неразделенной)
  АКФ для обоих процессов разных порядков, однако, тогда характеристики
  реализации (математической ожидание, дисперсия и др.) будут смещены: они
  станут характеристика двух наложенных друг на друга процессов.
Для первого подхода авторами\nbsp{}cite:box1976time предложена формула
корректировки коэффициентов процесса АР, для второго же подхода такой формулы
нет. Таким образом, лучшим решением на данный момент является использование
процессов АР и СС по отдельности.

**** Критерии выбора процесса для моделирования разных профилей волн.
:PROPERTIES:
:CUSTOM_ID: sec-process-selection
:END:

Одной из проблем в применении модели АРСС для генерации взволнованной морской
поверхности является то, что для разных профилей волн /необходимо/ использовать
разные процессы: стоячие волны моделируются только процессом АР, а прогрессивные
волны\nbsp{}--- только процессом СС. Это утверждение пришло из практики: если
попытаться использовать процессы наоборот, результирующая реализация либо
расходится, либо не представляет собой реальные морские волны (такое происходит
в случае необратимого процесса СС, который всегда стационарен). Таким образом,
процесс АР может быть использован только для моделирования стоячих волн, а
процесс СС\nbsp{}--- для прогрессивных волн.

Другой проблемой является невозможность автоматического определения оптимального
количества коэффициентов для трехмерных процессов АР и СС. Для одномерных
процессов существуют итеративные методы\nbsp{}cite:box1976time, однако они
расходятся в трехмерном случае.

Последней проблемой, которая описана в разделе [[#sec:how-to-mix-ARMA]], является
невозможность "смешать" процесс АР и СС в трех измерениях.

Практика показывает, что некоторые утверждения авторов\nbsp{}cite:box1976time не
выполняются для трехмерной модели АРСС. Например, авторы утверждают, что АКФ
процесса СС обрывается на отсчете \(q\), а АКФ процесса АР затухает на
бесконечности, однако, на практике при использовании слабо затухающей и
обрывающейся на отсчете \(q\) АКФ для трехмерного процесса СС получается
необратимый процесс СС и реализация, не соответствующая реальными морским
волнам, в то время как при использовании той же самой АКФ для трехмерного
процесса АР получается стационарный обратимый процесс и адекватная реализация.
Также, авторы утверждают, что первые \(q\) точек АКФ смешанного процесса
необходимо выделить процессу СС (поскольку он обычно используется для описания
пиков АКФ) и отдать остальные точки процессу АР, однако, на практике в случае
АКФ прогрессивной волны процесс АР стационарен только для начального временного
среза АКФ, а остальные точки отдаются процессу СС.

Суммируя вышесказанное, наиболее разработанным сценарием применения модели АРСС
для генерации взволнованной морской поверхности является использование процесса
АР для стоячих волн и процесса СС для прогрессивных волн. Смешанный процесс АРСС
может сделать модель более точной при условии наличия соответствующих формул
пересчета коэффициентов, что является целью дальнейших исследований.

** Известные формулы определения поля давлений
**** Теория волн малых амплитуд.
В\nbsp{}cite:stab2012,degtyarev1998modelling,degtyarev1997analysis дается
решение обратной задачи гидродинамики для случая идеальной несжимаемой жидкости
в рамках теории волн малых амплитуд (в предположении, что длина волны много
больше ее высоты: \(\lambda \gg h\)). В этом случае обратная задача линейна и
сводится к уравнению Лапласа со смешанным граничным условием, а уравнение
движения используется только для нахождения давлений по известным значениям
производных потенциала скорости. Предположение о малости амплитуд волн означает
слабое изменение локального волнового числа во времени и пространстве по
сравнению с подъемом (аппликатой) взволнованной поверхности. Это позволяет
вычислить производную подъема поверхности по \(z\) как \(\zeta_z=k\zeta\), где
\(k\)\nbsp{}--- волновое число. В двухмерном случае решение записывается явной
формулой
\begin{align}
    \left.\frac{\partial\phi}{\partial x}\right|_{x,t}= &
        -\frac{1}{\sqrt{1+\alpha^{2}}}e^{-I(x)}
            \int\limits_{0}^x\frac{\partial\dot{\zeta}/\partial
                z+\alpha\dot{\alpha}}{\sqrt{1+\alpha^{2}}}e^{I(x)}dx,\label{eq-old-sol-2d}\\
    I(x)= & \int\limits_{0}^x\frac{\partial\alpha/\partial z}{1+\alpha^{2}}dx,\nonumber
\end{align}
где \(\alpha\)\nbsp{}--- уклоны волн. В трехмерном случае решение записывается в
виде эллиптического дифференциального уравнения в частных производных
\begin{align*}
    & \frac{\partial^2 \phi}{\partial x^2} \left( 1 + \alpha_x^2 \right) +
    \frac{\partial^2 \phi}{\partial y^2} \left( 1 + \alpha_y^2 \right) +
    2\alpha_x\alpha_y \frac{\partial^2 \phi}{\partial x \partial y} + \\
    & \left(
        \frac{\partial \alpha_x}{\partial z} +
        \alpha_x \frac{\partial \alpha_x}{\partial x} +
        \alpha_y \frac{\partial \alpha_x}{\partial y}
    \right) \frac{\partial \phi}{\partial x} + \\
    & \left(
        \frac{\partial \alpha_y}{\partial z} +
        \alpha_x \frac{\partial \alpha_y}{\partial x} +
        \alpha_y \frac{\partial \alpha_y}{\partial y}
    \right) \frac{\partial \phi}{\partial y} + \\
    & \frac{\partial \dot{\zeta}}{\partial z} +
    \alpha_x \dot{\alpha_x} + \alpha_y \dot{\alpha_y} = 0.
\end{align*}
Уравнение предполагается решать численно путем сведения к разностному.

Как будет показано в [[#sec:compare-formulae]] формула\nbsp{}eqref:eq-old-sol-2d
расходится при попытке вычислить поле скоростей для волн больших амплитуд, а
значит не может быть использована вместе с моделью ветрового волнения,
генерирующей волны произвольных амплитуд.

**** Линеаризация граничного условия.
:PROPERTIES:
:CUSTOM_ID: linearisation
:END:
Модель Лонге---Хиггинса позволяет вывести явную формулу для поля
скоростей путем линеаризации кинематического граничного условия. Формула для
потенциала скорости запишется как
\begin{equation*}
\phi(x,y,z,t) = \sum_n \frac{c_n g}{\omega_n}
     e^{\sqrt{u_n^2+v_n^2} z}
     \sin(u_n x + v_n y - \omega_n t + \epsilon_n).
\end{equation*}
Формула дифференцируется для получения производных потенциала, а полученные
значения подставляются в динамическое граничное условие для вычисления давлений.

** Определение поля давлений под дискретно заданной взволнованной поверхностью
Аналитические решения граничных задач для классических уравнений часто
используются для исследования различных свойств уравнений, и для таких
исследований запись формулы общего решения неудобна ввиду своей сложности и
наличия интегралов от неизвестных функций. Одним из методов нахождения
аналитических решений ДУЧП является метод Фурье. Основой метода служит
преобразование Фурье, применение которого к любому ДУЧП позволяет свести его к
алгебраическому, а его решение записывается как обратное преобразование Фурье от
некоторой функции (которая может содержать преобразования Фурье от других
функций). Поскольку эти преобразования не всегда можно записать аналитически, то
вместо этого ищутся частные решения задачи и анализируется их поведение в
различных областях. В то же время, вычисление дискретных преобразований Фурье на
компьютере возможно для любой дискретно заданной функции и эффективно при
использовании алгоритмов БПФ. Эти алгоритмы используют симметрию комплексных
экспонент для понижения асимптотической сложности с \(\mathcal{O}(n^2)\) до
\(\mathcal{O}(n\log_{2}n)\). Таким образом, даже если общее решение содержит
преобразования Фурье от неизвестных функций, они все равно могут быть взяты
численно, а использование алгоритмов БПФ делает этот подход эффективным.

Альтернативным подходом является сведение их к разностным уравнениям, решаемым с
помощью построения различных численных схем. При этом решение получается
приближенным, а асимптотическая сложность соответствующих алгоритмов сопоставима
со сложностью алгоритма БПФ. Например, стационарное эллиптическое уравнение в
частных производных преобразуется в неявную разностную схему, решаемую
итерационным методом, на каждом шаге которого ищется решение трехдиагональной
или пятидиагональной СЛАУ методом прогонки (алгоритм Томаса). Асимптотическая
сложность алгоритма составляет \(\mathcal{O}({n}{m})\), где \(n\)\nbsp{}---
количество точек на сетке взволнованной поверхности, \(m\)\nbsp{}--- число
итераций. Несмотря на широкое распространение, итеративные алгоритмы
неэффективно отображаются на архитектуру параллельных машин; в частности,
отображение на сопроцессоры может включать в себя копирование данных на
сопроцессор и обратно на каждой итерации, что отрицательно сказывается на их
производительности. В то же время, наличие большого количества преобразований
Фурье в решении является скорее преимуществом, чем недостатком. Во-первых,
решения, полученные с помощью метода Фурье, явные, а значит хорошо
масштабируются на большое количество параллельно работающих вычислительных ядер
с использованием простейших приемов параллельного программирования. Во-вторых,
для алгоритмов БПФ существуют готовые оптимизированные реализация для различных
архитектур процессоров и сопроцессоров (GPU, MIC). Эти преимущества обусловили
выбор метода Фурье в качестве рабочего для получения явного аналитического
решения задачи определения давлений под взволнованной морской поверхностью.

*** Двухмерное поле скоростей
:PROPERTIES:
:CUSTOM_ID: sec:pressure-2d
:END:
**** Формула для жидкости бесконечной глубины.
Задача Робена для уравнения Лапласа в двух измерениях записывается как
\begin{align}
    \label{eq-problem-2d}
    & \phi_{xx}+\phi_{zz}=0,\\
    & \zeta_t + \zeta_x\phi_x = \frac{\zeta_x}{\sqrt{1 + \zeta_x^2}} \phi_x - \phi_z, & \text{на }z=\zeta(x,t).\nonumber
\end{align}
Для ее решения воспользуемся методом Фурье. Возьмем преобразование Фурье от
обоих частей уравнений Лапласа и получим
\begin{equation*}
    -4 \pi^2 \left( u^2 + v^2 \right)
    \FourierY{\phi(x,z)}{u,v} = 0,
\end{equation*}
откуда имеем \(v = \pm i u\). Здесь и далее будет использоваться следующая
симметричная форма преобразования Фурье:
\begin{equation*}
    \FourierY{f(x,y)}{u,v} =
    \iint\limits_{-\infty}^{\phantom{--}\infty}
    f(x,y)
    e^{-2\pi i (x u + y v)}
    dx dy.
\end{equation*}
Решение уравнения будем искать в виде обратного преобразования Фурье
\(\phi(x,z)=\InverseFourierY{E(u,v)}{x,z}\). Подставляя[fn::Выражение \(v={-i}{u}\)
не подходит в данной задаче, поскольку потенциал скорости должен стремиться к
нулю с увеличением глубины до бесконечности.] \(v={i}{u}\) в формулу, решение
перепишется как
\begin{equation}
    \label{eq-guessed-sol-2d}
    \phi(x,z) = \InverseFourierY{e^{2\pi u z}E(u)}{x}.
\end{equation}
Для того чтобы подстановка \(z=\zeta(x,t)\) не помешала использованию
преобразований Фурье в решении, перепишем\nbsp{}eqref:eq-guessed-sol-2d в виде
свертки:
\begin{equation*}
    \phi(x,z)
    =
    \Fun{z}
    \ast
    \InverseFourierY{E(u)}{x},
\end{equation*}
где \(\Fun{z}\)\nbsp{}--- некоторая функция, вид которой будет определен в
[[#sec:compute-delta]] и для которой выполняется соотношение
\(\FourierY{\Fun{z}}{u}=e^{2\pi{u}{z}}\). Подставляя выражение для \(\phi\) в
граничное условие, получим
\begin{equation*}
    \zeta_t
    =
    \left( i f(x) - 1 \right)
    \left[
        \Fun{z}
        \ast
        \InverseFourierY{2\pi u E(u)}{x}
    \right],
\end{equation*}
где \(f(x) = {\zeta_x}/{\sqrt{1 + \zeta_x^2}} - \zeta_x\). Применяя преобразование
Фурье к обеим частям, получаем выражение для коэффициентов \(E\):
\begin{equation*}
    E(u) =
    \frac{1}{2\pi u}
    \frac{
    \FourierY{\zeta_t / \left(i f(x) - 1\right)}{u}
    }{
    \FourierY{\Fun{z}}{u}
    }
\end{equation*}
Выполняя подстановку \(z=\zeta(x,t)\) и подставляя полученное выражение
в\nbsp{}eqref:eq-guessed-sol-2d, получаем окончательное выражение для
\(\phi(x,z)\):
\begin{equation}
    \label{eq-solution-2d}
    \boxed{
        \phi(x,z)
        =
        \InverseFourierY{
            \frac{e^{2\pi u z}}{2\pi u}
            \frac{
            \FourierY{ \zeta_t / \left(i f(x) - 1\right) }{u}
            }{
            \FourierY{ \Fun{\zeta(x,t)} }{u}
            }
        }{x}.
    }
\end{equation}

Множитель \(e^{2\pi u z}/(2\pi u)\) делает график функции от которой берется
обратное преобразования Фурье несимметричным относительно оси \(OY\). Это
затрудняет применение БПФ, поскольку оно требует периодичную функцию, которая на
концах промежутка принимает нулевое значение. Использование численного
интегрирования вместо БПФ не позволит получить преимущество над решением всей
системы уравнений с помощью разностных схем. Эту проблему можно обойти,
используя формулу\nbsp{}eqref:eq-solution-2d-full для жидкости конечной глубины
с заведомо большим значением глубины водоема \(h\). Вывод формулы дан в
следующем разделе.

**** Формула для жидкости конечной глубины.
На дне водоема вертикальная составляющая скорости перемещения жидкости должна
равняться нулю, т.е. \(\phi_z=0\) на \(z=-h\), где \(h\)\nbsp{}--- глубина водоема. В этом
случае пренебречь равенством \(v = -i u\), полученным из уравнения Лапласа,
нельзя, и решение ищется в виде
\begin{equation}
    \phi(x,z)
    =
    \InverseFourierY{
        \left( C_1 e^{2\pi u z} + C_2 e^{-2\pi u z} \right)
        E(u)
    }{x}.
    \label{eq-guessed-sol-2d-full}
\end{equation}
Подставляя \(\phi\) в условие на дне водоема, получим
\begin{equation*}
    C_1 e^{-2\pi u h} - C_2 e^{2\pi u h} = 0,
\end{equation*}
откуда имеем \(C_1=\frac{1}{2}C{e}^{2\pi{u}{h}}\) и
\(C_2=-\frac{1}{2}C{e}^{-2\pi{u}{h}}\). Константа \(C\) здесь произвольна,
поскольку при подстановке станет частью неизвестных коэффициентов \(E(u)\).
Подставляя полученные выражения для \(C_1\) и \(C_2\)
в\nbsp{}eqref:eq-guessed-sol-2d-full, получаем выражение
\begin{equation*}
    \phi(x,z) = \InverseFourierY{ \Sinh{2\pi u (z+h)} E(u) }{x}.
\end{equation*}
Подставляя \(\phi\) в граничное условие на свободной поверхности, получаем
\begin{equation*}
    \zeta_t = f(x) \InverseFourierY{ 2\pi i u \Sinh{2\pi u (z+h)} E(u) }{x}
            - \InverseFourierY{ 2\pi u \SinhX{2\pi u (z+h)} E(u) }{x}.
\end{equation*}
Здесь \(\sinh\) и \(\cosh\) дают схожие результаты вблизи свободной поверхности, и,
поскольку эта область является наиболее интересной с точки зрения практического
применения, положим \(\Sinh{2\pi{u}(z+h)}\approx\SinhX{2\pi{u}(z+h)}\). Выполняя
аналогичные предыдущему разделу операции, получаем окончательное выражение для
\(\phi(x,z)\):
\begin{equation}
\boxed{
    \phi(x,z,t)
    =
  \InverseFourierY{
        \frac{\Sinh{2\pi u (z+h)}}{2\pi u}
        \frac{
            \FourierY{ \zeta_t / \left(i f(x) - 1\right) }{u}
        }{
            \FourierY{ \FunSecond{\zeta(x,t)} }{u}
        }
    }{x},
}
    \label{eq-solution-2d-full}
\end{equation}
где \(\FunSecond{z}\)\nbsp{}--- некоторая функция, вид которой будет определен в
[[#sec:compute-delta]] и для которой выполняется соотношение
\(\FourierY{\FunSecond{z}}{u}=\Sinh{2\pi{u}{z}}\).

**** Сведение к формулам линейной теории волн.
Справедливость полученных формул проверим, подставив в качестве \(\zeta(x,t)\)
известные аналитические выражения для плоских волн. Символьные вычисления
преобразований Фурье в этом разделе производились с помощью пакета
Mathematica\nbsp{}cite:mathematica10. В линейной теории широко используется
предположение о малости амплитуд волн, что позволяет упростить исходную систему
уравнений\nbsp{}eqref:eq-problem-2d до
\begin{align*}
    & \phi_{xx}+\phi_{zz}=0,\\
    & \zeta_t = -\phi_z & \text{на }z=\zeta(x,t),
\end{align*}
решение которой запишется как
\begin{equation*}
    \phi(x,z,t)
    =
    -\InverseFourierY{
        \frac{e^{2\pi u z}}{2\pi u}
        \FourierY{\zeta_t}{u}
    }{x}
    .
\end{equation*}
Профиль прогрессивной волны описывается формулой
\(\zeta(x,t)=A\cos(2\pi(kx-t))\). Подстановка этого выражения
в\nbsp{}eqref:eq-solution-2d дает равенство
\(\phi(x,z,t)=-\frac{A}{k}\sin(2\pi(kx-t))\Sinh{2\pi{k}{z}}\). Чтобы свести его
к формуле линейной теории волн, представим гиперболический синус в
экспоненциальной форме и отбросим член, содержащий \(e^{-2\pi{k}{z}}\), как
противоречащий условию \(\phi\underset{z\rightarrow-\infty}{\longrightarrow}0\).
После взятия действительной части выражения получится известная формула линейной
теории \(\phi(x,z,t)=\frac{A}{k}e^{2\pi{k}{z}}\sin(2\pi(kx-t))\). Аналогично,
предположение о малости амплитуд волн позволяет упростить
формулу\nbsp{}eqref:eq-solution-2d-full до
\begin{equation*}
    \phi(x,z,t)
    =
    -\InverseFourierY{
        \frac{\Sinh{2\pi u (z+h)}}{2\pi u \Sinh{2\pi u h}}
        \FourierY{\zeta_t}{u}
    }{x}.
\end{equation*}
Подстановка формулы для прогрессивной плоской волны вместо \(\zeta(x,t)\) дает
равенство
\begin{equation}
    \label{eq-solution-2d-linear}
    \phi(x,z,t)=\frac{A}{k}
    \frac{\Sinh{2 \pi k (z+h)}}{ \Sinh{2 \pi k h} }
    \sin(2 \pi (k x-t)),
\end{equation}
что соответствует формуле линейной теории для конечной глубины.

Различные записи решения уравнения Лапласа, в которых затухающая экспонента
может встречаться как со знаком "+", так и со знаком "-", могут стать причиной
разницы между формулами линейно теории и формулами, выведенными в данной работе,
где вместо \(\sinh\) используется \(\cosh\). Выражение
\(\frac{\Sinh{2\pi{k}(z+h)}}{\Sinh{2\pi{k}{h}}}\approx\frac{\sinh(2\pi{k}(z+h))}{\sinh(2\pi{k}{h})}\)
превращается в строгое равенство на поверхности, и разница между правой левой
частью увеличивается при приближении к дну водоема (для достаточно большой
глубины ошибка вблизи поверхности жидкости незначительна). Поэтому для
достаточно большой глубины можно использовать любую из функций (\(\cosh\) или
\(\sinh\)) для вычисления потенциала скорости вблизи взволнованной поверхности.

Сведение формул\nbsp{}eqref:eq-solution-2d и\nbsp{}eqref:eq-solution-2d-full к
формулам линейной теории волн показывает, что формула\nbsp{}eqref:eq-solution-2d
для жидкости бесконечной глубины не подходит для вычисления потенциала скорости
с использованием метода Фурье, т.к. не обладает необходимой для преобразования
Фурье симметрией. Однако, для такого случая можно использовать формулу для
конечной глубины, полагая \(h\) равным характерному значению глубины
исследуемого водоема. Для стоячих волн сведение к формулам линейной теории
происходит с аналогичными предположениями.

*** Трехмерное поле скоростей
В трех измерениях исходная система уравнений\nbsp{}eqref:eq-problem
переписывается как
\begin{align}
    \label{eq-problem-3d}
    & \phi_{xx} + \phi_{yy} + \phi_{zz} = 0,\\
    & \zeta_t + \zeta_x\phi_x + \zeta_y\phi_y
    =
    \frac{\zeta_x}{\SqrtZeta{1 + \zeta_x^2 + \zeta_y^2}} \phi_x
    +\frac{\zeta_y}{\SqrtZeta{1 + \zeta_x^2 + \zeta_y^2}} \phi_y
    - \phi_z, & \text{на }z=\zeta(x,y,t).\nonumber
\end{align}
Для ее решения также воспользуемся методом Фурье. Возьмем преобразование Фурье
от обоих частей уравнений Лапласа и получим
\begin{equation*}
    -4 \pi^2 \left( u^2 + v^2 + w^2 \right)
    \FourierY{\phi(x,y,z)}{u,v,w} = 0,
\end{equation*}
откуда имеем \(w=\pm{i}\sqrt{u^2+v^2}\). Решение уравнения будем искать в виде
обратного преобразования Фурье
\(\phi(x,y,z)=\InverseFourierY{E(u,v,w)}{x,y,z}\). Подставляя
\(w=i\sqrt{u^2+v^2}=i\Kveclen\) в исходную формулу, получаем
\begin{equation*}
    \phi(x,y,z) = \InverseFourierY{
        \left(
            C_1 e^{2\pi \Kveclen z}
            -C_2 e^{-2\pi \Kveclen z}
        \right)
        E(u,v)
    }{x,y}.
\end{equation*}
Подставляя \(\phi\) в условие на дне водоема аналогично двухмерному случаю,
получаем
\begin{equation}
    \label{eq-guessed-sol-3d}
    \phi(x,y,z) = \InverseFourierY{
        \Sinh{2\pi \Kveclen (z+h)} E(u,v)
    }{x,y}.
\end{equation}
Подставляя выражение для \(\phi\) в граничное условие, получим
\begin{equation*}
    \arraycolsep=1.4pt
    \begin{array}{rl}
        \zeta_t = & i f_1(x,y) \InverseFourierY{2 \pi u \Sinh{2\pi \Kveclen (z+h)}E(u,v)}{x,y} \\
        + & i f_2(x,y) \InverseFourierY{2 \pi v \Sinh{2\pi \Kveclen (z+h)}E(u,v)}{x,y} \\
        - & \InverseFourierY{2 \pi \sqrt{u^2+v^2} \Sinh{2\pi \Kveclen (z+h)}E(u,v)}{x,y}
    \end{array}
\end{equation*}
где \(f_1(x,y)={\zeta_x}/{\SqrtZeta{1+\zeta_x^2+\zeta_y^2}}-\zeta_x\) и
\(f_2(x,y)={\zeta_y}/{\SqrtZeta{1+\zeta_x^2+\zeta_y^2}}-\zeta_y\).

Также как и в разделе\nbsp{}[[#sec:pressure-2d]] мы предполагаем, что
\(\Sinh{2\pi{u}(z+h)}\approx\SinhX{2\pi{u}(z+h)}\) вблизи свободной поверхности,
однако в трехмерном случае этого недостаточно для решения задачи. Для того чтобы
получить аналитическую формулу для коэффициентов \(E\), мы должны предположить,
что преобразования Фурье в равенстве имеют радиально симметричные ядра, т.е.
заменить \(u\) и \(v\) на \(\Kveclen\). Есть два момента, поддерживающих это
предположение. Во-первых, в численной реализации интегрирование ведется по
положительным волновым числам, так что знак \(u\) и \(v\) не влияет на решение.
Во-вторых, скорость роста \(\cosh\) в ядре интеграла значительно больше, чем
скорость роста \(u\) или \(\Kveclen\), так что замена слабо влияет на величину
решения. Несмотря на эти два момента, использование более математически строго
подхода было бы предпочтительнее.

Выполняя замену, применяя преобразование Фурье к обеим частям равенства и
подставляя результат в\nbsp{}eqref:eq-guessed-sol-3d, получаем выражение для
\(\phi\):
\begin{equation*}
    \label{eq-phi-3d}
    \phi(x,y,z,t) = \InverseFourierY{
        \frac{ \Sinh{\smash{2\pi \Kveclen (z+h)}} }{ 2\pi\Kveclen }
        \frac{ \FourierY{ \zeta_t / \left( i f_1(x,y) + i f_2(x,y) - 1 \right)}{u,v} }
        { \FourierY{\mathcal{D}_3\left( x,y,\zeta\left(x,y\right) \right)}{u,v} }
    }{x,y},
\end{equation*}
где
\(\FourierY{\mathcal{D}_3\left(x,y,z\right)}{u,v}=\Sinh{\smash{2\pi\Kveclen{}z}}\).

** Моделирование нелинейности морских волн
Модель АРСС позволяет учесть асимметричность распределения волновых аппликат,
т.е. генерировать морские волны, закон распределения аппликат которых имеет
ненулевой эксцесс и асимметрию. Такой закон распределения характерен для
реальных морских волн\nbsp{}cite:longuet1963nonlinear.

Асимметричность волн моделируется с помощью нелинейного безынерционного
преобразования (НБП) случайного процесса, однако, любое нелинейное
преобразование случайного процесса приводит к преобразованию его АКФ. Для того
чтобы подавить этот эффект, необходимо предварительно преобразовать АКФ, как
показано в\nbsp{}cite:boukhanovsky1997thesis.

**** Преобразование взволнованной поверхности.
Формула \(z=f(y)\) преобразования взволнованной поверхности к необходимому
одномерному закону распределения \(F(z)\) получается путем решения нелинейного
трансцендентного уравнения \(F(z) = \Phi(y)\), где \(\Phi(y)\)\nbsp{}--- функция
одномерного нормального закона распределения. Поскольку функция распределения
аппликат морских волн часто задается некоторой аппроксимацией, основанной на
натурных данных, то это уравнение целесообразно решать численно в каждой точке
\(y_k|_{k=0}^N\) сетки сгенерированной поверхности относительно \(z_k\). Тогда
уравнение запишется в виде
\begin{equation}
    \label{eq-distribution-transformation}
    F(z_k)
    =
    \frac{1}{\sqrt{2\pi}}
    \int\limits_0^{y_k} \exp\left[ -\frac{t^2}{2} \right] dt
    .
\end{equation}
Поскольку функции распределения монотонны, для решения этого уравнения
используется простейший численный метод половинного деления (метод бисекции).

**** Предварительное преобразование АКФ.
Для преобразования АКФ \(\gamma_z\) процесса ее необходимо разложить в ряд по
полиномам Эрмита (ряд Грама---Шарлье)
\begin{equation*}
    \gamma_z \left( \vec u \right)
    =
    \sum\limits_{m=0}^{\infty}
    C_m^2 \frac{\gamma_y^m \left( \vec u \right)}{m!},
\end{equation*}
где
\begin{equation*}
    C_m = \frac{1}{\sqrt{2\pi}}
  \int\limits_{0}^\infty
    f(y) H_m(y) \exp\left[ -\frac{y^2}{2} \right],
\end{equation*}
\(H_m\)\nbsp{}--- полином Эрмита, а \(f(y)\)\nbsp{}--- решение
уравнения\nbsp{}eqref:eq-distribution-transformation. Воспользовавшись
полиномиальной аппроксимацией \(f(y) \approx \sum\limits_i d_i y^i\) и
аналитическими выражениями для полиномов Эрмита, формулу определения
коэффициентов можно упростить, используя следующее равенство:
\begin{equation*}
    \frac{1}{\sqrt{2\pi}}
    \int\limits_\infty^\infty
    y^k \exp\left[ -\frac{y^2}{2} \right]
    =
    \begin{cases}
        (k-1)!! & \text{для четных }k,\\
        0       & \text{для нечетных }k.
    \end{cases}
\end{equation*}
Оптимальное количество коэффициентов \(C_m\) определяется путем вычисления их
последовательно и критерий прекращения счета определяется совпадением дисперсий
обоих полей с требуемой точностью \(\epsilon\):
\begin{equation}
    \label{eq-nit-error}
    \left| \Var{z} - \sum\limits_{k=0}^m
    \frac{C_k^2}{k!} \right| \leq \epsilon.
\end{equation}

В\nbsp{}cite:boukhanovsky1997thesis автор предлагает использовать полиномиальную
аппроксимацию для \(f(y)\) также для преобразования поверхности, однако на
практике в реализации взволнованной поверхности часто находятся точки,
выпадающие за промежуток на котором построена аппроксимация, что приводит к
резкому уменьшению ее точности. В этих точках
уравнение\nbsp{}eqref:eq-distribution-transformation эффективнее решать методом
бисекции. Использование полиномиальной аппроксимации в формулах для
коэффициентов ряда Грама---Шарлье не приводит к аналогичным ошибкам.

* Численные методы и результаты экспериментов
** Форма АКФ для разных волновых профилей
:PROPERTIES:
:CUSTOM_ID: sec-wave-acfs
:END:
**** Аналитический метод.
Прямой способ нахождения АКФ, соответствующей заданному профилю морской волны,
состоит в применении теоремы Винера---Хинчина. Согласно этой теореме
автокорреляционная функция \(K\) функции \(\zeta\) равна преобразованию Фурье от
квадрата модуля этой функции:
\begin{equation}
  K(t) = \Fourier{\left| \zeta(t) \right|^2}.
  \label{eq-wiener-khinchin}
\end{equation}
Если заменить \(\zeta\) на формулу для волнового профиля, то это выражение даст
аналитическую формулу для соответствующей АКФ.

Для трехмерного волнового профиля (два пространственных и одно временное
измерение) аналитическая формула представляет собой многочлен высокой степени, и
ее лучше всего вычислять с помощью программы для символьных вычислений. Затем,
для практического применения она может быть аппроксимирована суперпозицией
экспоненциально затухающих косинусов (именно так выглядит АКФ стационарного
процесса АРСС\nbsp{}cite:box1976time).

**** Эмпирический метод.
Впрочем, для трехмерного случая существует более простой эмпирический метод
нахождения формы АКФ, не требующий использования сложного программного
обеспечения. Известно, что АКФ, представляющая собой суперпозицию
экспоненциально затухающих косинусов, является решением уравнения Стокса для
гравитационных волн\nbsp{}cite:boccotti1983wind. Значит, если в моделируемом
морском волнении важна только форма волны, а не точные ее характеристики, то
заданный волновой профиль можно просто домножить на затухающую экспоненту, чтобы
получить подходящую АКФ. Эта АКФ не отражает параметры волн, такие как высота и
период, зато это открывает возможность моделировать волны определенных
неаналитических форм, "рисуя" профиль волны, домножая его на экспоненту и
используя результирующую функцию в качестве АКФ. Таким образом, эмпирический
метод неточен, но более простой по сравнению с применением теоремы
Винера---Хинчина; он, в основном, полезен для тестирования модели АРСС.

**** АКФ стоячей волны.
Профиль трехмерной плоской стоячей волны задается как
\begin{equation}
  \zeta(t, x, y) = A \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq-standing-wave}
\end{equation}
Найдем АКФ с помощью аналитического метода. Домножив формулу на затухающую
экспоненту (поскольку преобразование Фурье определено для функции \(f\), для
которой справедливо \(f\underset{x\rightarrow\pm\infty}{\longrightarrow}0\)),
получим
\begin{equation}
  \zeta(t, x, y) =
  A
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \sin (k_x x + k_y y) \sin (\sigma t).
  \label{eq-decaying-standing-wave}
\end{equation}
Затем, применяя трехмерное преобразование Фурье к обоим частям уравнения с
помощью программы для символьных вычислений, получим многочлен высокой степени,
который аппроксимируем выражением
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos \beta t
  \cos \left[ \beta x + \beta y \right].
  \label{eq-standing-wave-acf}
\end{equation}
Таким образом, после применения теоремы Винера---Хинчина получаем исходную
формулу, но с косинусами вместо синусов. Это различие важно, поскольку значение
АКФ в точке \((0,0,0)\) равно дисперсии процесса АРСС, которое при использовании
синусов было бы неверным.

Если попытаться получить ту же самую формулу с помощью эмпирического метода, то
выражение\nbsp{}eqref:eq-decaying-standing-wave необходимо адаптировать для
соответствия\nbsp{}eqref:eq-standing-wave-acf. Это можно осуществить либо,
изменяя фазу синуса, либо заменой синуса на косинус, чтобы сдвинуть максимум
функции в начало координат.

**** АКФ прогрессивной волны.
Профиль трехмерной плоской прогрессивной волны задается как
\begin{equation}
  \zeta(t, x, y) = A \cos (\sigma t + k_x x + k_y y).
  \label{eq-propagating-wave}
\end{equation}
Для аналитического метода повторение шагов из предыдущих двух параграфов дает
\begin{equation}
  K(t,x,y) =
  \gamma
  \exp\left[-\alpha (|t|+|x|+|y|) \right]
  \cos\left[\beta (t+x+y) \right].
  \label{eq-propagating-wave-acf}
\end{equation}
Для эмпирического метода профиль волны можно просто домножить на затухающую
экспоненту, не изменяя положение максимума АКФ (как это требовалось для стоячей
волны).

**** Сравнение изученных методов.
Итого, аналитический метод нахождения АКФ морских волн сводится к следующим
шагам.
- Обеспечить затухание выражения для профиля волны на \(\pm\infty\), домножив его
  на затухающую экспоненту.
- Взять преобразование Фурье от квадрата модуля получившегося профиля,
  воспользовавшись программой для символьных вычислений.
- Аппроксимировать получившийся многочлен подходящим выражением для АКФ.

Два примера этого раздела показывают, что затухающие профили стоячих и
прогрессивных волн схожи по форме с соответствующими АКФ с тем лишь различием,
что максимум АКФ должен быть перенесен в начало координат, чтобы сохранить
дисперсию моделируемого процесса. Применение эмпирического метода нахождения АКФ
сводится к следующим шагам.
- Обеспечить затухание выражения для профиля волны на \(\pm\infty\), домножив его
  на затухающую экспоненту.
- Перенести максимум получившейся функции в начало координат, используя свойства
  тригонометрических функций для сдвига фазы.

** Дополнительные формулы, методы и алгоритмы для модели АРСС
:PROPERTIES:
:CUSTOM_ID: sec:arma-algorithms
:END:
*** Аппроксимация распределения аппликат
Одним из параметров генератора взволнованной морской поверхности служит функция
плотности распределения (ФПР) аппликат этой поверхности. Она задается либо
полиномиальной аппроксимацией натурных данных, либо аналитически.

**** Разложение в ряд Грама---Шарлье.
В\nbsp{}cite:huang1980experimental было экспериментально показано, что
распределение аппликат морской поверхности отличается от нормального ненулевым
эксцессом и асимметрией. В\nbsp{}cite:rozhkov1996theory показано, что такое
распределение раскладывается в ряд Грама---Шарлье:
\begin{align}
    \label{eq-skew-normal-1}
    & F(z; \mu=0, \sigma=1, \gamma_1, \gamma_2) \approx
    \Phi(z; \mu, \sigma) \frac{2 + \gamma_2}{2}
    - \frac{2}{3} \phi(z; \mu, \sigma)
    \left(\gamma_2 z^3+\gamma_1
    \left(2 z^2+1\right)\right) \nonumber
    \\
    & f(z; \gamma_1, \gamma_2) \approx
    \frac{1}{\sigma\sqrt{2 \pi}}e^{-\frac{(z-\mu)^2}{2\sigma^2}}
    \left[
        1+
        \frac{1}{6} \gamma_1 z \left(z^2-3\right)
        + \frac{1}{24} \gamma_2 \left(z^4-6z^2+3\right)
    \right],
\end{align}
где \(\Phi(z)\)\nbsp{}--- ФР нормального распределения, \(\phi\)\nbsp{}--- ФПР
нормального распределения, \(\gamma_1\)\nbsp{}--- асимметрия,
\(\gamma_2\)\nbsp{}--- эксцесс, \(f\)\nbsp{}--- ФПР, \(F\)\nbsp{}--- функция
распределения (ФР). Согласно\nbsp{}cite:rozhkov1990stochastic для аппликат
морских волн значение асимметрии выбирается на интервале
\(0,1\leq\gamma_1\leq{0,52}]\), а значение эксцесса на интервале
\(0,1\leq\gamma_2\leq{0,7}\). Семейство плотностей распределения при различных
параметрах показано на рис.\nbsp{}[[fig-skew-normal-1]].

#+name: fig-skew-normal-1
#+begin_src R :file build/skew-normal-1-ru.pdf
source(file.path("R", "common.R"))
x <- seq(-3, 3, length.out=100)
params <- data.frame(
  skewness = c(0.00, 0.52, 0.00, 0.52),
  kurtosis = c(0.00, 0.00, 0.70, 0.70),
  linetypes = c("solid", "dashed", "dotdash", "dotted")
)
arma.skew_normal_1_plot(x, params)
legend(
  "topleft",
  mapply(
    function (s, k) {
      as.expression(bquote(list(
        gamma[1] == .(arma.fmt(s, 2)),
        gamma[2] == .(arma.fmt(k, 2))
      )))
    },
    params$skewness,
    params$kurtosis
  ),
  lty = paste(params$linetypes)
)
#+end_src

#+caption: Вид плотности распределения\nbsp{}eqref:eq-skew-normal-1 аппликат взволнованной морской поверхности при различных значениях асимметрии \(\gamma_1\) и эксцесса \(\gamma_2\).
#+name: fig-skew-normal-1
#+RESULTS: fig-skew-normal-1
[[file:build/skew-normal-1-ru.pdf]]

**** Асимметричное нормальное распределение.
Альтернативной аппроксимацией распределения волновых аппликат служит формула
асимметричного нормального распределения:
\begin{align}
    \label{eq-skew-normal-2}
    F(z; \alpha) & = \frac{1}{2}
   \mathrm{erfc}\left[-\frac{z}{\sqrt{2}}\right]-2 T(z,\alpha ), \nonumber \\
    f(z; \alpha) & = \frac{e^{-\frac{z^2}{2}}}{\sqrt{2 \pi }}
   \mathrm{erfc}\left[-\frac{\alpha z}{\sqrt{2}}\right],
\end{align}
где \(T\)\nbsp{}--- функция Оуэна\nbsp{}cite:owen1956tables. Эта формула не
позволяет задать значения асимметрии и эксцесса по отдельности\nbsp{}--- оба
значения регулируются параметром \(\alpha\). Преимущество данной формулы лишь в
относительной простоте вычисления: эта функция встроена в некоторые программы и
библиотеки математических функций. График функции для разных значений \(\alpha\)
представлен на рис.\nbsp{}[[fig-skew-normal-2]].

#+name: fig-skew-normal-2
#+begin_src R :file build/skew-normal-2-ru.pdf
source(file.path("R", "common.R"))
x <- seq(-3, 3, length.out=100)
alpha <- c(0.00, 0.87, 2.25, 4.90)
params <- data.frame(
  alpha = alpha,
  skewness = arma.bits.skewness_2(alpha),
  kurtosis = arma.bits.kurtosis_2(alpha),
  linetypes = c("solid", "dashed", "dotdash", "dotted")
)
arma.skew_normal_2_plot(x, params)
legend(
  "topleft",
  mapply(
    function (a, s, k) {
      as.expression(bquote(list(
        alpha == .(arma.fmt(a, 2)),
        gamma[1] == .(arma.fmt(s, 2)),
        gamma[2] == .(arma.fmt(k, 2))
      )))
    },
    params$alpha,
    params$skewness,
    params$kurtosis
  ),
  lty = paste(params$linetypes)
)
#+end_src

#+caption: Вид плотности распределения\nbsp{}eqref:eq-skew-normal-2 волновых аппликат при различных значениях коэффициента асимметрии \(\alpha\).
#+name: fig-skew-normal-2
#+RESULTS: fig-skew-normal-2
[[file:build/skew-normal-2.pdf]]

**** Тестирование.
Решение уравнения\nbsp{}eqref:eq-distribution-transformation с выбранной
функцией распределения можно произвести либо в каждой точке генерируемой
поверхности, что даст наиболее точные результаты, либо в каждой точке
фиксированной сетки, интерполировав решение методом наименьших квадратов (МНК).
Во втором случае точность будет меньше. Например, интерполяция многочленом 12-го
порядка на сетке из 500 узлов, построенной на промежутке
\(-5\sigma_z\leq{z}\leq{5}\sigma_z\), дает погрешность
\(\approx{0,43}\cdot10^{-3}\). Увеличение порядка многочлена приводит либо к
переполнениям при интерполяции МНК, либо к дополнительным коэффициентам близким
к нулю; увеличение размера сетки влияет на результат незначительно. В
большинстве случаев трех коэффициентов ряда Грама---Шарлье было достаточно для
преобразования АКФ; относительная погрешность без интерполяции составляет
\(10^{-5}\).

*** Алгоритм генерации белого шума
Чтобы исключить периодичность из сгенерированной моделью ветрового волнения
реализации взволнованной поверхности, для генерации белого шума нужно
использовать ГПСЧ с достаточно большим периодом. В качестве такого генератора в
работе используется параллельная реализация вихря
Мерсенна\nbsp{}cite:matsumoto1998mersenne с периодом \(2^{19937}-1\). Это
позволяет создавать апериодические реализации взволнованной морской поверхности
для любых сценариев применения, встречаемых на практике.

Запуск нескольких ГПСЧ с разными начальными состояниями в параллельных потоках
не гарантирует некоррелированность генерируемых последовательностей
псевдослучайных чисел, однако, можно воспользоваться алгоритмом динамического
создания вихрей Мерсенна\nbsp{}cite:matsumoto1998dynamic, чтобы дать такую
гарантию. Суть алгоритма заключается в поиске таких матриц начальных состояний
генераторов, которые бы дали максимально некоррелированные последовательности
псевдослучайных чисел при параллельном запуске нескольких вихрей Мерсенна с
этими начальными состояниями. Поскольку на поиск начальных состояний можно
потратить значительное количество процессорного времени, то вектор состояний
создается предварительно для заведомо большего количества параллельных потоков и
сохраняется в файл, который впоследствии считывается основной программой перед
началом генерации белого шума.

*** Алгоритм генерации взволнованной поверхности
В модели АРСС значение подъема взволнованной поверхности в каждой точке зависит
от предыдущих по пространству и времени значений, из-за чего в начале реализации
образуется так называемый /интервал разгона/ (см.\nbsp{}рис.\nbsp{}[[fig-ramp-up-interval]])\nbsp{}---
промежуток, на котором реализация не соответствует заданной АКФ. Способ решения
этой проблемы зависит от контекста, в котором происходит моделирование.

Если реализация используется в контексте расчета остойчивости судна без учета
маневрирования, то интервал никак не повлияет результаты эксперимента, поскольку
находится на границе (далеко от исследуемого морского объекта). Если изучается
остойчивость судна в условиях маневрирования, то интервал проще всего исключить
из реализации (размер интервала примерно равен числу коэффициентов АР по каждому
из измерений). Однако, это приводит к потере большого числа точек, поскольку
исключение происходит по каждому из трех измерений. Альтернативным подходом
является генерация взволнованной поверхности на интервале разгона моделью ЛХ и
генерация остальной реализации с помощью модели АРСС.

В алгоритме генерации взволнованной поверхности используется параллелизм по
данным: реализация делится на равные части, каждая из которых генерируется
независимо,\nbsp{}--- однако, в начале каждой из частей также присутствует
интервал разгона. Для его исключения используется метод /сшивания/, часто
применяемый в обработке цифровых
сигналов\nbsp{}cite:oppenheim1989discrete,svoboda2011efficient,pavel2013algorithms.
Суть метода заключается в добавлении интервала равного по размеру интервалу
разгона в конец каждой из частей. Затем взволнованная поверхность генерируется в
каждой точке каждой из частей (включая добавленный интервал), интервал в конце
части \(N\) накладывается на интервал разгона в начале части \(N+1\), и значения
в соответствующих точках складываются.

#+name: fig-ramp-up-interval
#+begin_src R :file build/ramp-up-interval-ru.pdf
source(file.path("R", "common.R"))
arma.plot_ramp_up_interval(label="Интервал разгона")
#+end_src

#+caption: Интервал разгона в начале оси \(OX\) реализации.
#+name: fig-ramp-up-interval
#+RESULTS: fig-ramp-up-interval
[[file:build/ramp-up-interval-ru.pdf]]

*** Формулы нормировки для потенциалов скоростей
:PROPERTIES:
:CUSTOM_ID: sec:compute-delta
:END:

В решениях\nbsp{}eqref:eq-solution-2d и\nbsp{}eqref:eq-solution-2d-full
двухмерной задачи определения поля давлений присутствуют функции
\(\Fun{z}=\InverseFourierY{e^{2\pi{u}{z}}}{x}\) и
\(\FunSecond{z}=\InverseFourierY{\Sinh{2\pi{u}{z}}}{x}\), которые могут быть
записаны аналитически различными выражениями и представляют сложность при
вычислении на компьютере. Каждая функция\nbsp{}--- это преобразование Фурье от
линейной комбинации экспонент, которое сводится к плохо определенной дельта
функции комплексного аргумента (см.\nbsp{}табл.\nbsp{}[[tab-delta-functions]]).
Обычно такого типа функции записывают как произведение дельта функций от
действительной и мнимой части, однако, такой подход не работает здесь, поскольку
взятие обратного преобразования Фурье не даст экспоненту, что сильно исказит
результирующее поле скоростей. Для получения однозначного аналитического
выражения можно воспользоваться нормировкой \(1/\Sinh{2\pi{u}{h}}\) (которая
также включается в выражение для коэффициентов \(E(u)\)). Численные эксперименты
показывают, что нормировка хоть и позволяет получить адекватное поле скоростей,
оно мало отличается от выражений из линейной теории волн, в которых члены с
\(\zeta\) опускаются. Как следствие, формула для трехмерного случая не
выводилась.

#+name: tab-delta-functions
#+caption: Формулы для вычисления \(\Fun{z}\) и \(\FunSecond{z}\) из [[#sec:pressure-2d]], использующие нормировку для исключения неоднозначности определения дельта функции комплексного аргумента.
#+attr_latex: :booktabs t
| Функция           | Без нормировки                                               | С нормировкой                                                                                                                          |
|-------------------+--------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------|
| \(\Fun{z}\)       | \(\delta (x+i z)\)                                           | \(\frac{1}{2 h}\mathrm{sech}\left(\frac{\pi  (x-i (h+z))}{2 h}\right)\)                                                                |
| \(\FunSecond{z}\) | \(\frac{1}{2}\left[\delta (x-i z) + \delta (x+i z) \right]\) | \(\frac{1}{4 h}\left[\text{sech}\left(\frac{\pi  (x-i (h+z))}{2 h}\right)+\text{sech}\left(\frac{\pi  (x+i(h+z))}{2 h}\right)\right]\) |

** Верификация модели АРСС
:PROPERTIES:
:CUSTOM_ID: sec:verification
:END:

Для модели АР в
работах\nbsp{}cite:degtyarev2011modelling,degtyarev2013synoptic,boukhanovsky1997thesis
экспериментальным путем были верифицированы
- распределения различных характеристик волн (высоты волн, длины волн, длины
  гребней, период волн, уклон волн, показатель трехмерности),
- дисперсионное соотношение,
- сохранение интегральных характеристик для случая смешанного волнения.
В данной работе верифицируются как модель АР, так и СС путем сравнения
распределений различных характеристик волн.

*** Верификация интегральных характеристик взволнованной поверхности
В\nbsp{}cite:rozhkov1990stochastic авторы показывают, что некоторые
характеристики морских волн (перечисленные в табл.\nbsp{}[[tab-weibull-shape]])
имеют распределение Вейбулла, а подъем взволнованной поверхности\nbsp{}---
нормальное распределение. Для верификации генерируемых моделями АР и СС
реализаций используются спрямленные диаграммы (графики, в которых по оси \(OX\)
откладываются квантили функции распределения, вычисленные аналитически, а по оси
\(OY\)\nbsp{}--- вычисленные экспериментально). Если экспериментально полученное
распределение соответствует аналитическому, то график представляет собой прямую
линию. Концы графика могут отклоняться от прямой линии, поскольку не могут быть
надежно получены из реализации конечной длины. Различные методы извлечения волн
из реализации также могут привести к вариациям на концах графиков, извлечь
каждую волну из реализации практически невозможно, поскольку они могут (и часто)
накладываются друг на друга.

#+name: tab-weibull-shape
#+caption: Значение коэффициента формы \(k\) распределения Вейбулла для различных характеристик волн.
#+attr_latex: :booktabs t
| Характеристика          | Коэффициент формы \(k\) |
|-------------------------+-----------------------|
| Высота волны            |                     2 |
| Длина волны             |                   2,3 |
| Длина гребня волны      |                   2,3 |
| Период волны            |                     3 |
| Уклон волны             |                   2,5 |
| Показатель трехмерности |                   2,5 |

Верификация производится для стоячих и прогрессивных волн. Соответствующие АКФ и
спрямленные диаграммы распределений характеристик волн представлены на рис.
[[acf-slices]], [[standing-wave-distributions]], [[propagating-wave-distributions]].

#+name: propagating-wave-distributions
#+begin_src R :file build/propagating-wave-qqplots-ru.pdf
source(file.path("R", "common.R"))
par(pty="s", mfrow=c(2, 2))
arma.qqplot_grid(
  file.path("build", "propagating_wave"),
  c("elevation", "heights_y", "lengths_y", "periods"),
  c("подъем", "высота по Y", "длина по Y", "период"),
  xlab="x",
  ylab="y"
)
#+end_src

#+caption: Спрямленные диаграммы для прогрессивных волн.
#+name: propagating-wave-distributions
#+RESULTS: propagating-wave-distributions
[[file:build/propagating-wave-qqplots.pdf]]

#+name: standing-wave-distributions
#+begin_src R :file build/standing-wave-qqplots-ru.pdf
source(file.path("R", "common.R"))
par(pty="s", mfrow=c(2, 2))
arma.qqplot_grid(
  file.path("build", "standing_wave"),
  c("elevation", "heights_y", "lengths_y", "periods"),
  c("подъем", "высота по Y", "длина по Y", "период"),
  xlab="x",
  ylab="y"
)
#+end_src

#+caption: Спрямленные диаграммы для стоячих волн.
#+name: standing-wave-distributions
#+RESULTS: standing-wave-distributions
[[file:build/standing-wave-qqplots-ru.pdf]]

#+name: acf-slices
#+header: :width 6 :height 9
#+begin_src R :file build/acf-slices-ru.pdf
source(file.path("R", "common.R"))
propagating_acf <- read.csv(file.path("build", "propagating_wave", "acf.csv"))
standing_acf <- read.csv(file.path("build", "standing_wave", "acf.csv"))
par(mfrow=c(5, 2), mar=c(0,0,0,0))
for (i in seq(0, 4)) {
  arma.wavy_plot(standing_acf, i, zlim=c(-5,5))
  arma.wavy_plot(propagating_acf, i, zlim=c(-5,5))
}
#+end_src

#+caption: Временные срезы АКФ для стоячих (слева) и прогрессивных (справа) волн.
#+name: acf-slices
#+RESULTS: acf-slices
[[file:build/acf-slices-ru.pdf]]

Хвосты распределений на рис.\nbsp{}[[propagating-wave-distributions]] отклоняются от
оригинального распределения для характеристик отдельных волн, поскольку каждую
волну необходимо извлечь из полученной взволнованной поверхности, чтобы измерить
ее длину, период и высоту. Алгоритм, который бы гарантировал безошибочное
извлечение всех волн, не известен, поскольку волны могут и часто накладываются
друг на друга. Правый хвост распределения Вейбулла отклоняется больше, поскольку
он представляет редко возникающие волны.

Степень соответствия для стоячих волн (рис.\nbsp{}[[standing-wave-distributions]])
ниже для высот и длин, примерно одинакова для подъема поверхности и выше для
периодов волн. Более низкая степень соответствия длин и высот может быть
результатом того, что распределения были получены эмпирически для морских волн,
которые, в основном, являются прогрессивными, и аналогичные распределения для
стоячих волн могут отличаться. Более высокая степень соответствия периодов волн
является следствием того, что периоды стоячих волн извлекаются более точно,
поскольку волн не перемещаются вне моделируемой области взволнованной
поверхности. Одинаковая степень соответствия для подъема поверхности получается
из-за того, что это характеристика поверхности (и соответствующего процесса АР
или СС), и она не зависит от типа волн.
*** Верификация полей потенциалов скоростей
:PROPERTIES:
:CUSTOM_ID: sec:compare-formulae
:END:

Сравнение полученных общих формул\nbsp{}eqref:eq-solution-2d
и\nbsp{}eqref:eq-solution-2d-full с известными формулами линейной теории волн
позволяет оценить различие между полями скоростей для волн как больших, так и
малых амплитуд. В общем случае аналитическое выражение для потенциала скорости
неизвестно даже для плоских волн, поэтому сравнение производится численно. Имея
ввиду выводы раздела [[#sec:pressure-2d]], сравниваются только формулы для
случая конечной глубины.

**** Отличие от формул линейной теории волн.
Для того чтобы получить поля потенциалов скоростей, взволнованная морская
поверхность генерировалась с помощью модели АР с варьированием амплитуды волн. В
численной реализации волновые числа в преобразованиях Фурье выбирались на
интервале от \(0\) до максимального волнового числа, определяемого численно из
полученной взволнованной поверхности. Эксперименты проводились для волн малых и
больших амплитуд.

Эксперимент показал, что поля потенциалов скоростей, полученные по
формуле\nbsp{}eqref:eq-solution-2d-full для конечной глубины и по
формуле\nbsp{}eqref:eq-solution-2d-linear линейной теории, качественно
отличаются (см.\nbsp{}рис.\nbsp{}[[fig-potential-field-nonlinear]]). Во-первых,
контуры потенциала скорости имеют вид затухающей синусоиды, что отличается от
овальной формы, описываемой линейной теории волн. Во-вторых, по мере приближения
к дну водоема потенциал скорости затухает гораздо быстрее, чем в линейной
теории, а область, где сконцентрирована большая часть энергии волны, еще больше
приближена к ее гребню. Аналогичный численный эксперимент, в котором из
формулы\nbsp{}eqref:eq-solution-2d-full были исключены члены, которыми
пренебрегают в рамках линейной теории волн, показал, что полное соответствие
получившихся полей потенциалов скоростей (насколько это позволяет сделать
машинная точность).

#+name: fig-potential-field-nonlinear
#+header: :width 8 :height 11
#+begin_src R :file build/plain-wave-velocity-field-comparison-ru.pdf
source(file.path("R", "velocity-potentials.R"))
par(pty="s")
nlevels <- 41
levels <- pretty(c(-200,200), nlevels)
palette <- colorRampPalette(c("blue", "lightyellow", "red"))
col <- palette(nlevels-1)

# linear solver
par(fig=c(0,0.95,0,0.5),new=TRUE)
arma.plot_velocity_potential_field(
  file.path("build", "plain_wave_linear_solver"),
  levels=levels,
  col=col
)

# high-amplitude solver
par(fig=c(0,0.95,0.5,1),new=TRUE)
arma.plot_velocity_potential_field(
  file.path("build", "plain_wave_high_amplitude_solver"),
  levels=levels,
  col=col
)

# legend 1
par(pty="m",fig=c(0.80,1,0.5,1), new=TRUE)
arma.plot_velocity_potential_field_legend(
  levels=levels,
  col=col
)

# legend 2
par(pty="m",fig=c(0.80,1,0,0.5), new=TRUE)
arma.plot_velocity_potential_field_legend(
  levels=levels,
  col=col
)
#+end_src

#+name: fig-potential-field-nonlinear
#+caption: Поле потенциала скорости прогрессивной волны \(\zeta(x,y,t) = \cos(2\pi x - t/2)\). Поле, полученное по формуле\nbsp{}eqref:eq-solution-2d-full (сверху) и по формуле линейной теории волн (снизу).
#+attr_latex: :width \textwidth
#+RESULTS: fig-potential-field-nonlinear
[[file:build/plain-wave-velocity-field-comparison-ru.pdf]]


**** Отличие от формул теории волн малой амплитуды.
Эксперимент, в котором сравнивались поля потенциалов скоростей, полученные
численно различными формулами, показал, что поля скоростей, полученные по
формуле\nbsp{}eqref:eq-solution-2d-full и формуле для волн малой
амплитуды\nbsp{}eqref:eq-old-sol-2d, сопоставимы для волн малых амплитуд. В этом
эксперименте использовались две реализации взволнованной морской поверхности,
полученные по модели АР: одна содержала волны малой амплитуды, другая\nbsp{}---
большой. Интегрирование в формуле\nbsp{}eqref:eq-solution-2d-full велось по
диапазону волновых чисел, полученному из морской поверхности. Для волн малой
амплитуды обе формулы показали сопоставимые результаты (разница в значениях
скорости приписывается стохастической природе модели АР), в то время как для
волн больших амплитуд устойчивое поле скоростей дала только
формула\nbsp{}eqref:eq-solution-2d-full (рис.\nbsp{}[[fig-velocity-field-2d]]).
Таким образом, общая формула\nbsp{}eqref:eq-solution-2d-full показывает
удовлетворительные результаты, не вводя ограничения на амплитуду волн.

#+name: fig-velocity-field-2d
#+name: fig-velocity-field-2d
#+header: :width 8 :height 11
#+begin_src R :file build/large-and-small-amplitude-velocity-field-comparison-ru.pdf
source(file.path("R", "velocity-potentials.R"))
linetypes = c("solid", "dashed")
par(mfrow=c(2, 1))
arma.plot_velocity(
  file.path("data", "velocity", "low-amp"),
  file.path("data", "velocity", "low-amp-0"),
  linetypes=linetypes,
  ylim=c(-2,2)
)
arma.plot_velocity(
  file.path("data", "velocity", "high-amp"),
  file.path("data", "velocity", "high-amp-0"),
  linetypes=linetypes,
  ylim=c(-2,2)
)
#+end_src

#+name: fig-velocity-field-2d
#+caption: Сравнение полей скоростей на поверхности моря, полученных по общей формуле (\(u_1\)) и формуле для волн малой амплитуды (\(u_2\)). Поле скоростей для поверхности волн малой амплитуды (сверху) и большой амплитуды (снизу).
#+attr_latex: :width \textwidth
#+RESULTS: fig-velocity-field-2d
[[file:build/large-and-small-amplitude-velocity-field-comparison-ru.pdf]]

*** Верификация нелинейного безынерционного преобразования
Для того чтобы измерить влияние НБП на форму результирующей взволнованной
поверхности, было сгенерировано три реализации:
- реализация с Гауссовым распределением (без НБП),
- реализация с распределением на основе ряда Грама---Шарлье (РГШ), и
- реализация с асимметричным нормальным распределением (АНР).
Начальные состояния ГПСЧ были заданы одинаковыми для всех запусков программы,
чтобы модель АРСС выдавала одни и те же значения для каждой реализации. Было
проведено два эксперимента: для стоячих и прогрессивных волн с АКФ, заданными
формулами из разд.\nbsp{}[[#sec-wave-acfs]].

В то время как эксперимент показал, что применение НБП с распределением РГШ
увеличивает крутизну волн, то же самое нельзя сказать об асимметричном
нормальном распределении (рис.\nbsp{}[[fig-nit]]). Использование этого распределения
приводит к взволнованной поверхности, в которой аппликаты всегда больше или
равны нулю. Таким образом, асимметричное нормальное распределение не подходит
для НБП. НБП увеличивает высоту и крутизну как прогрессивных, так и стоячих
волн. Увеличение параметра либо асимметрии, либо эксцесса РГШ приводит в
увеличению как высоты, так и крутизны волн. Ошибка аппроксимации АКФ
(ур.\nbsp{}eqref:eq-nit-error) принимает значения от 0.20 для РГШ до 0.70 для
асимметричного нормального распределения (табл.\nbsp{}[[tab-nit-error]]).

#+name: fig-nit
#+header: :width 7 :height 7
#+begin_src R :file build/nit.pdf
source(file.path("R", "nonlinear.R"))
par(mfrow=c(2, 1), mar=c(4,4,4,0.5), family='serif')
args <- list(
  graphs=c('Гауссово', 'РГШ', 'АНР'),
  linetypes=c('solid', 'dashed', 'dotted')
)
args$title <- 'Прогрессивные волны'
arma.plot_nonlinear(file.path("build", "nit-propagating"), args)
args$title <- 'Стоячие волны'
arma.plot_nonlinear(file.path("build", "nit-standing"), args)
#+end_src

#+name: fig-nit
#+caption: Срезы взволнованной поверхности с различными распределениями волновых аппликат (Гауссово, РГШ и асимметричное нормальное).
#+RESULTS: fig-nit
[[file:build/nit.pdf]]

#+name: tab-nit-error
#+caption: Ошибка аппроксимации АКФ (разность дисперсий) для различных распределений волновых аппликат. \(N\)\nbsp{}--- количество коэффициентов аппроксимации АКФ.
#+attr_latex: :booktabs t
| Тип волн     | Распред. | \(\gamma_1\) | \(\gamma_2\) | \(\alpha\) | Ошибка | \(N\) | Высота волн |
|--------------+----------+--------------+--------------+------------+--------+-------+-------------|
|              |          |          <r> |          <r> |        <r> |    <r> |       |         <r> |
| прогрессивные | Гауссово |              |              |            |        |       |        2,41 |
| прогрессивные | РГШ      |         2,25 |          0,4 |            |   0,20 |     2 |        2,75 |
| прогрессивные | АНР      |              |              |          1 |   0,70 |     3 |        1,37 |
| стоячие      | Гауссово |              |              |            |        |       |        1,73 |
| стоячие      | РГШ      |         2,25 |          0,4 |            |   0,26 |     2 |        1,96 |
| стоячие      | АНР      |              |              |          1 |   0,70 |     3 |        0,94 |

Таким образом, единственный тестовый сценарий, который показал приемлемые
результаты\nbsp{}--- это реализации с распределением на основе РГШ для
прогрессивных и стоячих волн. Распределение АНР искажает взволнованную
поверхность для обоих типов волн. Реализации с распределением на основе РГШ
характеризуются большой ошибкой аппроксимации АКФ, что приводит к увеличению
высоты волн. Причина большой ошибки заключается в неточность ошибка
аппроксимации ряда Грама---Шарлье, которая не сходится для всевозможных
функций\nbsp{}cite:wallace1958asymptotic. Несмотря на большую ошибку, изменение
высоты волн невелико (табл.\nbsp{}[[tab-nit-error]]).

*** Нефизическая природа модели
Благодаря своей нефизической природе модель АРСС не включает в себя понятие
морской волны; вместо этого она моделирует взволнованную поверхность как единое
целое. Движения отдельных волн и их форма часто получаются грубыми, а точное
количество генерируемых волн неизвестно. Несмотря на это, интегральные
характеристики взволнованной поверхности соответствуют реальным морским волнам.

Теоретически, профили самих морских волн могут быть использованы в качестве АКФ,
если предварительно обеспечить их экспоненциальное затухание. Это может
позволить генерировать волны произвольных профилей и является одной из тем
дальнейших исследований.

* Высокопроизводительный программный комплекс для моделирования морского волнения
** Реализация для систем с общей памятью (SMP)
**** Параллельные алгоритмы для моделей АР, СС и ЛХ.
Несмотря на то что модели АР и СС являются частью одной смешанной модели АРСС,
они имеют разные параллельные алгоритмы, которые отличаются от тривиального
алгоритма модели ЛХ. Алгоритм АР заключается в разбиении взволнованной
поверхности на трехмерные части одинакового размера вдоль каждой из координатных
осей и их параллельном вычислении с учетом каузальных ограничений, накладываемых
авторегрессионными зависимостями между точками поверхности. В модели СС такие
зависимости между точками поверхности отсутствуют, а ее формула представляет
собой свертку белого шума с коэффициентами модели, которая сводится к вычислению
трех преобразований Фурье посредством теоремы о свертке. Таким образом, алгоритм
СС заключается в параллельном вычислении свертки, которая основана на
параллельном вычислении БПФ. Наконец, алгоритм ЛХ делается параллельным простым
вычислением каждой точки параллельно в нескольких потоках. Таким образом,
параллельная реализация модели АРСС включает в себя два параллельных алгоритма,
по одному для каждой составляющей модели, которые сложнее, чем алгоритм для
модели ЛХ.

Основная особенность формулы модели АР\nbsp{}--- авторегрессионные зависимости
между точками взволнованной поверхности по каждому из измерений,\nbsp{}---
который препятствуют параллельному вычислению каждой точки поверхности. Вместо
этого поверхность разделяется на равные части по каждому из измерений, и для
каждой части устанавливаются информационные зависимости, определяющие порядок
вычисления. На рис.\nbsp{}[[fig-ar-cubes]] показаны эти зависимости. Здесь стрелка
обозначает зависимость одной части от наличия другой, т.е. вычисление части
может начаться, только если все части, от которых она зависит, уже вычислены.
Здесь часть \(A\) не имеет зависимостей, части \(B\) и \(D\) зависят только от
\(A\), а часть \(E\) зависит от \(A\), \(B\) и \(C\). В общем случае, каждая
часть зависит от всех частей, имеющих предыдущий индекс хотя бы по одному из
измерений (если такие части существуют). Первая часть не имеет никаких
зависимостей, а размер части по каждому из измерений выбирается большим или
равным количеству коэффициентов по соответствующему измерению, чтобы принимать
во внимание только прилегающие части.

#+name: fig-ar-cubes
#+header: :width 5 :height 5
#+begin_src R :file build/ar-cubes-ru.pdf
source(file.path("R", "common.R"))
arma.plot_ar_cubes_2d(3, 3, xlabel="Индекс части (X)", ylabel="Индекс части (Y)")
#+end_src

#+RESULTS: fig-ar-cubes
[[file:build/ar-cubes-ru.pdf]]

Каждая часть имеет трехмерный индекс и состояние завершения. Алгоритм начинается
с отправки всех объектов, содержащих эту информацию, в очередь. После этого
параллельные потоки запускаются, каждый поток последовательно ищет первую часть,
для которой все зависимости удовлетворены (путем проверки состояния каждой из
частей), извлекает эту часть из очереди, генерирует взволнованную поверхность
для этой части и устанавливает состояние завершения. Алгоритм заканчивается,
когда очередь становится пустой. Доступ к очереди из разных потоков
синхронизируется посредством блокировок. Алгоритм подходит для SMP машин, а для
MPP части, от которых зависит данная, должны быть предварительно скопированы на
узел, на котором будут проводится вычисления.

Таким образом, параллельный алгоритм модели АР сводится к созданию
минималистичного планировщика задач, в котором
- каждая задача соответствует части взволнованной поверхности,
- порядок выполнения задач определяется авторегрессионными зависимостями, и
- очередь обрабатывается простым пулом потоков, в котором каждый поток в цикле
  извлекает из очереди первую задачу, для которой все зависимые задачи
  завершены, и выполняет ее.

В модели СС, в отличие от АР, отсутствуют авторегрессионные зависимости между
точками; вместо этого, каждая точка поверхности зависит от предыдущих по времени
и пространству значений белого шума. Формула модели СС может быть переписана как
свертка белого шума с коэффициентами модели в качестве ядра. Используя теорему о
свертке, свертка переписывается как обратное преобразование Фурье от
произведения прямых преобразования Фурье от белого шума и коэффициентов.
Поскольку количество коэффициентов СС много меньше, чем количество точек
поверхности, то параллельное БПФ не подходит, поскольку требует дополнение
массива коэффициентов нулями для того чтобы его размер совпадал с размером
массива точек поверхности. Вместо этого, поверхность разбивается на части по
каждому из измерений, который дополняются нулями, чтобы получить размер равный
количеству коэффициентов домноженному на два. Затем, преобразование Фурье
вычисляется параллельно для каждой части, домножается на заранее вычисленное
преобразование Фурье от коэффициентов и обратное преобразование Фурье
вычисляется от результата. После этого, каждая часть записывается в выходной
массив, а перекрывающие друг друга точки (из-за заполнения нулями) складываются
друг с другом. Этот алгоритм известен в области обработки сигналов как
"overlap-add"\nbsp{}cite:svoboda2011efficient. Заполнение нулями необходимо для
предотвращения маскированных ошибок: без него результатом вычислений была бы
циклическая свертка.

Несмотря на то что алгоритм модели СС разбивает поверхность на те же самые части
(но, возможно, другого размера), что и алгоритм модели АР, отсутствие
авторегрессионных зависимостей между ними позволяет вычислять из параллельно без
использования специализированного планировщика задач. Однако, этот алгоритм
также требует дополнение каждой части нулями, чтобы результат вычислений
совпадал с результатом, полученным по исходной формуле модели СС. Таким образом,
алгоритм модели СС лучше масштабируется а большое количество узлов ввиду
отсутствия информационных зависимостей между частями, но размер частей больше,
чем в алгоритме модели АР.

Отличительной особенностью алгоритма модели ЛХ является его простота: чтобы
сделать его параллельным, взволнованная поверхность разделяется на части равного
размера, каждая из которых генерируется параллельно. Между частями отсутствуют
информационные зависимости, что делает этот алгоритм подходящим для вычисления
на видеокарте: каждый аппаратный поток вычисляет свою точку поверхности. При
этом, функции синуса и косинуса в формуле модели медленно вычисляются на
процессоре, что делает видеокарту еще более выгодным выбором.

Итого, несмотря на то что модели АР и СС являются составными частями одной
смешанной модели АРСС, их параллельные алгоритмы фундаментально отличаются и
являются более сложными, чем тривиальный параллельный алгоритм модели ЛХ.
Эффективная реализация алгоритма АР требует специализированного планировщика
задач для учета авторегрессионных зависимостей между частями взволнованной
поверхности, в то время как алгоритм СС требует дополнения каждой части нулями,
чтобы иметь возможность обработать из параллельно. В отличие от этих моделей, в
модели ЛХ отсутствуют информационные зависимости между частями, но она также
требует больше вычислительных ресурсов (операций с плавающей точкой в секунду)
ввиду наличия трансцендентных функций в формуле.

**** Производительность реализаций на OpenMP и OpenCL.
:PROPERTIES:
:header-args:R: :results output raw :exports results
:END:

Разница параллельных алгоритмов моделей делает их эффективными на разных
архитектурах процессоров, и для того чтобы найти наиболее эффективную все модели
были протестированы на процессоре и видеокарте.

Модель АРСС не требует высоко оптимизированных кодов для того чтобы быть
эффективными, его производительность высокая и без использования сопроцессоров;
на это есть две причины. Во-первых, сама модель АРСС не использует
трансцендентные функции (синусы, косинусы и экспоненты) в отличие от модели ЛХ.
Все вычисления (исключая коэффициенты модели) производятся через полиномы,
которые эффективно вычисляются на современных процессорах, используя
последовательность инструкций FMA. Во-вторых, вычисления давлений происходит по
явной аналитической формуле, используя несколько БПФ. Поскольку двухмерное БПФ
одного и того же размера постоянно вычисляется на каждом временном срезе, его
коэффициенты (комплексные экспоненты) вычисляются один раз для всех временных
срезов, и дальнейшие вычисления включают в себя лишь несколько трансцендентных
функций. В случае модели СС, производительность также повышается за счет
вычисления свертки с помощью БПФ. Таким образом, высокая производительность
модели АРСС обусловлена скудным использованием трансцендентных функций и
интенсивным использованием БПФ, не говоря уже о том что высокая сходимость и
отсутствие периодичности позволяют использовать гораздо меньше коэффициентов по
сравнению с моделью ЛХ.

#+name: tab-gpulab
#+caption: Конфигурация системы Gpulab.
#+attr_latex: :booktabs t
| Процессор                    | AMD FX-8370                        |
| Память процессора            | 16ГБ                               |
| Видеокарта                   | GeForce GTX 1060                   |
| Память видеокарты            | 6ГБ                                |
| Жесткий диск                 | WDC WD40EZRZ-00WN9B0, 5400об./мин. |
| Количество процессорных ядер | 4                                  |
| Количество потоков на ядро   | 2                                  |

Программа АРСС использует несколько библиотек математических функций, численных
алгоритмов и примитивов визуализации (перечисленных в таб.\nbsp{}[[tab-arma-libs]]),
и написана с использованием нескольких технологий параллельного программирования
(OpenMP, OpenCL), чтобы найти наиболее эффективную. Для каждой технологии и
каждой модели была оптимизирована генерация взволнованной поверхности (за
исключением модели СС, для которой была сделана только реализация OpenMP).
Вычисление потенциала скорости было реализована на OpenMP, реализация на OpenCL
была сделана только для визуализации взволнованной поверхности в реальном
времени. Для каждой технологии программа перекомпилировалась, запускалась
несколько раз и измерялась производительность каждой высокоуровневой функции
посредством системных часов.

Результаты тестирования представлены в таб.\nbsp{}[[tab-arma-performance]]. Все
тесты запускались на машине с видеокартой, характеристики которой собраны в
таб.\nbsp{}[[tab-gpulab]]. Все тесты запускались с одними и теми же входными
параметрами для всех моделей: реализация длиной в 10000 сек. и размер выходной
сетки \(40\times40\)м. Единственный параметр, который отличался, это порядок
(количество коэффициентов): порядок моделей АР и СС был выбран равным \(7,7,7\),
а порядок модели ЛХ \(40,40\). Это связано с большим количеством коэффициентов,
необходимым для исключения периодичности модели ЛХ.

Во всех тестах генерация взволнованной поверхности и НБП занимают большую часть
времени счета, в то время как вычисления потенциала скорости вместе с остальными
подпрограммами лишь малую его часть.

#+name: tab-arma-libs
#+caption: Список библиотек, используемых в программе АРСС.
#+attr_latex: :booktabs t
| Библиотека                                                   | Назначение                       |
|--------------------------------------------------------------+----------------------------------|
| DCMT\nbsp{}cite:matsumoto1998dynamic                         | параллельный ГПСЧ                |
| Blitz\nbsp{}cite:veldhuizen1997will,veldhuizen2000techniques | многомерные массивы              |
| GSL\nbsp{}cite:gsl2008scientific                             | вычисление ФПР, ФР, БПФ          |
|                                                              | проверка стационарности процесса |
| LAPACK, GotoBLAS\nbsp{}cite:goto2008high,goto2008anatomy     | определение коэффициентов АР     |
| GL, GLUT\nbsp{}cite:kilgard1996opengl                        | трехмерная визуализация          |
| CGAL\nbsp{}cite:fabri2009cgal                                | триангуляция волновых чисел      |

Модель АР показывает наибольшую производительность в реализации на OpenMP и
наименьшую в реализации на OpenCL, что также является наибольшей и наименьшей
производительностью среди всех комбинация моделей и технологий. В самой
оптимальной комбинации производительность АР в 4,5 раз выше, чем
производительность СС, и в 20 раз выше, чем производительность ЛХ; в самой
неоптимальной конфигурация\nbsp{}--- в 137 раз медленней, чем СС и в два раза
медленней, чем ЛХ. Отношение между наибольшей (OpenMP) и наименьшей (OpenCL)
производительностью модели АР составляет несколько сотен. Это объясняется тем,
что формула модели\nbsp{}eqref:eq-ar-process эффективно отображается на
архитектуру центрального процессора, который отличается от видеокарты наличием
нескольких кэшей, памятью с низкой пропускной способностью и небольшим
количеством модулей для операций с плавающей точкой.
- Эта формула не содержит трансцендентных функций (синусов, косинусов и
  экспонент),
- все операции умножения и сложения в формуле реализуются посредством FMA
  инструкций процессора, и
- эффективное использование (локальность) кэша достигается путем использования
  библиотеки Blitz, которая реализует оптимизированный обход элементов
  многомерного массива, основанный на заполняющей пространство кривой Гильберта.
В отличие от центрального процессора, видеокарта имеет меньшее количество кэшей,
память с высокой пропускной способностью и большое количество модулей для
операций с плавающей точкой, что является наименее благоприятным сценарием для
модели АР.
- Формула модели АР не содержит трансцендентных функций, которые могли бы
  компенсировать высокие задержки памяти,
- в видеокарте присутствуют инструкции FMA, но они не увеличивают
  производительность из-за высоких задержек памяти, и
- оптимальный обход многомерного массива не использовался ввиду отсутствия
  библиотек, реализующих его для видеокарты.
Наконец, архитектура видеокарты не содержит примитивы синхронизации, позволяющих
эффективно реализовать авторегрессионные зависимости между отдельными частями
взволнованной поверхности; вместо этого отдельная подпрограмма OpenCL
запускается для каждой части, а управление зависимостями между ними
осуществляется на стороне центрального процессора. Таким образом, в случае
модели АР архитектура центрального процессора превосходит архитектуру
видеокарты, поскольку более эффективно обрабатывает сложные информационные
зависимости, простые вычисления (сложения и умножения) и сложные шаблоны доступа
к памяти.

#+header: :results output raw :exports results
#+name: tab-arma-performance
#+begin_src R :results output org :exports results
source(file.path("R", "benchmarks.R"))
model_names <- list(
	ar.x="АР",
	ma.x="СС",
	lh.x="ЛХ",
	ar.y="АР",
	ma.y="СС",
	lh.y="ЛХ",
  Row.names="\\orgcmidrule{2-4}{5-6}Подпрограмма"
)
row_names <- list(
  determine_coefficients="Определение коэффициентов",
  validate="Проверка модели",
  generate_surface="Генерация поверхности",
  nit="НБП",
  write_all="Запись вывода в файл",
  copy_to_host="Копирование данных с GPU",
  velocity="Выч. потенциалов скорости"
)
arma.print_openmp_vs_opencl(model_names, row_names)
#+end_src

#+name: tab-arma-performance
#+caption: Время работы (с.) реализации OpenMP и OpenCL для моделей АР, СС и ЛХ.
#+attr_latex: :booktabs t
#+RESULTS: tab-arma-performance
|                                    |      |      | OpenMP |        | OpenCL |
| \orgcmidrule{2-4}{5-6}Подпрограмма |   АР |   СС |     ЛХ |     АР |     ЛХ |
|------------------------------------+------+------+--------+--------+--------|
| Определение коэффициентов          | 0.02 | 0.01 |   0.19 |   0.01 |   1.19 |
| Проверка модели                    | 0.08 | 0.10 |        |   0.08 |        |
| Генерация поверхности              | 1.26 | 5.57 | 350.98 | 769.38 |   0.02 |
| НБП                                | 7.11 | 7.43 |        |   0.02 |        |
| Копирование данных с GPU           |      |      |        |   5.22 |  25.06 |
| Выч. потенциалов скорости          | 0.05 | 0.05 |   0.06 |   0.03 |   0.03 |
| Запись вывода в файл               | 0.27 | 0.27 |   0.27 |   0.28 |   0.27 |

В отличие от модели АР, модель ЛХ показывает наибольшую производительность на
видеокарте и наименьшую производительность на центральном процессоре. Причиной
этому служат
- большое количество трансцендентных функций в ее формуле, которые компенсируют
  высокие задержки памяти,
- линейный шаблон доступа к памяти, который позволяет векторизовать вычисления и
  объединить операции доступа к памяти из разных потоков, и
- отсутствие информационных зависимостей между точками взволнованной
  поверхности.
Несмотря на то что видеокарта на тестовой системе более производительна, чем
центральный процессор (с точки зрения операций с плавающей точкой в секунду),
общая производительность модели ЛХ по сравнению с моделью АР меньше. Причиной
этого служит медленная передача данных между памятью видеокарты и центрального
процессора.

Модель СС быстрее, чем модель ЛХ, но медленнее, чем модель АР. Поскольку свертка
в ее формуле реализована с помощью БПФ, ее производительность зависит от
производительности реализации БПФ: библиотека GSL для центрального процессора и
clFFT для видеокарты. В данной работе производительность модели СС на видеокарте
не была протестирована ввиду недоступности трехмерного БПФ в библиотеке clFFT;
если бы преобразование было доступно, оно могло бы сделать модель даже более
быстрой, чем АР.

НБП занимает меньше времени на видеокарте, чем на центральном процессоре,
однако, если принять во внимание время передачи данных между ними, время
становится сопоставимым. Это объясняется большим количеством трансцендентных
функций, которые необходимо вычислить для каждой точки взволнованной поверхности
для преобразования ее координат \(z\). Для каждой точки нелинейное
трансцендентное уравнение\nbsp{}eqref:eq-distribution-transformation решается
методом бисекции. Видеокарта выполняет эту задачу в несколько сотен раз быстрее,
чем центральный процессор, но тратит много времени на передачу результата
обратно в память процессора. Таким образом, единственная возможность
оптимизировать эту подпрограмму заключается в использовании метода поиска корня
уравнения с квадратичной сходимостью, чтобы уменьшить количество трансцендентных
функций, которые необходимо вычислить.

**** Производительность ввода-вывода.
:PROPERTIES:
:header-args:R: :results output raw :exports results
:END:

Несмотря на то что в тестах из предыдущего раздела запись данных в файлы не
занимает большое количество времени, использование монтируемых по сети файловых
систем может замедлить этот этап программы. Для его оптимизации части
взволнованной поверхности записываются в файл, как только генерация всего
временного среза завершена (рис.\nbsp{}[[fig-arma-io-events]]): запускается
отдельный поток, который начинает запись, как только первый временной срез
становится доступен, и завершает, после того как основная группа потоков
заканчивает вычисления, и последний срез записывается в файл. Суммарное время,
затрачиваемое на ввод/вывод, увеличиваться, но суммарное время работы программы
уменьшается, поскольку ввод/вывод производится параллельно вычислениям
(таб.\nbsp{}[[tab-arma-io-performance]]). Использование этого подхода для локальных
систем имеет тот же эффект, но выигрыш в производительности меньше.

#+header: :results output raw :exports results
#+name: tab-arma-io-performance
#+begin_src R
source(file.path("R", "benchmarks.R"))
suffix_names <- list(
  xfs.x="XFS",
  xfs.y="XFS",
  nfs.x="NFS",
  nfs.y="NFS",
  gfs.x="GlusterFS",
  gfs.y="GlusterFS",
  Row.names="\\orgcmidrule{2-4}{5-7}Подпрограмма"
)
top_names <- c("Последовательная", "Параллельная")
row_names <- list(
  generate_surface="Генерация поверхности",
  write_all="Запись вывода в файл"
)
arma.print_sync_vs_async_io(suffix_names, row_names, top_names)
#+end_src

#+name: tab-arma-io-performance
#+caption: Время работы подпрограмм (сек.) при использовании файловых систем XFS, NFS и GlusterFS совместно с последовательным и параллельным выводом в файл.
#+attr_latex: :booktabs t
#+RESULTS: tab-arma-io-performance
|                                    |      |      | Последовательная |      |      | Параллельная |
| \orgcmidrule{2-4}{5-7}Подпрограмма |  XFS |  NFS |        GlusterFS |  XFS |  NFS |    GlusterFS |
|------------------------------------+------+------+------------------+------+------+--------------|
| Генерация поверхности              | 1.26 | 1.26 |             1.33 | 1.33 | 3.30 |        11.06 |
| Запись вывода в файл               | 0.28 | 2.34 |            10.95 | 0.00 | 0.00 |         0.00 |

#+name: fig-arma-io-events
#+header: :width 6 :height 8 :results output graphics
#+begin_src R :file build/arma-io-events-ru.pdf
source(file.path("R", "benchmarks.R"))
names <- list(
  xlab="Время, сек.",
  ylab="Поток"
)
par(mfrow=c(3,1), family="serif")
arma.plot_io_events(names)
#+end_src

#+name: fig-arma-io-events
#+caption: График событий для XFS, NFS и GlusterFS, показывающий временные интервалы для каждого из потоков, на протяжении которых производится запись в файл (красный) и вычисления (черный).
#+RESULTS: fig-arma-io-events
[[file:build/arma-io-events-ru.pdf]]

**** Параллельное вычисление поля потенциала скорости.
Тесты для моделей АР, СС, и ЛХ показали, что вычисление поля потенциала скорости
занимает лишь малую долю суммарного времени работы программы, однако, абсолютное
время вычисления на плотной сетке \(XY\) может быть большим. Одно из приложений,
в котором используется плотная сетка,\nbsp{}--- это имитационное моделирование и
визуализация в реальном времени взволнованной поверхности. Визуализации в
реальном времени позволяет
- настроить параметры модели и АКФ, мгновенно получая результат изменений, и
- визуально сравнить размер и форму областей, в которых сконцентрирована
  основная часть энергии волн, для образовательных целей.

Поскольку визуализация производится на видеокарте, вычисление потенциала
скорости на центральном процессоре может сделать передачу данных между памятью
двух устройств узким местом. Для того чтобы обойти это, программа использует
программный интерфейс взаимодействия OpenCL/OpenGL, позволяющий создавать
буферы, используемые совместно контекстами OpenCL и OpenGL, что исключает
копирование данных между устройствами. Кроме того, формула трехмерного поля
потенциала скорости\nbsp{}eqref:eq-phi-3d особенно подходит для вычисления на
видеокарте:
- она содержит трансцендентные функции (гиперболические косинусы и комплексные
  экспоненты);
- она вычисляется на большой четырехмерной области \((t,x,y,z)\);
- она явная и не имеет информационных зависимостей между отдельными точками в
  измерениях \(t\) и \(z\).

Для того чтобы выяснить, насколько использование видеокарты может ускорить
вычисления поля потенциала скорости, была протестирована упрощенная
версия\nbsp{}eqref:eq-phi-3d:
\begin{align}
    \label{eq:phi-linear}
    \phi(x,y,z,t) &= \InverseFourierY{
        \frac{ \Sinh{\smash{2\pi \Kveclen (z+h)}} }
        { 2\pi\Kveclen \Sinh{\smash{2\pi \Kveclen h}} }
        \FourierY{ \zeta_t }{u,v}
    }{x,y}\nonumber \\
    &= \InverseFourierY{ g_1(u,v) \FourierY{ g_2(x,y) }{u,v} }{x,y}.
\end{align}
Код, вычисляющий потенциал скорости, был переписан на языке OpenCL и его
производительность сравнивалась с реализацией на OpenMP.

Для каждой реализации измерялось время работы выбранных подпрограмм и время
передачи данных между устройствами. Поле потенциала скорости вычислялось для
одной точки по оси \(t\), 128 точек по оси \(z\), расположенных под
взволнованной поверхностью, и для каждой точки по оси \(x\) и \(y\)
четырехмерной сетки \((t,x,y,z)\). Между запусками программы изменялся размер
сетки по оси \(x\).

В реализациях используются разные библиотеки БПФ: GNU Scientific Library
(GSL)\nbsp{}cite:galassi2015gnu для OpenMP и clFFT\nbsp{}cite:clfft для OpenCL.
Подпрограммы БПФ из этих библиотек отличаются друг от друга.
- Порядок частот в БПФ у обоих библиотек разный. В случае clFFT элементы
  результирующего массива дополнительно сдвигаются, чтобы соответствовать
  корректному полю потенциала скорости. В случае GSL никакого сдвига не
  требуется.
- Разрыв в точках сетки \((x,y)=(0,0)\) обрабатывается библиотекой clFFT
  автоматически, в то время как библиотека GSL выдает искаженные значения в этой
  точке, поэтому с случае GSL значения в этих точках интерполируются.
Другие отличия подпрограмм БПФ, влияющие на производительность, не были
найдены.

**** Производительность кода OpenCL, вычисляющего поле потенциала скорости.
:PROPERTIES:
:header-args:R: :results output raw :exports results
:END:

Эксперименты показали, что реализация OpenCL превосходит OpenMP по
производительности в 10--15 раз (рис.\nbsp{}[[fig-arma-realtime-graph]]), однако,
распределение времени работы между подпрограммами отличается
(таб.\nbsp{}[[tab-arma-realtime]]). В случае процессора больше всего времени
тратится на вычисление \(g_1\), а в случае видеокарты время вычисления \(g_1\)
сопоставимо с \(g_2\). Копирование результирующего поля потенциала скорости
между процессором и видеокартой занимает \(\approx{}20\%\) общего времени
вычисления этого поля. Вычисление \(g_2\) занимает больше всего времени в случае
OpenCL и меньше всего времени в случае OpenMP. В обоих реализациях \(g_2\)
вычисляется на центральном процессоре, поскольку готовая подпрограмма вычисления
производной на OpenCL не была найдена. В случае OpenCL результат вычислений
дублируется для каждой точки сетки по оси \(z\), для того чтобы перемножить все
точки одного временного среза в одной подпрограмме OpenCL, а, затем, копируется
в память видеокарты, что негативно сказывается на производительности. Все тесты
запускались на машине с видеокартой, характеристики которой просуммированы в
таб.\nbsp{}[[tab-storm]].

#+name: tab-storm
#+caption: Конфигурация вычислительной системы Storm.
#+attr_latex: :booktabs t
| Процессор                    | Intel Core 2 Quad Q9550          |
| Память процессора            | 8ГБ                              |
| Видеокарта                   | AMD Radeon R7 360                |
| Память видеокарты            | 2ГБ                              |
| Жесткий диск                 | Seagate Barracuda, 7200 об./мин. |
| Количество процессорных ядер | 4                                |

#+name: fig-arma-realtime-graph
#+header: :results output graphics
#+begin_src R :file build/realtime-performance-ru.pdf
source(file.path("R", "benchmarks.R"))
par(family="serif")
data <- arma.load_realtime_data()
arma.plot_realtime_data(data)
title(xlab="Размер взволнованной поверхности по оси OX", ylab="Время, сек.")
#+end_src

#+name: fig-arma-realtime-graph
#+caption: Сравнение производительности версий кода, вычисляющего поле потенциала скорости, для центрального процессора (OpenMP) и видеокарты (OpenCL).
#+RESULTS: fig-arma-realtime-graph
[[file:build/realtime-performance-ru.pdf]]

Причина разного распределения времени работы между подпрограммами OpenCL и
OpenMP та же, что и в случае разной производительности модели АР на центральном
процессоре и видеокарте: видеокарта выполняет больше операций с плавающей точкой
в секунду и имеет больше модулей трансцендентных функций, чем процессор, что
ускоряет вычисление \(g_1\), но в ней отсутствует кэш, который необходим для
оптимизации нерегулярного шаблона доступа к памяти при вычислении \(g_2\). В
отличие от модели АР, производительность вычисления многомерной производной на
видеокарте легче увеличить ввиду отсутствия информационных зависимостей между
точками: в данной работе оптимизация не была проведена ввиду отсутствия готовой
реализации. Кроме того, такая реализация может позволить эффективно вычислить
неупрощенную формулу полностью на видеокарте, поскольку опущенные в формуле
функции также содержат производные.

#+name: tab-arma-realtime
#+begin_src R
source(file.path("R", "benchmarks.R"))
routine_names <- list(
  harts_g1="Функция \\(g_1\\)",
  harts_g2="Функция \\(g_2\\)",
  harts_fft="БПФ",
  harts_copy_to_host="Копирование данных с видекарты"
)
column_names <- c("Подпрограмма", "Время OpenMP, сек.", "Время OpenCL, сек.")
data <- arma.load_realtime_data()
arma.print_table_for_realtime_data(data, routine_names, column_names)
#+end_src

#+name: tab-arma-realtime
#+caption: Время работы подпрограмм вычисления поля потенциала скорости в реальном времени для взволнованной поверхности (размер по \(OX\) равен 16384).
#+attr_latex: :booktabs t
#+RESULTS: tab-arma-realtime
| Подпрограмма                    | Время OpenMP, сек. | Время OpenCL, сек. |
|---------------------------------+--------------------+--------------------|
| Функция \(g_1\)                 |             4.6730 |             0.0038 |
| Функция \(g_2\)                 |             0.0002 |             0.8253 |
| БПФ                             |             2.8560 |             0.3585 |
| Копирование данных с видеокарты |                    |             2.6357 |

Как и ожидалось, совместное использование одного буфера контекстами OpenCL и
OpenGL увеличивает производительность путем исключения копирования данных между
памятью центрального процессора и видеокарты, но также требует, чтобы данные
были в формате вершин, с которым непосредственно работает OpenGL. Преобразование
в этот формат выполняется быстро, однако он требует больше памяти, поскольку
каждая точка записывается как вектор из трех компонент. Другим недостатком
совместного использования OpenCL и OpenGL является требование ручной блокировки
общего буфера: невыполнение этого требования может стать причиной артефактов
изображения на экране, которые можно убрать, только перезагрузив компьютер.

**** Заключение.
Тесты показали, что видеокарта превосходит центральный процессор по
производительности в задачах с большим количеством арифметических операций,
требующих большое количество операций с плавающей точкой в секунду, однако,
производительность падает, когда объем данных, которые нужно скопировать между
памятью процессора и видеокарты, увеличивается или, когда шаблон доступа к
памяти отличается от линейного. Первая проблема может быть решена путем
использования сопроцессора, в котором память с высокой пропускной способностью
расположена на одной плате вместе с процессором и основной памятью. Это
исключает узкое место при пересылке данных, но может также увеличить время
выполнения ввиду меньшего количества модулей для операций с плавающей точкой.
Вторую проблему можно решить программно, при наличии библиотеки для вычисления
многомерных производных на OpenCL.

Модели АР и СС превосходят модель ЛХ в тестах производительности и для этого не
требуется наличие видеокарты. Их сильными сторонами с вычислительной точки
зрения являются
- отсутствие трансцендентных функций, и
- простые алгоритмы, производительность которых зависит от производительности
  библиотеки для многомерных массивов и библиотеки для БПФ.
Обеспечение основного функционала посредством низкоуровневых библиотек делает
производительность программы переносимой: поддержка новых архитектур процессоров
может быть добавлена путем замены библиотек. Наконец, использование явной
формулы позволяет тратить лишь небольшую долю суммарного времени работы
программы на вычисление поля потенциала скорости. Если бы такой формулы не было
или она не содержала бы интегралы в виде преобразований Фурье, на вычисление
поля потенциала скорости затрачивалось бы гораздо больше времени.

** Отказоустойчивый планировщик пакетных задач
*** Архитектура системы
**** Физический уровень.
Состоит из узлов и прямых/маршрутизируемых физических сетевых соединений. На
этом уровне предполагается полная сетевая связность, т.е.\nbsp{}возможность
отправить сетевой пакет между любой парой узлов кластера.

**** Уровень резидентных процессов.
Состоит из процессов, находящихся на узлах кластера и иерархических логических
связей (главный/подчиненный) между ними. На каждом узле запущен ровно один
процесс, поэтому эти понятия взаимозаменяемы в данной работе. Роль главного и
подчиненного назначается резидентным процессам динамически, т.е.\nbsp{}любой
физический узел может стать главным или подчиненным, или быть и тем и другим
одновременно. Динамический выбор ролей использует алгоритм выбора лидера, не
требующий периодической отправки широковещательных сообщений всем узлам
кластера, вместо этого роль определяется IP-адресом узла. Подробное описание
алгоритма приведено в разд.\nbsp{}[[#sec-node-discovery]]. Его сильными сторонами
являются масштабируемость на большое количество узлов и низкие накладные
расходы, что делает его пригодным для высокопроизводительных вычислений; его
слабой стороной является искусственная зависимость места, занимаемого узлом в
иерархии, от его IP-адреса, что делает его непригодным для виртуальных сред, где
IP-адрес узла может динамически меняться.

Единственным предназначением древовидной иерархии состоит в балансировке
нагрузки между узлами кластера. Нагрузка распределяется от текущего узла к его
соседям в иерархии путем простой итерации по ним. Когда в иерархии появляются
новые связи или меняются старые (из-за того что новый узел присоединяется к
кластеру или работающий узел выходит из строя), резидентные процессы
обмениваются сообщениями, передавая друг другу количеством узлов, находящихся
/за/ соответствующей связью в иерархии. Эта информация используется для
равномерного распределения нагрузки, даже если распределенная программа
запускается на подчиненном узле. Кроме того, иерархия уменьшает количество
одновременных сетевых соединений между узлами: на каждую связь в иерархии
устанавливается и поддерживается только одно соединение\nbsp{}--- что уменьшает
вероятность возникновения перегрузки сети при большом количестве узлов в
кластере.

Балансировка нагрузки реализована следующим образом. Когда узел \(A\) пытается
стать подчиненным узлу \(B\), он отправляет сообщение на соответствующий
IP-адрес, передавая, сколько узлов уже связаны с ним в иерархии (включая себя
самого). После того как все связи в иерархии установлены, каждый узел имеет
достаточно информации, чтобы сказать, сколько узлов находится за каждой из его
связей, а суммарное количество узлов за всеми связями равно общему количеству
узлов в кластере. Если это связь между главным и подчиненным узлом, и
подчиненный узел хочет узнать, сколько узлов находится за связью с главным, то
из суммарного количества узлов за связями главного со всеми его подчиненным
узлами он вычитает количество узлов за главным, чтобы получить правильную сумму.
Для распределения управляющих объектов (см.\nbsp{}разд.\nbsp{}[[#sec-kernel-layer]])
между узлами используется циклический алгоритм (round-robin),
т.е.\nbsp{}производится итерации по всем связям текущего узла, включая связь с
главным узлом, и, принимая во внимание количество узлов, находящихся за каждой
из связей. Таким образом, даже если программа запускается на подчиненном узле,
находящимися внизу иерархии, ее управляющие объекты распределяются равномерно
между всеми узлами кластера.

Предложенный подход может быть расширен, включив сложную логику в алгоритм
распределения нагрузки. Вместе с количеством узлов, находящихся за связью в
иерархии, может быть отправлена любая метрика, которая необходима для реализации
этой логики. Однако, если эта метрика обновляется чаще, чем изменяется иерархия,
или периодически, то и сообщения с изменениями будут отправляться чаще. Для того
чтобы эти пересылки не повлияли на производительность программ, для них можно
использовать отдельную физическую сеть. Также, когда происходит изменение
иерархии, управляющие объекты, которые уже отправлены на узлы до этого
изменения, не учитываются при распределении нагрузки, из-за чего частые
изменения иерархии могут стать причиной неравномерной загруженности узлов
кластера (которая, однако, станет равномерной со временем).

Динамическое назначение ролей главного и подчиненного узла вместе с
распределением управляющих объектов делает архитектуру системы однородной в
рамках одного кластера. На каждом узле запущен один и тот же резидентный
процесс, и никакой предварительной конфигурации не требуется, чтобы объединить
процессы на разных узлах в иерархию.

**** Уровень управляющих объектов.
:PROPERTIES:
:CUSTOM_ID: sec-kernel-layer
:END:

Ключевая особенность, отсутствующая в текущих технологиях параллельного
программирования,\nbsp{}--- это возможность задавать иерархические зависимости
между параллельно выполняющимися задачами. Когда такая зависимость есть,
руководящая задача становится ответственной за перезапуск подчиненной,
завершившейся неудачно, на оставшихся узлах кластера. Для того чтобы иметь
возможность перезапустить задачу, у которой нету задачи, главенствующей над ней,
создается копия, и отправляется на другой узел
(см.\nbsp{}разд.\nbsp{}[[#sec-fail-over]]). Существует несколько систем, которые
способны выполнять направленные ациклические графы задач
параллельно\nbsp{}cite:acun2014charmpp,islam2012oozie, однако, графы не подходят
для определения связей руководитель-подчиненный между задачами, поскольку
вершина графа может иметь несколько входящих ребер, а значит несколько
руководящих узлов.

Основное назначение предлагаемого подхода состоит в упрощении разработки
распределенных приложений для пакетной обработки и промежуточного программного
обеспечения, а идея состоит в обеспечении отказоустойчивости на самом низком из
возможных уровней. Реализация разделена на два слоя: нижний слой состоит из
подпрограмм и классов для приложений, работающих на одном узле (без
взаимодействия по сети), а верхний слой предназначен для приложений, работающих
на произвольном количестве узлов. Предполагается наличие двух типов сильно
связанных сущностей\nbsp{}--- это /управляющие объекты/ (или /объекты/ для
краткости) и /конвейеры/,\nbsp{}--- которые составляют основу программы.

Управляющие объекты реализуют логику (порядок выполнения) программы в методах
~act~ и ~react~ и хранят состояние текущей ветки исполнения. Как логика так и
состояние задаются программистом. В методе ~act~ какая-либо функция либо
вычисляется непосредственно, либо разлагается на вложенные функции
(представляемые подчиненными управляющими объектами), которые впоследствии
отправляются на конвейер. В методе ~react~ подчиненные управляющие объекты,
вернувшиеся с конвейера, обрабатываются их родительским объектом. Вызовы методов
~act~ и ~react~ производятся асинхронно внутри потоков, присоединенных к
конвейеру. Для каждого управляющего объекта метод ~act~ вызывается только один
раз, и для нескольких объектов вызовы происходят параллельно друг другу, в то
время как метод ~react~ вызывается один раз для каждого подчиненного объекта, и
все вызовы происходят в одном потоке для предотвращения одновременного изменения
состояния несколькими потоками (для разных родительских объектов могут
использоваться разные потоки).

Конвейеры осуществляют асинхронные вызовы методов ~act~ и ~react~, стараясь
сделать как можно больше вызовов параллельно, учитывая предоставляемый
платформой параллелизм (количество процессорных ядер на узле и количество узлов
в кластере). Конвейер включает в себя пул управляющих объектов, содержащий все
подчиненные объекты, отправленные в него родителями, и пул потоков,
обрабатывающий эти объекты в соответствии с правилами, описанными в предыдущем
параграфе. Для каждого устройства используется отдельный конвейер. Существуют
конвейеры для параллельной обработки, обработки по расписанию (периодические и
отложенные задачи) и промежуточный конвейер для обработки управляющих объектов
на узлах кластера (см.\nbsp{}рис.\nbsp{}[[fig-subord-ppl]]).

По принципу работу механизм управляющих объектов и конвейеров напоминает
механизм работы процедур и стеков вызовов, с тем лишь преимуществом, что методы
объектов вызываются асинхронно и параллельно друг другу (насколько это позволяет
логика программы). Поля управляющего объекта\nbsp{}--- это локальные переменные
стека, метод ~act~\nbsp{}--- это последовательность процессорных инструкций
перед вложенным вызовом процедуры, а метод ~react~\nbsp{}--- это
последовательность инструкций после вложенного вызова. Создание и отправка на
конвейер подчиненного объекта\nbsp{}--- это вложенный вызов процедуры. Наличие
двух методов обуславливается асинхронностью вложенных вызовов и помогает
заменить активное ожидание завершения подчиненных объектов пассивным при помощи
конвейеров. Конвейеры, в свою очередь, позволяют реализовать пассивное ожидание
и вызывают правильные методы, анализируя внутреннее состояние объектов.

#+name: fig-subord-ppl
#+begin_src dot :exports results :file build/subord-ppl-ru.pdf
graph G {

  node [fontname="Old Standard",fontsize=14,margin="0.055,0",shape=box]
  graph [nodesep="0.25",ranksep="0.25",rankdir="LR"]
  edge [arrowsize=0.66]

  subgraph cluster_daemon {
    label="Родительский процесс"
    style=filled
    color=lightgrey

    factory [label="Фабрика"]
    parallel_ppl [label="Параллельный\nконвейер"]
    io_ppl [label="Конвейер\nввода/вывода"]
    sched_ppl [label="Конвейер\nдля таймера"]
    net_ppl [label="Конвейер для\nсетевых устройств"]
    proc_ppl [label="Конвейер\nдля процессов"]

    upstream [label="Пул потоков\nupstream"]
    downstream [label="Пул потоков\ndownstream"]
  }

  factory--parallel_ppl
  factory--io_ppl
  factory--sched_ppl
  factory--net_ppl
  factory--proc_ppl

  subgraph cluster_hardware {
    label="Вычислительные устройства"
    style=filled
    color=lightgrey

    cpu [label="CPU"]
    core0 [label="Ядро 0"]
    core1 [label="Ядро 1"]
    core2 [label="Ядро 2"]
    core3 [label="Ядро 3"]

    storage [label="Устройства\nхранения"]
    disk0 [label="Диск 0"]

    network [label="Сетевые\nкарты"]
    nic0 [label="СК 0"]

    timer [label="Таймер"]

  }

  core0--cpu
  core1--cpu
  core2--cpu
  core3--cpu

  disk0--storage
  nic0--network

  parallel_ppl--upstream
  parallel_ppl--downstream

  upstream--{core0,core1,core2,core3} [style="dashed"]
  downstream--core0 [style="dashed"]

  io_ppl--core0 [style="dashed"]
  io_ppl--disk0 [style="dashed"]
  sched_ppl--core0 [style="dashed"]
  sched_ppl--timer [style="dashed"]
  net_ppl--core0 [style="dashed"]
  net_ppl--nic0 [style="dashed"]
  proc_ppl--core0 [style="dashed"]

  subgraph cluster_children {
    style=filled
    color=white

    subgraph cluster_child0 {
      label="Дочерний процесс 0"
      style=filled
      color=lightgrey

      app0_factory [label="Фабрика"]
      app0 [label="Конвейер\nдочернего\nпроцесса"]
    }

#    subgraph cluster_child1 {
#      label="Дочерний процесс 1"
#      style=filled
#      color=lightgrey
#
#      app1_factory [label="Фабрика"]
#      app1 [label="Конвейер\nдочернего процесса"]
#    }
  }

  proc_ppl--app0
#  proc_ppl--app1

  app0_factory--app0 [constraint=false]
#  app1_factory--app1 [constraint=false]

}
#+end_src

#+caption: Отображение конвейеров родительского и дочернего процессов на вычислительные устройства. Сплошные линии обозначают агрегацию, пунктирные линии обозначают отображение между логическими и физическими сущностями.
#+attr_latex: :width \textwidth
#+label: fig-subord-ppl
#+RESULTS: fig-subord-ppl
[[file:build/subord-ppl-ru.pdf]]

**** Программная реализация.
Из соображений эффективности конвейер объектов и методы обеспечения
отказоустойчивости (которые будут описаны далее) были реализованы во фреймворке
на языке C++: с точки зрения автора язык C слишком низкоуровневый для написания
распределенных программ, а использование языка Java влечет за собой накладные
расходы, и не популярно в высокопроизводительных вычислениях. Фреймворк
называется Bscheduler и находится на этапе проверки концепции.

**** Программный интерфейс.
Каждый управляющий объект имеет четыре типа полей (перечисленных в
табл.\nbsp{}[[tab-kernel-fields]]):
- поля, относящиеся к управлению потоком исполнения,
- поля, определяющие исходное местонахождение управляющего объекта,
- поля, определяющие текущее местонахождение управляющего объекта и
- поля, определяющие целевое местонахождение управляющего объекта.

#+name: tab-kernel-fields
#+caption: Описание полей управляющего объекта.
#+attr_latex: :booktabs t :align lp{0.7\textwidth}
| Поле              | Описание                                                                                                       |
|-------------------+----------------------------------------------------------------------------------------------------------------|
| ~process_id~      | Идентификатор процесса (приложения) в рамках кластера, которому принадлежит управляющий объект.                |
| ~id~              | Идентификатор управляющего объекта внутри процесса.                                                            |
| ~pipeline~        | Идентификатор конвейера, который обрабатывает управляющий объект.                                              |
|                   |                                                                                                                |
| ~exit_code~       | Результат выполнения управляющего объекта.                                                                     |
| ~flags~           | Вспомогательный битовые флаги, используемые при планировании.                                                  |
| ~time_point~      | Момент времени, в который запланировано выполнение управляющего объекта.                                       |
|                   |                                                                                                                |
| ~parent~          | Адрес/идентификатор родительского объекта.                                                                     |
| ~src_ip~          | IP-адрес исходного узла кластера.                                                                              |
| ~from_process_id~ | Идентификатор процесса в рамках кластера, из которого пришел управляющий объект.                               |
|                   |                                                                                                                |
| ~principal~       | Адрес/идентификатор целевого управляющего объекта (объекта, к которому текущий направляется или возвращается). |
| ~dst_ip~          | IP-адрес целевого узла кластера.                                           |

При создании каждому управляющему объекту присваивается адрес родительского
объекта и идентификатор конвейера. Если другие поля не установлены, то
управляющий объект является /upstream/-объектом\nbsp{}--- объектом, который
можно распределить на любой узел кластера и любое ядро процессора для извлечения
параллелизма. Если адрес целевого управляющего объекта установлен, то объект
является /downstream/-объектом\nbsp{}--- объектом, который можно направить
только к целевому, а ядро процессора, на которое будет направлен этот объект,
определяется адресом/идентификатором целевого объекта. Если downstream-объект
предполагается направить на другой узел, то IP-адрес целевого узла должен быть
установлен, иначе система не сможет найти целевой объект.

Когда выполнение управляющего объекта завершается (после завершения метода
~act~), этот объект явно направляется к какому-либо другому объекту, эта
директива явно вызывается в методе ~act~. Обычно, по окончании выполнения
объекта, он направляется к своему родительскому объекту путем установки поля
~principal~ в значение адреса/идентификатора родителя, целевого IP-адреса в
значение исходного IP-адреса и идентификатора процесса в значение идентификатора
исходного процесса. После этого управляющий объект становится
downstream-объектом, направляется системой на узел, где находится его текущий
руководитель, без использования алгоритма балансировки нагрузки. Для
downstream-объектов метод ~react~ их родителя вызывается конвейером с текущим
объектом в качестве аргумента, чтобы позволить родителю собрать результат
выполнения объекта.

Не существует способа предоставить мелкозернистую отказоустойчивость к сбоям
узлов кластера, если в программе присутствуют downstream-объекты кроме тех, что
возвращаются к своим родителям. Вместо этого, код завершения управляющего
объекта проверяется и пользовательская подпрограмма для восстановления
выполняется. Если проверки на ошибку не выполняется, система перезапускает
выполнение, начиная с первого родительского объекта, который не создавал
downstream-объектов. Это означает, что если решаемая программой задача имеет
информационные зависимости между частями вычисляемыми параллельно, и узел
выходит из строя во время вычисления этих частей, то эти вычисления
перезапускается с самого начала, отбрасывая части, вычисленные ранее. Такого не
происходит в высоко параллельных программах, где параллельные части не имеют
таких информационных зависимостей между друг другом: в этом случае только части
с вышедших из строя узлов вычисляются заново, а все ранее вычисленные части
сохраняются.

В отличие от функции ~main~ программ, основанных на библиотеке MPI, первый
(главный) управляющий объект изначально запускается только на одном узле, а
другие узлы кластеры используются при необходимости. Это позволяет использовать
больше узлов для участков кода с большой степенью параллелизма, и меньше для
других участков. Похожий подход применяется во фреймворках для обработки больших
объемов данных\nbsp{}cite:dean2008mapreduce,vavilapalli2013yarn --- узлы, на
которых будет выполняться задача выбираются в зависимости от того, где физически
находятся входные файлы.

**** Отображение алгоритма генерации взволнованной поверхности на архитектуру системы.
Модель АРСС реализована в программном комплексе, работающем по принципу
вычислительного конвейера, в котором каждое звено применяет некоторую функцию к
выходным данным предыдущего звена. Звенья конвейера распределяются по узлам
вычислительного кластера, чтобы сделать возможным параллелизм по операциям, а
затем данные, перемещающиеся между звеньями конвейера распределяются между
ядрами процессора, чтобы сделать возможным параллелизм по данным. На
рис.\nbsp{}[[fig-pipeline]] представлена схема конвейера обработки данных, в которой
прямоугольниками со скругленными углами обозначены звенья конвейера, обычными
прямоугольниками\nbsp{}--- массивы объектов из предметной области задачи,
передаваемые от одного звена к другому, а стрелками\nbsp{}--- направление
передачи данных. Некоторые звенья разделены на /секции/, каждая из которых
обрабатывает отдельную часть массива. Если звенья соединены без использования
/барьера/ (горизонтальная или вертикальная полоса), то передача отдельных
объектов между такими звеньями происходит параллельно с вычислениями, по мере их
готовности. Секции работают параллельно на нескольких ядрах процессора
(нескольких узлах кластера). Таким образом, между множеством ядер процессора,
секций звеньев конвейера и объектами устанавливается сюръективное отображение,
т.е. на одном ядре процессора может работать несколько секций звеньев конвейера,
каждая из которых может обрабатывать несколько объектов последовательно, но одна
секция не может работать сразу на нескольких ядрах, а объект не может
обрабатываться сразу несколькими секциями конвейера.

#+name: fig-pipeline
#+begin_src dot :exports results :file build/pipeline-ru.pdf
digraph {

  node [fontsize=14,margin="0.055,0"]
  graph [nodesep="0.25",ranksep="0.25",rankdir="TB"]
  edge [arrowsize=0.66]

  # data
  subgraph xcluster_linear {
    label="Линейная модель"

    start [label="",shape=circle,style=filled,fillcolor=black,width=0.23]
    spectrum [label="S(ω,θ)",shape=box]
    acf [label="K(i,j,k)",shape=box]
    phi [label="Φ(i,j,k)",shape=box]

    # transformations
    fourier_transform [label="Преобразование Фурье",shape=box,style=rounded]
    solve_yule_walker [label="Решение уравнений\nЮла—Уокера",shape=box,style=rounded]

    subgraph cluster_nonlinear_1 {
      label="Моделир. нелинейности\l"
      labeljust=left
      style=filled
      color=lightgrey
      acf2 [label="K*(i,j,k)",shape=box]
      transform_acf [label="Преобразование АКФ",shape=box,style=rounded]
    }
  }

  subgraph xcluster_linear2 {

    eps_parts [label="<e1> ε₁|<e2> ε₂|<e3> …|<e4> εₙ|<e> ε(t,x,y)",shape=record]
    end [label="",shape=doublecircle,style=filled,fillcolor=black,width=0.23]

    generate_white_noise [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Генерация\lбелого шума",shape=record,style=rounded]
    generate_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Генерация частей\lвзволнованной мор-\lской поверхности\l",shape=record,style=rounded]

    zeta_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Несшитые части реализации",shape=record]
    overlap_add [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Сшивание час-\lтей реализации\l",shape=record,style=rounded]

    zeta_parts:g1->overlap_add:g1
    zeta_parts:g2->overlap_add:g2
    zeta_parts:g3->overlap_add:g3
    zeta_parts:g4->overlap_add:g4

    zeta_parts:g2->overlap_add:g1 [constraint=false]
    zeta_parts:g3->overlap_add:g2 [constraint=false]
    zeta_parts:g4->overlap_add:g3 [constraint=false]

    overlap_add:g1->zeta2_parts:g1
    overlap_add:g2->zeta2_parts:g2
    overlap_add:g3->zeta2_parts:g3
    overlap_add:g4->zeta2_parts:g4

    zeta2_parts:g1->transform_zeta:g1->zeta3_parts:g1->write_zeta:g1->eps_end
    zeta2_parts:g2->transform_zeta:g2->zeta3_parts:g2->write_zeta:g2->eps_end
    zeta2_parts:g3->transform_zeta:g3->zeta3_parts:g3->write_zeta:g3->eps_end
    zeta2_parts:g4->transform_zeta:g4->zeta3_parts:g4->write_zeta:g4->eps_end

  }

  subgraph part3 {

    zeta2_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> Поверхность с нормаль-\lным законом распреде-\lления\l",shape=record]

    subgraph cluster_nonlinear_2 {
      label="Моделир. нелинейности\r"
      labeljust=right
      style=filled
      color=lightgrey
      zeta3_parts [label="<g1> ζ₁|<g2> ζ₂|<g3> …|<g4> ζₙ|<gen> ζ(t,x,y)",shape=record]
      transform_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Преобразование за-\lкона распределения\lвзволнованной мор-\lской поверхности\l",shape=record,style=rounded]
    }

    # barriers
    eps_start [label="",shape=box,style=filled,fillcolor=black,height=0.05]
    eps_end [label="",shape=box,style=filled,fillcolor=black,height=0.05]

    write_zeta [label="<g1> g₁|<g2> g₂|<g3> …|<g4> gₙ|<gen> Запись готовых\lчастей в файл\l",shape=record,style=rounded]
  }

  # edges
  start->spectrum->fourier_transform->acf->transform_acf
  transform_acf->acf2
  acf2->solve_yule_walker
  solve_yule_walker->phi
  phi->eps_start [constraint=false]
  eps_start->generate_white_noise:g1
  eps_start->generate_white_noise:g2
  eps_start->generate_white_noise:g3
  eps_start->generate_white_noise:g4
  generate_white_noise:g1->eps_parts:e1->generate_zeta:g1->zeta_parts:g1
  generate_white_noise:g2->eps_parts:e2->generate_zeta:g2->zeta_parts:g2
  generate_white_noise:g3->eps_parts:e3->generate_zeta:g3->zeta_parts:g3
  generate_white_noise:g4->eps_parts:e4->generate_zeta:g4->zeta_parts:g4

  eps_end->end
}
#+end_src

#+caption: Схема конвейера обработки данных, реализующего генерацию взволнованной морской поверхности по АР модели.
#+name: fig-pipeline
#+RESULTS: fig-pipeline
[[file:build/pipeline-ru.pdf]]

Конвейер объектов можно считать развитием модели BSP (Bulk Synchronous
Parallel)\nbsp{}cite:valiant1990bridging, применяемой в системах обработки
графов\nbsp{}cite:malewicz2010pregel,seo2010hama. Конвейер позволяет исключить
глобальную синхронизацию (где это возможно) между последовательно идущим этапами
вычислений путем передачи данных между звеньями параллельно с вычислениями, в то
время как в модели BSP глобальная синхронизация происходит после каждого шага.

Конвейер объектов ускоряет программу путем параллельного выполнения блоков кода,
работающих с разными вычислительными устройствами: в то время как текущая часть
взволнованной поверхности генерируется на процессоре, предыдущая часть
записывается на диск. Такой подход позволяет получить ускорение, потому что
различные вычислительные устройства работают асинхронно, и их параллельное
использование увеличивает производительность программы.

Поскольку передача данных между звеньями конвейера происходит параллельно с
вычислениями, то на одном и том же конвейере можно запустить сразу несколько
копий приложения с разными параметрами (генерировать сразу несколько
взволнованных морских поверхностей с разными характеристиками). На практике
оказывается, что высокопроизводительные приложения не всегда загружают
процессор на 100%, тратя время на синхронизацию параллельных процессов и
запись данных на диск. Использование конвейера в таком случае позволит на одном
и том же множестве процессов запустить сразу несколько расчетов и максимально
эффективно использовать все устройства компьютера. Например, во время записи в
файл одной задачей может производиться расчет на процессоре другой задачей. Это
минимизирует время простоя процессора и других устройств компьютера и повышает
общую пропускную способность кластера.

Конвейеризация шагов программы, которые в противном случае последовательны,
выгодно не только для кода, работающего с различными устройствами, но и для
кода, различные ветки которого могут быть запущены на нескольких аппаратных
потоках одного процессорного ядра, т.е. ветки, осуществляющие доступ к различным
блокам памяти или использующие смешанную арифметику (целочисленную и с плавающей
точкой). Ветки кода, которые используют различные модули процессора, являются
хорошими кандидатами для параллельного запуска на процессорном ядре с
несколькими аппаратными потоками.

Таким образом, вычислительную модель на основе конвейера можно рассматривать как
/массивно асинхронную модель/ (bulk-asynchronous model) из-за параллельной
природы шагов программы. Эта модель является основой модели отказоустойчивости,
которая будет описана далее.

*** Алгоритм обнаружения узлов кластера
:PROPERTIES:
:CUSTOM_ID: sec-node-discovery
:END:

**** Алгоритмы выбора лидера.
Многие системы пакетной обработки задач построены по принципу /субординации/: в
каждом кластере выбирается руководящий узел, который управляет очередью задач,
планирует их запуск на подчиненных узлах и следит за их состоянием. Роль
главного узла назначается либо /статически/ системным администратором
определенному физическому узлу, либо /динамически/, путем периодического
избрания какого-либо из узлов кластера главным. В первом случае
отказоустойчивость обеспечивается посредством резервирования дополнительного
свободного узла, который выполнит роль главного в случае отказа текущего. Во
втором случае отказоустойчивость обеспечивается выбором нового главного узла из
оставшихся. Несмотря на то что динамическое задание ролей требует наличия
алгоритма выбора лидера, этот подход становится все более и более популярным,
поскольку не требует наличия простаивающих резервных узлов на случай отказа
главного
узла\nbsp{}cite:hunt2010zookeeper,lakshman2010cassandra,divya2013elasticsearch и
в общем случае приводит к симметричной архитектуре системе, в которой один и тот
же стек программного обеспечения с одними и теми же настройками установлен на
каждом узле кластера\nbsp{}cite:boyer2012glusterfs,ostrovsky2015couchbase.

Алгоритмы выбора лидера (которые иногда называют алгоритмами /распределенного
консенсуса/) являются частными случаями волновых алгоритмов.
В\nbsp{}cite:tel2000introduction Тель определяет их как алгоритмы, в которых
событие завершения программы предваряется хотя бы одним каким-либо другим
событием, происходящем в /каждом/ параллельном процессе. Волновые алгоритмы не
определены для анонимных сетей, т.е. они работают только с теми параллельными
процессами, которые могут себя уникально идентифицировать. Однако, количество
процессов, которых затрагивает "волна", может быть определено по мере выполнения
алгоритма. В рамках распределенных систем это означает, что волновые алгоритмы
подходят для вычислительных кластеров с динамически меняющимся количеством
узлов, так что включение и выключение отдельных узлов не влияет на работу
алгоритма.

Подход к поиску узлов кластера не использует волновые алгоритмы, а значит не
требует опроса всех узлов кластера для выбора лидера. Вместо этого каждый узел
кластера нумерует все узлы подсети, в которой он находится, и преобразует список
в /древовидную иерархию/ с заданным максимальным значением ветвления
(максимальным количеством подчиненных вершин). Затем узел определяет свой
уровень иерархии и пытается соединиться с вышестоящими узлами, чтобы стать их
подчиненным. Сначала он проверяет близко расположенные к нему узлы, а потом все
остальные узлы вплоть до вершины иерархии. Если вышестоящих узлов нет или с ними
невозможно соединиться, то узел сам становится главой всей иерархии.

Древовидная иерархия узлов подсети определяет отношение строгого порядка на
множестве всех узлов кластера. Несмотря на то что с технической точки зрения
любая функция может быть выбрана для присвоения узлу подсети номера в списке, на
практике эта функция должна быть достаточно гладкой вдоль временной оси и иметь
лишь редкие скачки: быстрые изменения в структуре иерархии узлов (которые часто
являются следствием погрешности измерений) могут привести постоянной передаче
роли главного узла от одного узла к другому, что сделает иерархию непригодной
для распределения нагрузки. Простейшей такой функцией является позиция IP-адреса
узла в диапазоне всех IP-адресов подсети.

**** Алгоритм обхода древовидной иерархии.
Отношение строго порядка на множестве \(\mathcal{N}\) узлов одной подсети
определяется как
\begin{equation*}
  \forall n_1 \forall n_2 \in \mathcal{N},
  \forall f \colon \mathcal{N} \rightarrow \mathcal{R}^n
  \Rightarrow (f(n_1) < f(n_2) \Leftrightarrow \neg (f(n_1) \geq f(n_2))),
\end{equation*}
где \(f\)\nbsp{}--- отображение узла на его ранг, а \(<\)\nbsp{}--- оператор, определяющий
отношение строго порядка на множестве \(\mathcal{R}^n\). Функция \(f\) присваивает
узлу порядковый номер, а оператор \(<\) делает этот номер уникальным.

Простейшее отображение \(f\) ставит в соответствие каждому узлу подсети позицию
его IP-адреса в диапазоне всех адресов подсети. Без преобразования к древовидной
иерархии (когда в подсети выбирается только один лидер) рабочий узел, адрес
которого занимает наименьшую позицию в диапазоне, становится руководящим. Если
адрес узла занимает первую позицию в диапазоне, то для него невозможно выбрать
лидера, и он будет находится на вершине иерархии вплоть до выхода из строя.
Несмотря на то что идентификацию узлов на основе их IP-адресов легко реализовать
в программе, такой подход устанавливает искусственную зависимость роли
руководителя от IP-адреса узла. Тем не менее, этот подход полезен для первичного
объединения узлов в кластер, когда более сложные отображения неприменимы.

Для того чтобы алгоритм обнаружения масштабировался на большое количество узлов,
диапазона IP адресов подсети отображается на древовидную иерархию. В такой
иерархии каждый узел определяется уровнем \(l\) иерархии, на котором он
находится, и отступом \(o\), который равен порядковому номеру узла на его
уровне. Значения уровня и отступа определяются из следующей задачи оптимизации.
\begin{equation*}
    n = \sum\limits_{i=0}^{l(n)} p^i + o(n), \quad
    l \rightarrow \min, \quad
    o \rightarrow \min, \quad
    l \geq 0, \quad
    o \geq 0
\end{equation*}
где \(n\)\nbsp{}--- позиция IP-адреса узла в диапазоне IP-адресов подсети и \(p\)\nbsp{}---
значение ветвления (максимальное количество подчиненных, которых может иметь
узел). Руководитель узла на уровне \(l\) с отступом \(o\) имеет уровень \(l-1\) и
отступ \(\lfloor{o/p}\rfloor\). Расстояние между любыми двумя узлами в иерархии,
адреса которых занимают позиции \(i\) и \(j\) в диапазоне определяется как
\begin{align*}
    & \langle
        \text{lsub}(l(j), l(i)), \quad
        \left| o(j) - o(i)/p \right|
    \rangle,\\
    & \text{lsub}(l_1, l_2) =
    \begin{cases}
        \infty & \quad \text{if } l_1 \geq l_2, \\
        l_1 - l_2 & \quad \text{if } l_1 < l_2.
    \end{cases}
\end{align*}
Расстояние является составным, чтобы уровень иерархии учитывался в первую
очередь.

Для выбора руководителя каждый узел ранжирует все узлы подсети в соответствии с
их позицией \(\langle{l(n),o(n)}\rangle\) и, используя формулу для определения
расстояния, выбирает ближайший к потенциальному руководителю узел, имеющий
наименьший ранг. Это позволяет пропустить IP-адреса выключенных узлов, однако,
для разреженных сетей (в которых узлы занимают непоследовательные IP-адреса)
сбалансированность дерева не гарантируется.

Формулу для вычисления расстояния можно сделать сколь угодно сложной (чтобы
учесть задержки и пропускную способность сети или географическое местоположение
узла), однако, для ее простейшего вида более выгодно использовать алгоритм
обхода узлов кластера. Этот алгоритм требует меньшего количества памяти,
поскольку не нужно хранить ранжированный список всех узлов, вместо этого он
перебирает все IP-адреса сети в порядке, определяемом значением ветвления.
Алгоритм работает следующим образом. Сначала базовый узел (узел, который ищет
руководителя) вычисляет адрес своего потенциального руководителя и пытается
установить соединение с ним. Если соединение не удается, базовый узел
последовательно пытается соединиться с каждым узлом, находящимся на более
высоком уровне иерархии, пока не достигнет вершины иерархии (корня дерева). Если
ни одно из соединений не удается, базовый узел последовательно пытается
соединиться с каждым узлом на своем уровне, имеющим более низкую позицию в
диапазоне всех IP-адресов подсети. Если ни один из узлов не отвечает, базовый
узел занимает вершину иерархии, а обход иерархии повторяется через заданный
промежуток времени. Пример порядка обхода для кластера из 11 узлов и древовидной
иерархии с ветвлением 2 показан на рис.\nbsp{}[[fig-tree-hierarchy-11]].

#+name: fig-tree-hierarchy-11
#+begin_src dot :exports results :file build/tree-hierarchy-11-ru.pdf
digraph {

  node [fontname="Old Standard",fontsize=14,margin="0.055,0.055",shape=box,style=rounded]
  graph [nodesep="0.30",ranksep="0.30",rankdir="BT"]
  edge [arrowsize=0.66]

  m1 [label="10.0.0.1"]
  m2 [label="10.0.0.2"]
  m3 [label="10.0.0.3"]
  m4 [label="10.0.0.4"]
  m5 [label="10.0.0.5"]
  m6 [label="10.0.0.6"]
  m7 [label="10.0.0.7"]
  m8 [label="10.0.0.8"]
  m9 [label="10.0.0.9"]
  m10 [label="10.0.0.10",fillcolor="#c0c0c0",style="filled,rounded"]
  m11 [label="10.0.0.11",shape=Mrecord]

  m2->m1
  m3->m1
  m4->m2
  m5->m2
  m6->m3
  m7->m3
  m8->m4
  m9->m4
  m10->m5
  m11->m5

  m5->m4->m6 [style="dashed,bold",color="#c00000",constraint=false]
  {rank=same; m6->m7 [style="dashed,bold",color="#c00000"]}
  m7->m2->m3->m1->m8->m9 [style="dashed,bold",color="#c00000",constraint=false]

}
#+end_src

#+caption: Древовидная иерархия для кластера из 11 узлов со значением ветвления 2. Красными стрелками обозначен порядок обхода иерархии узлом с IP-адресом 10.0.0.10.
#+name: fig-tree-hierarchy-11
#+RESULTS: fig-tree-hierarchy-11
[[file:build/tree-hierarchy-11-ru.pdf]]

**** Результаты тестирования.
Для тестирования производительности обнаружения узлов, на каждом физическом узле
кластера запускалось несколько резидентных процессов, каждый из которых был
привязан к отдельному IP-адресу. Количество процессов на одно физическое ядро
варьировалось от 2 до 16. Каждый процесс был привязан к определенному
физическому ядру, чтобы уменьшить накладные расходы на миграцию процессов между
ядрами. Алгоритм обхода древовидной иерархии имеет низкие требования к
процессорному времени и пропускной способности сети, поэтому запуск нескольких
процессов на одном физическом ядре целесообразно, в отличие от кодов
высокопроизводительных приложений, в которых это часто ведет к низкой
производительности. Конфигурация тестовой системы показана в
табл.\nbsp{}[[tab-ant]].

#+name: tab-ant
#+caption: Конфигурация системы Ant.
#+attr_latex: :booktabs t
| Процессор               | Intel Xeon E5440, 2,83ГГц |
| Память                  | 4ГБ                       |
| Жесткий диск            | ST3250310NS, 7200об./мин. |
| Количество узлов        | 12                        |
| Количество ядер на узел | 8                         |

Похожий подход используется
в\nbsp{}cite:lantz2010network,handigol2012reproducible,heller2013reproducible,
где авторы воспроизводят разнообразные практические эксперименты на виртуальных
кластерах и сопоставляют результаты с физическими. Преимущество данного подхода
заключается в возможности проведения экспериментов на больших виртуальных
кластерах, используя сравнительно небольшое количество физических узлов.
Преимущество подхода, используемого в данной работе, в котором не применяются
пространства имен Linux, заключается в том, что он более легковесный и большее
количество резидентных процессов можно протестировать на одном и том же
физическом кластере.

Производительность обнаружения узлов была протестирована путем измерения
времени, которое необходимо для того чтобы все узлы кластера нашли друг друга,
т.е.\nbsp{}времени, которое необходимо для того чтобы древовидная иерархии узлов
достигла устойчивого состояния. Каждое изменение иерархии, то, как его видит
каждый узел, записывалось в файл журнала, и по прошествии заданного промежутка
времени все резидентные процессы (каждый из которых моделирует узел кластера)
принудительно завершались. Процессы запускались последовательно с задержкой в
100мс., чтобы удостовериться, что главные узлы становятся доступны раньше
подчиненных, а иерархия не меняется произвольным образом в результате разного
времени запуска процессов. Эта искусственная задержка впоследствии была вычтена
из результатов тестирования. Таким образом, результаты теста представляют собой
время обнаружения узлов в "идеальном" кластере, к котором каждый резидентный
процесс находит главного с первой попытки.

Тест запускался несколько раз, варьируя количество резидентных процессов на
физический узел. Эксперимент показал, что обнаружение 512 узлами (8 физических
узлов по 64 процесса на узел) друг друга занимает не более двух секунд
(рис.\nbsp{}[[fig-discovery-benchmark]]). Это значение меняется незначительно с
увеличением количества физических узлов. Использование более 8 узлов по 64
процесса на узел приводит к большой колебаниям времени обнаружения, ввиду того
что большое количества процессов одновременно устанавливает соединение с одним
и тем же главным процессов (значение ветвления во всех тестах равнялось 10000),
поэтому эти результаты были исключены.

#+name: fig-discovery-benchmark
#+header: :width 7 :height 5
#+begin_src R :file build/discovery-benchmark-ru.pdf
source(file.path("R", "discovery.R"))
bscheduler.plot_discovery(
  xlabel="Количество физических узлов",
  ylabel="Время, сек.",
  toplabel="ppn")
#+end_src

#+caption: Время обнаружения всех резидентных процессов, запущенных на кластере, в зависимости от количества процессов. Пунктирная линия обозначает минимальное и максимальное значение за все проведенные тесты, "ppn" --- количество резидентных процессов на узел.
#+name: fig-discovery-benchmark
#+RESULTS: fig-discovery-benchmark
[[file:build/discovery-benchmark-ru.pdf]]

**** Обсуждение.
Поскольку узлу для выбора руководителя нужно соединиться с узлом, адрес которого
известен заранее, то обнаружение узлов масштабируется на большое количество
узлов. Соединение с другими узлами происходит только в том случае, если текущий
узел-руководитель выходит из строя. Таким образом, если адреса узлов кластера
расположены непрерывно в диапазоне адресов подсети, каждый узел устанавливает
соединение только со своим руководителем, и неэффективного сканирования всей
сети каждым узлом не происходит.

Следующие ключевые особенности отличают предложенный подход от некоторых
существующих
подходов\nbsp{}cite:brunekreef1996design,aguilera2001stable,romano2014design.
- *Многоуровневая иерархия.* Количество руководящих узлов в сети зависит от
  значения ветвления. Если оно меньше количества IP-адресов в подсети, то в
  кластере будет несколько руководящих узлов. Если оно больше или равно
  количеству IP-адресов в подсети, то в кластере будет только один руководящий
  узел. Когда какой-либо узел выходит из строя, многоуровневая иерархия
  изменятся локально, только узлы, примыкающие к вышедшему из строя,
  взаимодействуют друг с другом.
- *Отображение IP-адресов.* Поскольку структура иерархии зависит только от
  IP-адресов узлов, то в алгоритме отсутствует фаза выбора лидера. Чтобы сменить
  руководителя, каждый узел отправляет сообщение только прежнему и новому
  руководителю.
- *Полностью основан на событиях.* Сообщения отправляются только при выходе из
  строя узла, поэтому постоянной нагрузки на сеть нету. Поскольку алгоритм
  допускает ошибку при отправке любого сообщения, то нет необходимости в
  heartbeat-пакетах, являющихся индикацией нахождения узла в сети; вместо этого
  все сообщения выполняют роль heartbeat-пакетов и настраивается время ожидания
  отправки пакета.
- *Отсутствие ручной конфигурации.* Узлу не требуется никаких предварительных
  знаний, чтобы найти руководителя: он определяет сеть, узлом которой он
  является, вычисляет IP-адрес потенциального руководителя и отправляет ему
  сообщение. Если это не срабатывает, то процесс повторяется для следующего
  потенциального руководителя. Таким образом, алгоритм подходит для начальной
  загрузки кластера без ручной настройки, для этого требуется только запустить
  соответствующий сервис на каждом узле.
Суммируя вышесказанное, достоинством алгоритма является то, что он
- масштабируется на большое количество узлов посредством иерархии с несколькими
  руководящими узлами,
- не нагружает сеть отправкой сообщений с текущим состоянием узлов и
  heartbeat-пакетами,
- не требует ручной настройки для первичной загрузки кластера.

Недостатком алгоритма является то, что он требует редкого изменения IP-адресов.
Он не подходит для облачной среды, в которой только DNS имя узла сохраняется, а
IP-адрес может меняться со временем. Когда IP-адрес меняется, текущие соединения
могут закрыться, сигнализируя о "выходе из строя" узла и перестраивая иерархию
узлов. Таким образом, окружения, в которых узлы не идентифицируются IP-адресами,
не подходят для алгоритма.

Другим недостатком алгоритма является искусственная зависимость ранга узла от
IP-адреса: замена отображения IP-адресов на что-то более совершенное (например,
на отображение, которое использует загрузку текущего узла и сети для
ранжирования узлов) представляет сложность, поскольку погрешность измерений
может стать причиной неустойчивой иерархии, а полная событийность алгоритма
будет нарушена.

Алгоритм обнаружения узлов спроектирован для балансировки нагрузки на кластер
вычислительных узлов, и его применение в других приложениях не рассматривается в
данной работе. Когда распределенная или параллельная программа запускается на
одном из узлов кластера, ее подзадачи распределяются между всеми примыкающими
узлами иерархии (включая главный узел, если есть). Для того чтобы равномерно
распределить нагрузку, когда программа запускается на подчиненном узле, каждый
узел хранит вес каждого из примыкающих узлов иерархии. Вес равен количеству
узлов дерева, находящегося "за" примыкающим узлом. Например, если вес первого
примыкающего узла равен 2, то циклический алгоритм балансировки нагрузки
распределит две подзадачи на первый узел перед тем как перейти к следующему
узлу.

Суммируя вышесказанное, алгоритм обнаружения узлов
- спроектирован для облегчения распределения нагрузки на кластер,
- полностью отказоустойчивый, состояние каждого узла можно вычислить заново в
  любой момент времени,
- полностью основан на событиях, а значит не нагружает сеть периодической
  отправкой сообщений.

*** Алгоритм восстановления после сбоев
:PROPERTIES:
:CUSTOM_ID: sec-fail-over
:END:

**** Контрольные точки восстановления.
Сбои узлов распределенной системы можно разделить на два типа: сбой подчиненного
узла и сбой руководящего узла. Для того чтобы запущенная на кластере задача
могла пережить сбой подчиненного узла, планировщик задач периодически создает
для нее контрольные точки восстановления и записывают их в надежное хранилище.
Для того чтобы создать контрольную точку, планировщик временно останавливает все
параллельные процессы задачи, копирует все страницы памяти и все структуры ядра
операционной системы, выделенные для этих процессов, на диск, и продолжает
выполнение задачи. Для того чтобы пережить сбой руководящего узла, серверный
процесс планировщика задач непрерывно копирует свое внутреннее состояние на
резервный узел, который становится руководящим после сбоя.

Оптимизации работы контрольных точек восстановления посвящено большое количество
работ\nbsp{}cite:egwutuoha2013survey, а альтернативным подходам уделяется меньше
внимания. Обычно высокопроизводительные приложения используют передачу сообщений
для обмена данными между параллельными процессами и хранят свое текущее
состояние в глобальной памяти, поэтому не существует способа перезапустить
завершившийся процесс, не записав образ всей выделенной для него памяти на диск.
Обычно общее число процессов фиксировано и задается планировщиком, и в случае
отказа перезапускаются сразу все процессы. Существуют некоторые обходные
решения, которые позволяют перезапустить только часть
процессов\nbsp{}cite:meyer2012radic, восстановив их из контрольной точки на
выживших узлах, однако это может привести к перегрузке, если на этих узлах уже
запущены другие задачи. Теоретически, перезапуск процесса необязателен если
задача может быть продолжена на выживших узлах, но библиотека передачи сообщений
не позволяет изменять количество параллельных процессов во время работы
программы, и большинство программ все равно предполагают, что это значение
является константой. Таким образом, не существует надежного способа обеспечения
отказоустойчивости на уровне библиотеки передачи сообщений кроме как путем
перезапуска всех параллельных процессов из контрольной точки восстановления.

Однако, существует возможность продолжить выполнение задачи на меньшем
количестве узлов, чем было изначально выделено изначально, реализовав
отказоустойчивость на уровне приложения. В этом случае роли руководителя и
подчиненного динамически распределяются между резидентными процессами
планировщика задач, работающими на каждом узле кластера, образуя древовидную
иерархию узлов кластера, а параллельная программа состоит из управляющих
объектов, использующих иерархию узлов для динамического распределения нагрузки и
свою собственную иерархию для перезапуска управляющих объектов в случае сбоя
узла.

**** Динамическое распределение ролей.
Отказоустойчивость параллельной программы\nbsp{}--- это одна из проблем, которая
должна решаться планировщиком задач обработки больших данных или
высокопроизводительных вычислений, однако, большинство планировщиков
обеспечивают только отказоустойчивость подчиненных узлов. Такого рода сбои
обычно обрабатываются путем перезапуска затронутой задачи (из контрольной точки
восстановления) или ее части на оставшихся узлах, а выход из строя руководящего
узла считается либо маловероятным, либо слишком сложным для обработки и
настройки на целевой платформе. Системные администраторы обычно находят
альтернативы отказоустойчивости на уровне приложения: они изолируют руководящий
процесс планировщика от остальных узлов кластера, размещая его на специально
выделенной машине, или, вместо этого, используют технологии виртуализации. Все
эти альтернативы усложняют конфигурацию и обслуживание, и, уменьшая вероятность
выхода из строя машины, приводящей к выходу из строя всей системы, увеличивают
вероятность ошибки оператора.

С этой точки зрения более практичным реализовать отказоустойчивость руководящего
узла на уровне приложения, но не существует общего зарекомендовавшего себя
решения. Большинство реализаций слишком привязаны к конкретному приложению,
чтобы стать повсеместно применяемыми. Автор считает, что это происходит из-за
привычки людей думать о кластере, как о совокупности отдельных машин, каждая из
которых может быть руководителем или подчиненным, вместо того чтобы думать о
кластере, как о едином целом, в котором роли руководителя и подчиненного
динамически распределяются между запущенными на разных узлах процессами.

Понимание того, что кластер тоже является вычислительной машиной, позволяет
реализовать промежуточное программное обеспечение, которое автоматически
распределяет роли руководителя и подчиненного и общим способом обрабатывает сбои
узлов. Это программное обеспечение предоставляет программный интерфейс и
распределяет управляющие объекты между доступными на данный момент узлами.
Используя этот интерфейс, можно написать программу, которая запускается на
кластере, не зная точного количества работающих узлов. Это промежуточное
программное обеспечение работает как кластерная операционная система в
пользовательском пространстве, позволяющая писать и запускать распределенные
приложения прозрачно.

**** Симметричная архитектура.
Многие распределенные хранилища типа "ключ-значение" и параллельные файловые
системы имеют симметричную архитектуру, в которой роли руководителя и
подчиненного распределяются динамически, так что любой узел может выступать в
роли руководителя, если текущий руководящий узел выходит из
строя\nbsp{}cite:ostrovsky2015couchbase,divya2013elasticsearch,boyer2012glusterfs,anderson2010couchdb,lakshman2010cassandra.
Однако, такая архитектура до сих пор не используется в планировщиках задач
обработки больших данных и высокопроизводительных вычислений. Например, в
планировщике задач обработки больших данных YARN\nbsp{}cite:vavilapalli2013yarn,
роли руководителя и подчиненного являются статическими. Восстановление после
сбоя подчиненного узла осуществляется путем перезапуска работавшей на нем части
задачи на одном из выживших узлов, а восстановление после сбоя руководящего узла
осуществляется путем установки резервного руководящего
узла\nbsp{}cite:murthy2011architecture. Оба руководящих узла управляются
сервисом Zookeeper, который использует динамическое распределение ролей для
обеспечения своей отказоустойчивости\nbsp{}cite:okorafor2012zookeeper. Таким
образом, отсутствие динамического распределения ролей у планировщика YARN
усложняет конфигурацию всего кластера: если бы динамические роли были доступны,
Zookeeper был бы лишним в данной конфигурации.

Такая же проблема возникает в планировщиках задач для высокопроизводительных
вычислений, руководящий узел (на котором запущен главный процесс планировщика
задач) является единой точкой сбоя.
В\nbsp{}cite:uhlemann2006joshua,engelmann2006symmetric авторы копируют состояние
планировщика задач на резервный узел, чтобы обеспечить высокую доступность
руководящего узла, но роль резервного узла задается статически. Такое решение
близко к симметричной архитектуре, поскольку не использует внешний сервис для
обеспечения высокой доступности, но далеко от идеала, в котором резервный узел
выбирается динамически.

Наконец, наиболее простой вариант высокой доступности руководящего узла
реализован в протоколе VRRP (Virtual Router Redundancy
Protocol)\nbsp{}cite:rfc2338,rfc3768,rfc5798. Несмотря на то что протокол VRRP
предоставляет динамическое распределение ролей, он не может быть использован в
планировщиках задач, поскольку спроектирован для маршрутизаторов, за которыми
стоят инвертированные прокси-серверы. В таких серверах отсутствует состояние
(очередь задач), которое необходимо восстановить после выхода из строя узла,
поэтому их высокую доступность обеспечить проще. Это может быть реализовано даже
без маршрутизаторов, используя вместо этого сервис
Keepalived\nbsp{}cite:cassen2002keepalived.

Симметричная архитектура выгодна для планировщиков задач, поскольку позволяет
- сделать физические узлы взаимозаменяемыми,
- реализовать динамическое распределение ролей руководителя и подчиненного и
- реализовать автоматическое восстановление после сбоя любого из узлов.
В последующих разделах будут описаны компоненты необходимые для написания
параллельной программы и планировщика, которые устойчивы к сбоям узлов кластера.

**** Определения иерархий.  Для устранения неоднозначности иерархических связей
между резидентными процессами и управляющими объектами и для того чтобы
упростить изложение, мы будем использовать в тексте следующие условные
обозначения. Если связь установлена между двумя резидентными процессами, то
отношения обозначаются /руководитель-подчиненный/. Если связь установлена между
двумя управляющими объектами, то отношения обозначаются либо
/руководитель-подчиненный/, либо /родитель-потомок/. Две иерархии ортогональны
друг к другу в том смысле, что ни один управляющий объект не может иметь связь
с сервисом, и наоборот. Поскольку иерархия сервисом используется для
распределения нагрузки на узлы кластера, иерархия управляющих объектов
отображается на нее, и это отображение может быть произвольным: обычна
ситуация, когда руководящий управляющий объект находится на подчиненном узле, а
его подчиненные управляющие объекта распределены равномерно между всеми узлами
кластера (включая узел, где находится руководящий объект).  Обе иерархии может
быть сколь угодно глубокими, но "неглубокие" являются предпочтительными для
высоко параллельных программ, так как в них меньше количество промежуточных
узлов, через которые должны пройти управляющие объекты при распределении между
узлами кластера. Поскольку существует однозначное соответствие между
резидентными процессами и узлами кластера, в данной работе они используются как
взаимозаменяемые термины.

**** Обработка выхода узлов из строя.
Основной стратегией при выходе из строя подчиненного узла является перезапуск
выполнявшихся на нем объектов на рабочих узлах\nbsp{}--- стратегия, которой
следует язык Erlang при перезапуске подчиненных
процессов\nbsp{}cite:armstrong2003thesis. Для того что реализовать этот метод в
рамках иерархии управляющих объектов, узел-отправитель сохраняет каждый объект,
передаваемый на другие узлы кластера, и в случае отказа произвольного количества
узлов, на которые были переданы объекты, их копии перераспределяются между
оставшимися узлами без индивидуальной обработки программистом. Если больше не
осталось узлов, на которые можно отправить объекты, то они выполняются локально.
В отличие от "тяжеловесного" метода контрольных точек восстановления,
используемого планировщиками задач HPC кластеров, древовидная иерархия узлов в
паре с иерархией объектов позволяет автоматически продолжить выполнение
программы при выходе из строя произвольного количества подчиненных узлов без
перезапуска каких-либо процессов параллельной программы.

Возможный подход к обработке выхода из строя главного узла (узла, на котором
запускается главный управляющий объект) заключается в копировании этого главного
объекта на резервный узел и синхронизации любых изменений между двумя копиями
объекта посредством распределенных транзакций, однако, этот подход не
соотносится с асинхронностью вычислительных ядер и слишком сложна в реализации.
На практике, оказывается, что главный управляющий объект обычно не выполняет
операции параллельно, а последовательно переходит от вычисления одного шага
программы к вычислению другого, и, значит, имеет не больше одного подчиненного в
каждый момент времени. (Каждый подчиненный объект представляет собой
последовательный шаг вычислений, который может быть, а может не быть
параллельным внутри.) Имея это ввиду, можно упростить синхронизацию состояния
главного объекта программы: отправить главный объект на подчиненный узел вместе
с его подчиненным объектом. Тогда при выходе из строя главного узла, копия
главного объекта принимает подчиненный объект (поскольку оба объекта находятся
на одном и том же узле), и время на восстановление не тратится. Если же выходит
из строя подчиненный узел, на которым был отправлен подчиненный объект вместе с
копией главного объекта, то подчиненный объект отправляется на оставшиеся узлы,
и в худшем случае текущий шаг вычислений выполняется заново.

Описанный выше подход предназначен для объектов, у которых нет объекта-родителя
и которые имеют только один подчиненный объект в каждый момент времени, и
повторяет механизм работы контрольных точек восстановления. Преимуществом
данного подхода является то, что он
- сохраняет состояние только между последовательными шагами вычислений (когда оно
занимает минимальный объем памяти),
- сохраняет только актуальное данные и
- использует для сохранения состояния оперативную память другого узла кластера,
  а не дисковое хранилище.
Этот подход позволяет выдержать выход из строя не более одного /любого/ узла
кластера за один шаг вычислений или произвольного количества подчиненных узлов в
любой момент работы программы.

Далее следует пример работы алгоритма восстановления после сбоев
(рис.\nbsp{}[[fig-fail-over-example]]).
1. Исходное состояние. На начальном этапе вычислительный кластер не требует
   никакой настройки за исключением настройки сети. Алгоритм предполагает полную
   связность узлов кластера и лучше всего работает с древовидными топологиями, в
   которых все узлы кластера соединены несколькими коммутаторами.
2. Построение иерархии узлов. При первичной загрузке на всех узлах кластера
   запускаются резидентные процессы, которые совместно строят иерархию таких же
   процессов поверх топологии сети кластера. Положение процесса-сервиса в
   иерархии определяется позицией IP-адреса его узла в диапазоне IP-адресов
   сети. Для установления связи каждый из процессов соединяется только с
   предполагаемым руководящим процессом. В данном случае процесс на узле \(A\)
   становится руководящим процессом для всех остальных. Иерархия может
   измениться, только если новый узел присоединяется к кластеру или какой-либо из
   узлов выходит из строя.
3. Запуск главного управляющего объекта. Первый управляющий объект запускается
   на одном из подчиненных узлов (узел \(B\)). Главный объект может иметь только
   один подчиненный объект в каждый момент времени, и резервная копия главного
   объекта посылается вместе с этим подчиненным объектом \(T_1\) на руководящий узел
   \(A\). \(T_1\) представляет собой последовательный шаг программы. В программе
   может быть произвольное количество последовательных шагов, и, когда узел
   \(A\) выходит из строя, текущий шаг перезапускается с начала.
4. Запуск подчиненных управляющих объектов. Управляющие объекты \(S_1\), \(S_2\),
   \(S_3\) запускаются на подчиненных узлах кластера. Когда узел \(B\), \(C\)
   или \(D\), соответствующий руководящий управляющий объект перезапускает
   завершившиеся некорректно подчиненные объекты (\(T_1\) перезапускает \(S_1\),
   главный объект перезапускает \(T_1\) и т.д.). Когда выходит из строя узел
   \(B\), главный объект восстанавливается из резервной копии.

#+name: fig-fail-over-example
#+header: :headers '("\\input{preamble}\\setdefaultlanguage{russian}")
#+begin_src latex :file build/fail-over-example-ru.pdf :exports results :results raw
\input{tex/preamble}
\newcommand*{\spbuInsertFigure}[1]{%
\vspace{2\baselineskip}%
\begin{minipage}[b]{0.5\linewidth}%
    \Large%
    \input{#1}%
\end{minipage}%
}%
\noindent%
\spbuInsertFigure{tex/cluster-0}~\spbuInsertFigure{tex/frame-0}\newline
\spbuInsertFigure{tex/frame-3-ru}~\spbuInsertFigure{tex/frame-4-ru}\newline
\spbuInsertFigure{tex/legend-ru}
#+end_src

#+caption: Пример работы алгоритма восстановления после сбоев.
#+name: fig-fail-over-example
#+attr_latex: :width \textwidth
#+RESULTS: fig-fail-over-example
[[file:build/fail-over-example-ru.pdf]]

**** Результаты тестирования.
Алгоритм обеспечения отказоустойчивости был протестирован на физическом кластере
(см.\nbsp{}табл.\nbsp{}[[tab-ant]]) на примере распределенной программы для модели
АР, подробно описанной в разделе\nbsp{}[[#sec:arma-mpp]]. Программа состоит из серии
функций, каждая из которых применяется к результату работы предыдущей. Некоторые
из функций вычисляются параллельно, так что вся программа состоит из
последовательно выполняющихся шагов, некоторые из которых внутри реализованы
параллельно, чтобы получить большую производительность. Только наиболее
ресурсоемкий этап программы (генерация взволнованной морской поверхности)
выполняется параллельно на всех узлах, другие этапы выполняются параллельно на
всех процессорных ядрах главного узла.

Программа была переписана для распределенной версии фреймворка, что потребовало
добавления методов чтения/записи для каждого управляющего объекта, которые
передается по сети и небольших изменений исходного кода для корректной обработки
выхода из строя узла с главным объектом. Главный объект был помечен, чтобы
фреймворк смог передать его на подчиненный узел вместе с подчиненным ему
объектом. Другие изменения исходного кода были связаны с изменением программного
интерфейса фреймворка. Таким образом, обеспечение отказоустойчивости посредством
иерархии управляющих объектов, в основном, прозрачно для программиста и требует
лишь маркировки главного объекта для его репликации на резервный узел и
добавлении кода для чтения/записи объектов в байтовый буфер.

В ряде экспериментов была измерена производительность новой версии программы при
выходе из строя различных типов узлов во время выполнения:
- без выхода из строя узлов,
- выход из строя главного узла (на котором запускается главный объект),
- выход из строя подчиненного узла (на который копируется главный объект
  программы).
Только два напрямую соединенных узла кластера были использованы в тесте. Выход
из строя узла имитировался путем отправки сигнала ~SIGKILL~ резидентному
процессу на соответствующем узле, сразу после того как копия главного объекта
создана. Приложение сразу обнаруживало выход из строя узла, поскольку
соответствующее соединение закрывалось; на практике, однако, выход узла из строя
обнаруживается только по прошествии настраиваемого время ожидания протокола
TCP\nbsp{}cite:rfc5482. Время выполнения этих запусков сравнивалось со временем
выполнения без имитирования выхода из строя узлов. Результаты тестов
представлены на рис.\nbsp{}[[fig-master-slave-failure]], а схема распределения
управляющих объектов между двумя узлами на рис.\nbsp{}[[fig-master-slave-backup]].

#+name: fig-master-slave-backup
#+begin_src dot :exports results :file build/master-slave-backup-ru.pdf
digraph {

  node [fontname="Old Standard",fontsize=14,margin="0.055,0.055",shape=box,style=rounded]
  graph [nodesep="0.30",ranksep="0.30",rankdir="BT"]
  edge [arrowsize=0.66]

  m1 [label="{{<master>Master | 10.0.0.1} | {<main>M | <slave1>S₁ | <slave3>S₃}}",shape=record]
  m2 [label="{{<slave>Slave | 10.0.0.2} | {M' | <step>N | <slave2>S₂ | <slave4>S₄}}",shape=record]

  m2->m1

}
#+end_src

#+name: fig-master-slave-backup
#+caption: Главный и подчиненный узлы, а также отображение главного объекта \(M\), его копии \(M'\), объекта, соответствующего текущему шагу выполнения \(N\) и подчиненных объектов \(S_{1,2,3}\) на эти узлы.
#+RESULTS: fig-master-slave-backup
[[file:build/master-slave-backup-ru.pdf]]

Как и ожидалось, существует большая разница в производительности приложения при
выходе из строя различных типов узлов. В случае отказа подчиненного узла главный
управляющий объект вместе с некоторыми подчиненными (которые были распределены
на подчиненный узел) теряются, но главный узел имеет копию главного объекта и
использует ее, чтобы продолжить выполнение. Таким образом, при выходе из строя
подчиненного узла ничего не теряется, за исключением потенциала
производительности подчиненного узла. В случае выхода из строя главного узла
копия главного объекта, а также подчиненный объект, который переносит эту копию,
теряются, но подчиненный узел имеет оригинальный главный объект и использует его
для перезапуска вычислений с текущего шага, т.е.\nbsp{}отправляет подчиненный
объект на один из оставшихся узлов кластера (в случае двух напрямую соединенных
узлов он отправляет объект себе же). Таким образом, разница в производительности
приложения объясняется разным количеством и разными ролями объектов, которые
теряются при выходе из строя того или иного узла.

Обнаружение выхода из строя подчиненного узла требует некоторого времени: это
происходит, только когда подчиненный объект, переносящий копию главного,
заканчивает выполнение и пытается добраться до родительского объекта.
Мгновенное обнаружение требует принудительной остановки подчиненного объекта,
что может быть неприменимо для программ со сложной логикой.

#+name: fig-master-slave-failure
#+begin_src R :file build/master-slave-failure-ru.pdf
source(file.path("R", "benchmarks.R"))
par(family="serif")
data <- arma.load_master_slave_failure_data()
arma.plot_master_slave_failure_data(
  data,
  list(
    master="Bscheduler (главный узел)",
    slave="Bscheduler (подчиненный узел)",
    nofailures="Bscheduler (без выхода из строя)"
  )
)
title(xlab="Размер взволнованной поверхности", ylab="Время, сек.")
#+end_src

#+caption: Производительность модели АР при выходе из строя узлов.
#+name: fig-master-slave-failure
#+RESULTS: fig-master-slave-failure
[[file:build/master-slave-failure-ru.pdf]]

Итого, если выход из строя узла происходит сразу после того как копия главного
объекта сделана, лишь малая часть производительности теряется в случае выхода из
строя главного узла; при выходе из строя подчиненного узла теряется больше
производительности.

**** Обсуждение результатов тестирования.
Поскольку выход из строя имитируется, сразу после того как первый подчиненный
объект достигает точки назначения (узла, на котором предполагается его
выполнить), выход из строя подчиненного узла приводит к потере небольшой доли
производительности; на практике, где выход из строя может произойти в середине
генерации взволнованной поверхности, потери производительности при выходе из
строя /резервного/ узла (узла, где находится копия главного объекта) были бы
выше. Аналогично, на практике количество узлов в кластере больше, а значит
меньшее количество подчиненных объектов теряется при выходе из строя главного
узла, из-за чего потери производительности меньше. В тесте потери в случае
выхода из строя подчиненного узла выше, что является результатом отсутствия
параллелизма в начале генерации взволнованной поверхности моделью АР: первая
часть вычисляется последовательно, а другие части вычисляются, только когда
первая доступна. Таким образом, потеря первого подчиненного объекта замедляет
выполнение всех зависимых объектов в программе.

Алгоритм восстановления после сбоев гарантирует обработку выхода из строя одного
узла на один последовательный шаг программы; больше сбоев может быть выдержано,
если он не затрагивают руководящий узел. Алгоритм обрабатывает одновременный
выход из строя всех подчиненных узлов, однако, если руководящий и резервный узлы
вместе выходят из строя, у программы нет ни единого шанса продолжить работу. В
этом случае состояние текущего шага вычислений теряется полностью, и его можно
восстановить только перезапуском программы с начала.

Управляющие объекты являются абстракциями, отделяющие распределенное приложение
от физических устройств: для непрерывной работы программы не важно, сколько
узлов кластера в данный момент работают. Управляющие объекты позволяют
отказаться от выделения физического резервного узла для обеспечения устойчивости
к выходу из строя руководящего узла: в рамках иерархии управляющих объектов
любой физический узел (кроме руководящего) может выполнять роль резервного.
Наконец, иерархия управляющих объектов позволяет обрабатывать сбои прозрачно для
программиста, определяя порядок действий из внутреннего состояния объекта.

Проведенные эксперименты показывают, что параллельной программе необходимо иметь
несколько последовательных этапов выполнения, чтобы сделать ее устойчивой к
сбоям узлов, иначе выход из строя резервного узла фактически вызывает
восстановление исходного состояния программы. Несмотря на то что вероятность
сбоя резервного узла меньше вероятности сбоя одного из подчиненных узлов, это не
повод потерять все данные, когда выполнявшаяся продолжительное время программа
почти завершилась. В общем случае, чем больше последовательных этапов вычислений
содержит параллельная программа, тем меньше времени потеряется в случае сбоя
резервного узла, и, аналогично, чем больше параллельных частей содержит каждый
последовательный этап, тем меньше времени потеряется при сбое руководящего или
подчиненного узла. Другими словами, чем больше количество узлов, на которое
масштабируется программа, тем она становится более устойчива к сбою узлов
кластера.

Хотя это не было показано в экспериментах, Фабрика не только обеспечивает
устойчивость к выходу из строя узлов кластера, но и позволяет автоматически
вводить новые узлы в кластер и распределять на них часть управляющих объектов из
уже запущенных программ. В контексте фреймворка этот процесс тривиален,
поскольку не требует перезапуска незавершившихся управляющих объектов и
копирования их состояния, и не изучался экспериментально в данной работе.

Теоретически, отказоустойчивость, основанная на иерархии узлов и управляющих
объектов, может быть реализована поверх библиотеки передачи сообщений без потери
общности. Хотя использование незагруженных узлов заместо вышедших из строя в
рамках такой библиотеки представляет определенную сложность, поскольку
количество узлов, на которых запущена программа, в таких библиотеках
фиксировано, однако, выделение достаточно большого количества узлов для
программы будет достаточно для обеспечения ее отказоустойчивости. В то же время,
реализация отказоустойчивости, основанной на иерархии, внутри самой библиотеки
передачи сообщений не практично, поскольку это потребует сохранения текущего
состояния параллельной программы, объем которого эквивалентен всей занимаемой ей
памятью на каждом узле кластера, что, в свою очередь, не позволит сделать такой
подход эффективнее контрольных точек восстановления.

Слабым местом описанных методов является период времени, начиная с отказа
руководящего узла и заканчивая обнаружением сбоя подчиненным узлом,
восстановлением главного объекта из копии и получением нового подчиненного
объекта вместе с копией его родителя подчиненным узлом. Если в любой момент
времени из этого периода резервный узел выходит из строя, то состояние
выполнения программы полностью теряется без возможности его восстановить, кроме
как перезапуском с самого начала. Протяженность этого опасного промежутка
времени может быть минимизирована, но полностью исключить вероятность внезапного
завершения программы невозможно. Этот результат согласуется с исследованиями
/теории невыполнимости/ в рамках которой доказывается невозможность
распределенного консенсуса с хотя бы одним процессом, дающим
сбой\nbsp{}cite:fischer1985impossibility и невозможность надежной передачи
данных в случае сбоя одного из узлов\nbsp{}cite:fekete1993impossibility.

*** Сравнение предложенного подхода с современными подходами
Современный подход к разработке и запуску параллельных программ на кластере
заключается в использовании библиотеки передачи сообщений MPI и планировщика
задач, и, несмотря на то что этот подход имеет высокую эффективность с точки
зрения параллельных вычислений, он недостаточно гибок, чтобы вместить в себя
динамическую балансировку нагрузки и автоматическое обеспечение
отказоустойчивости. Программы, написанные с помощью MPI обычно предполагают
- равномерную загрузку каждого процессора,
- бесперебойное и надежное выполнение пакетных задач, и
- постоянное число параллельных процессов/потоков во время выполнения, равное
  общему количеству процессоров.
Первое предположение несправедливо для программы моделирование морского
волнения, поскольку модель АР требует динамической балансировки нагрузки между
процессорами для генерации каждой части поверхности только когда генерация всех
зависимых частей уже закончена. Последнее предположение также несправедливо,
поскольку в угоду эффективности каждая часть записывается в файл отдельным
потоком асинхронно. Оставшееся предположение относится не к самой программе, а к
планировщику задач, и несправедливо для больших вычислительных кластеров, в
которых узлы часто выходят из строя, а планировщик перезапускает задачу из
контрольной точки восстановления, серьезно замедляя ее. Таким образом, идея
предлагаемого подхода\nbsp{}--- дать параллельным программам больше гибкости:
- предоставить динамическую балансировку нагрузки путем выполнения
  последовательных, параллельных изнутри шагов программы в режиме конвейера,
- перезапускать только затронутые выходом из строя узла процессы, и
- выполнять программу на как можно большем количестве узлов, которое доступно в
  кластере.
В данном разделе обсуждаются преимущества и недостатки этого подхода.

В сравнении с переносимыми системами пакетных заданий (PBS) для распределения
нагрузки на узлы кластера предлагаемый подход использует легковесные управляющие
объекты вместо тяжеловесных параллельных задач. Во-первых, это позволяет иметь
очереди объектов на каждом узле, вместо того чтобы иметь одну очередь задач на
кластер. Зернистость управляющих объектов гораздо выше, чем у пакетных задач, и,
несмотря на то что время их выполнения не может быть надежно спрогнозировано
(также как и время выполнения пакетных задач), объекты из нескольких
параллельных программ могут быть динамически распределены между одним и тем же
множеством узлов кластера, делая нагрузку более равномерной. Недостатком
является необходимость в большем количестве оперативной памяти для выполнения
нескольких задач на одних и тех же узлах, а также в том что выполнение каждой
программы может занять больше времени из-за общих очередей управляющих объектов.
Во-вторых, предлагаемый подход использует динамическое распределение ролей
руководителя и подчиненного среди узлов кластера вместо их статического
присвоения конкретным физическим узлам. Это позволяет сделать узлы
взаимозаменяемыми, что необходимо для обеспечения отказоустойчивости. Таким
образом, одновременное выполнение нескольких параллельных программ на одном и
том же множестве узлов может увеличить пропускную способность кластера, но также
может уменьшить их производительность, взятую по отдельности, а динамическое
распределение ролей является основанием, на котором строится устойчивость к
сбоям.

В сравнении с MPI для разбиения программы на отдельные сущности предлагаемый
подход использует легковесные управляющие объекты вместо тяжеловесных процессов.
Во-первых, это позволяет определить число обрабатываемых параллельно сущностей,
исходя из задачи, а не архитектуры компьютера или кластера. Это поощряет
программиста создавать столько объектов, сколько необходимо, руководствуясь
алгоритмом или ограничениями на размер структур данных из предметной области
задачи. В программе моделирования морского волнения минимальный размер каждой
части поверхности зависит от числа коэффициентов вдоль каждой из осей, и, в то
же время, количество частей должно быть больше, чем количество процессоров, для
того чтобы сделать нагрузку на процессоры более равномерной. Учитывая эти
ограничения оптимальный размер части определяется во время выполнения, и, в
общем случае, не совпадает с количеством параллельных процессов. Недостатком
является то, что, чем больше управляющих объектов в программе, тем больше общих
структур данных копируется на один и тот же узел вместе с подчиненными
объектами; проблема решается введением промежуточного слоя объектов, что в свою
очередь влечет увеличивает сложность программы. Во-вторых, иерархия управляющих
объектов совместно с иерархией узлов позволяет автоматически пересчитывать
завершившиеся некорректно подчиненные объекты на выживших узлах кластера в случае
выхода из строя оборудования. Это возможно, поскольку ход выполнения программы
сохраняется в каждом объекте, а не в глобальных переменных, как это делается в
программах MPI. Дублируя состояние на подчиненные узлы, система пересчитывает
только объекты из поврежденных процессов, а не программу целиком. Таким образом,
переход от процессов к управляющим объектам может увеличить производительность
параллельной программы путем динамической балансировки нагрузки, но также может
повлиять на ее масштабируемость на большое количество узлов из-за дублирования
состояния хода выполнения.

Может показаться, что три составляющих предлагаемого подхода\nbsp{}---
управляющие объекты, конвейеры и иерархии\nbsp{}--- ортогональны, но, на самом
деле, они дополняют друг друга. Если бы управляющие объекты не содержали в себе
состояние хода выполнения программы, то было бы невозможно пересчитать
завершившиеся некорректно подчиненные объекты и обеспечить отказоустойчивость.
Если бы иерархии узлов не было, то было бы невозможно распределить нагрузку
между узлами кластера, поскольку все узлы одинаковы без иерархии. Если бы для
каждого устройства не было конвейера, то было бы невозможно обрабатывать
управляющие объекты асинхронно и реализовать динамическую балансировку нагрузки.
Эти три сущности образуют замкнутую систему, в которую нечего добавить и из
которой нечего удалить\nbsp{}--- надежную основу для любой распределенной
программы.

Подводя итог, можно сказать, что управляющие объекты придают гибкости
параллельным программам: они балансируют снижение производительности за счет
использования общих очередей ее увеличением за счет динамической балансировки
нагрузки. Требуя больше оперативной памяти для работы, они позволяют выполнять
сразу несколько параллельных программ одновременно на всех узлах кластера без
простаивания в очереди задач, и превращают кластер в единую вычислительную
систему, которая делает все возможное для непрерывной работы распределенных
приложений.

** Реализация для систем с распределенной памятью (MPP)
:PROPERTIES:
:CUSTOM_ID: sec:arma-mpp
:END:

**** Распределенный алгоритм для модели АР.
Этот алгоритм в отличие от параллельной версии, использует копирование данных
для того чтобы выполнить вычисления на других узлах кластера, и, поскольку
пропускная способность сети гораздо меньше, чем у памяти, размер передаваемых по
сети данных должен быть оптимизирован для получения большей производительности,
чем на системе с общей памятью. Один из способов добиться этого\nbsp{}--- это
распределить части взволнованной поверхности между узлами кластера, копируя на
узлы коэффициенты и необходимы точки на границах, и, копируя обратно
сгенерированную часть взволнованной поверхности. Авторегрессионные зависимости
не позволяют создать все части сразу и статически распределить их между узлами
кластера, поэтому части создаются динамически на первом узле, когда точки, от
которых они зависят, становятся доступны. Таким образом, распределенный алгоритм
для модели АР является алгоритмом типа ведущий-ведомый, в котором ведущий
динамически создает задачи для каждой части взволнованной поверхности, принимая
во внимание авторегрессионные зависимости между точками, и отправляет их на
подчиненные узлы, а ведомые вычисляют каждую часть взволнованной поверхности и
отправляют ее обратно ведущему.

В реализации для систем с распределенной памятью каждая задача моделируется
управляющим объектом: существует руководящий объект, создающий подчиненные при
необходимости, и подчиненные объекты, генерирующие части взволнованной
поверхности. В методе ~act~ главного объекта создается подчиненный объект для
первой части\nbsp{}--- части, которая не зависит ни от каких других точек. Когда
этот объект возвращается, руководящий объект в методе ~react~ определяет, какие
части могут быть вычислены сейчас, создает подчиненный объект для каждой части и
отправляет его на конвейер. В методе ~act~ подчиненного объекта генерируется
часть взволнованной поверхности, а затем объект отправляет самого себя
руководителю. Метод ~react~ подчиненного объекта пустой.

Реализация распределенного алгоритма АР имеет ряд преимуществ по сравнению с
параллельной.
- Конвейеры автоматически распределяют подчиненные объекты между доступными
  узлами кластера, и приложение не имеет дела с такими низкоуровневыми деталями.
- Нет необходимости реализовать минималистичный планировщик задач, которые
  определят последовательность выполнения задач (объектов), учитывая
  авторегрессионные зависимости: порядок выполнения полностью определяется в
  методе ~react~ руководящего объекта.
- Нет необходимости в отдельной версии программы для машину с общей памятью,
  реализация работает прозрачно на любой количестве узлов, даже если планировщик
  задач не запущен.

**** Производительность реализации распределенного алгоритма для АР модели.
Реализация распределенной модели АР была протестирована на двух узлах системы
Ant (таб.\nbsp{}[[tab-ant]]). Для увеличения пропускной способности сети, два узла
были соединены друг с другом напрямую, а максимальный размер единицы
передаваемых данных (MTU) установлен в 9200 байт. Рассматривались два случая: с
одним резидентным процессом Bscheduler, запущенным на локальном узле, и с двумя
резидентными процессами, запущенными на каждом узле. Производительность программы
сравнивалась с производительностью версии на OpenMP, запускаемой на одном узле.

Bscheduler превосходит OpenMP как на одном, так и на двух узлах
(рис.\nbsp{}[[fig-bscheduler-performance]]). В случае одного узла более высокая
производительность объясняется тем, что Bscheduler не сканирует очередь задач в
поисках частей, для которых готовы все зависимости (как это происходит в
параллельной версии алгоритма), вместо этого он для каждой части обновляет
счетчик готовых частей, от которых она зависит. Такой же подход может быть
использован для версии OpenMP, однако он был обнаружен только в более новой
версии программы для Bscheduler, поскольку сканирование очереди задач не может
быть эффективно реализовано в рамках этого планировщика. В случае двух узлов
более высокая производительность объясняется большим суммарным количеством
процессорных ядер (16), высокой пропускной способностью прямого сетевого
соединения. Таким образом, реализация распределенного алгоритма модели АР на
Bscheduler быстрее на системе с общей памятью ввиду более эффективной обработки
авторегрессионных зависимостей, и его производительность масштабируется на
большее количество ядер ввиду низких накладных расходов на передачу данных по
прямому сетевому соединению.

#+name: fig-bscheduler-performance
#+begin_src R :file build/bscheduler-performance-ru.pdf
source(file.path("R", "benchmarks.R"))
par(family="serif")
data <- arma.load_bscheduler_performance_data()
arma.plot_bscheduler_performance_data(
  data,
  list(
    openmp="OpenMP",
    bsc1="Bscheduler (один узел)",
    bsc2="Bscheduler (два узла)"
  )
)
title(xlab="Размер взволнованной поверхности", ylab="Время, сек.")
#+end_src

#+name: fig-bscheduler-performance
#+caption: Сравнение производительности Bscheduler и OpenMP.
#+RESULTS: fig-bscheduler-performance
[[file:build/bscheduler-performance-ru.pdf]]

* Заключение
**** Итоги исследования.
В изучении возможностей математического аппарата для имитационного моделирования
морского волнения, выходящего за рамки линейной теории волн, были достигнуты
следующие основные результаты.
- Процесс АРСС был использован для моделирования морских волн произвольных
  амплитуд. Интегральные характеристики генерируемой взволнованной поверхности
  были верифицированы путем сопоставления с характеристиками реальной морской
  поверхности.
- Новый метод был использован для вычисления поля потенциала скорости под
  генерируемой поверхностью. Получившееся поле потенциалов скоростей было
  верифицировано путем сравнения с полем, вычисляемым по формулам из линейной
  теории волн. Новый метод эффективен с вычислительной точки зрения, поскольку
  все интегралы в его формуле записываются как преобразования Фурье, для
  которого существуют высокопроизводительные реализации.
- Модель и метод были реализована для систем как с общей, так и с распределенной
  памятью, и в нескольких тестах показали масштабируемость на различном
  количество ядер, которая близка к линейной. Модель АР более эффективна с
  вычислительной точки зрения на центральном процессоре, нежели на видеокарте, и
  превосходит по производительности модель ЛХ.

**** Перспективы дальнейших исследований.
Одной из тем дальнейших исследований является изучение возможности генерации
волн произвольных профилей на базе смешанного процесса АРСС. Другим направлением
является интеграция разработанной модели и метода расчета давлений в
существующие пакеты прикладного программного обеспечения.

* Выводы
Результаты исследования позволяют сделать вывод о том, что задача вычисления
давлений под реальной морской поверхностью может быть решена аналитически,
минуя предположения линейной теории волн и теории волн малой амплитуды. Это
решение в паре с моделью АРСС морского волнения, способной
генерировать волны произвольных амплитуд, может быть использовано для расчета
влияния колебаний волн на поведение динамического объекта в открытом море, и
дает более точные результаты чем аналогичное решение для волн малых амплитуд.

Результаты проведенных численных экспериментов позволяют сделать вывод о том,
что как генерация взволнованной поверхности так и расчет гидродинамических
давлений могут быть реализованы эффективно с использованием алгоритмов быстрого
преобразования Фурье, и длительные сессии имитационного моделирования могут
проводиться.

Разработанный в работе математический аппарат и его численная реализация могут
стать основой виртуального полигона, предназначенного для расчетов динамики
морских объектов.

* Благодарности
Графики в этой работе были подготовлены с помощью языка для статистических
вычислений R\nbsp{}cite:rlang2016,Sarkar2008lattice и программного обеспечения
Graphviz\nbsp{}cite:Gansner00anopen. Документ был подготовлен с использованием
Org-mode\nbsp{}cite:Schulte2011org2,Schulte2011org1,Dominik2010org для GNU
Emacs, предоставляющего вычислительное окружение для воспроизводимых
исследований. Это означает, что все графики можно воспроизвести и
соответствующие утверждения проверить, скопировав репозиторий
диссертации[fn:repo], установив Emacs и экспортировав документ.

Исследования были выполнены в рамках грантов РФФИ
(проекты\nbsp{}\mbox{16-07-01111}, \mbox{16-07-00886}, \mbox{16-07-01113}).

[fn:repo] [[https://github.com/igankevich/arma-thesis]]

* Список сокращений и условных обозначений
- <<<MPP>>> :: Massively Parallel Processing, класс вычислительных систем с разделенной памятью.
- <<<SMP>>> :: Symmetric Multi-Processing, класс вычислительных систем с общей памятью.
- <<<GPGPU>>> :: General-purpose computing on graphics processing units,
                 вычисления общего назначения на графических ускорителях.
- <<<АКФ>>> :: автоковариационная функция.
- <<<БПФ>>> :: быстрое преобразование Фурье.
- <<<ГПСЧ>>> :: генератор псевдослучайных чисел.
- <<<ГУ>>> :: граничное условие.
- <<<ДУЧП>>> :: дифференциальное уравнение в частных производных.
- <<<НБП>>> :: нелинейное безынерционное преобразование.
- <<<АР>>> :: процесс авторегрессии.
- <<<АРСС>>> :: процесс авторегрессии скользящего среднего.
- <<<СС>>> :: процесс скользящего среднего.
- <<<ЛХ>>> :: модель Лонге---Хиггинса.
- <<<LAMP>>> :: Large Amplitude Motion Programme, программа для моделирования
качки судна на морских волнах.
- <<<ЦПТ>>> :: центральная предельная теорема.
- <<<ПМ>>> :: аппроксимация Пирсона---Московица для спектра морского волнения.
- <<<ЮУ>>> :: система уравнений Юла---Уокера.
- <<<МНК>>> :: метод наименьших квадратов.
- <<<ФПР>>> :: функция плотности распределения.
- <<<ФР>>> :: функция распределения.
- <<<BSP>>> :: Bulk Synchronous Parallel.
- <<<OpenCL>>> :: Open Computing Language.
- <<<OpenGL>>> :: Open Graphics Library.
- <<<OpenMP>>> :: Open Multi-Processing.
- <<<MPI>>> :: Message Passing Interface.
- <<<POSIX>>> :: Portable Operating System.
- <<<FMA>>> :: Fused multiply-add.
- <<<DCMT>>> :: Dynamic creation of Mersenne Twisters.
- <<<GSL>>> :: GNU Scientific Library.
- <<<BLAS>>> :: Basic Linear Algebra Sub-programmes.
- <<<LAPACK>>> :: Linear Algebra Package.
- <<<DNS>>> :: Dynamic name resolution.
- <<<HPC>>> :: High-performance computing.
- <<<РГШ>>> :: Распределение на основе ряда Грама---Шарлье.
- <<<АНР>>> :: Асимметричное нормальное распределение.
- Трансцендентные функции :: математические функции, не являющиеся
     алгебраическими (т.е.\nbsp{}логарифмические, тригонометрические и др.).

#+begin_export latex
\input{postamble}
#+end_export

bibliographystyle:ugost2008
bibliography:bib/refs.bib

* Приложение
** Вывод формулы модели Лонге---Хиггинса
:PROPERTIES:
:CUSTOM_ID: longuet-higgins-derivation
:END:

Двухмерная система уравнений\nbsp{}eqref:eq-problem в рамках линейной теории
волн записывается как
\begin{align*}
    & \phi_{xx} + \phi_{zz} = 0,\\
    & \zeta(x,t) = -\frac{1}{g} \phi_t, & \text{на }z=\zeta(x,t),
\end{align*}
где \(\frac{p}{\rho}\) включено в \(\phi_t\). Решение уравнения Лапласа ищется в
виде ряда Фурье cite:kochin1966theoretical:
\begin{equation*}
    \phi(x,z,t) = \int\limits_{0}^{\infty} e^{k z}
    \left[ A(k, t) \cos(k x) + B(k, t) \sin(k x) \right] dk.
\end{equation*}
Подставляя его в граничное условие, получаем
\begin{align*}
    \zeta(x,t) &= -\frac{1}{g} \int\limits_{0}^{\infty}
    \left[ A_t(k, t) \cos(k x) + B_t(k, t) \sin(k x) \right] dk \\
    &= -\frac{1}{g} \int\limits_{0}^{\infty} C_t(k, t) \cos(kx + \epsilon(k, t)).
\end{align*}
Здесь \(\epsilon\)\nbsp{}--- белый шум, а \(C_t\) включает в себя значение \(dk\).
Подставляя бесконечную сумму вместо интеграла, получаем двухмерную форму
ур.\nbsp{}[[eq-longuet-higgins]].

** Производная в направлении нормали к поверхности
:PROPERTIES:
:CUSTOM_ID: directional-derivative
:END:

Производная от \(\phi\) в направлении вектора \(\vec{n}\) определяется как
\(\nabla_n\phi=\nabla\phi\cdot\frac{\vec{n}}{|\vec{n}|}\). Вектор \(\vec{n}\),
направленный по нормали к поверхности \(z=\zeta(x,y)\) в точке \((x_0,y_0)\)
определяется как
\begin{equation*}
  \vec{n} = \begin{bmatrix}\zeta_x(x_0,y_0)\\\zeta_y(x_0,y_0)\\-1\end{bmatrix}.
\end{equation*}
Отсюда производная в направлении нормали к поверхности определяется
\begin{equation*}
\nabla_n \phi = \phi_x \frac{\zeta_x}{\sqrt{\zeta_x^2+\zeta_y^2+1}}
    + \phi_y \frac{\zeta_y}{\sqrt{\zeta_x^2+\zeta_y^2+1}}
    + \phi_z \frac{-1}{\sqrt{\zeta_x^2+\zeta_y^2+1}},
\end{equation*}
где производные \(\zeta\) вычисляются в \((x_0,y_0)\).
